<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width" />

<title>Minimal Card Hand (PWA)</title>

<!-- PWA meta tags -->
<meta name="theme-color" content="#121212">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="apple-touch-icon" href="data:image/png;base64,iVBORw0KGgo=">

<style>
:root {
    --card-h: calc(30vh - 4vh);
    --card-w: calc(var(--card-h) * (63.5 / 88.9));
    --color: #fff;

    --bg: #121212;
    --panel: #1a1a1a;
    --accent: #49a6ff;
    --muted: #6b6b6b;
}

html, body {
    margin: 0;
    padding: 0;
    background: #121212;
    overflow: hidden;
    font-family: sans-serif;
    width: 100%;
    height: 100%;
    color: var(--color);
}

body {
    display: flex;
    flex-direction: column;
}

/* ===== HAND AREA ===== */
.hand-area {
    width: 100vw;
    display: flex;
    gap: 1vw;
    align-items: center;
    overflow-x: auto;
    overflow-y: visible;
    white-space: nowrap;
    background: #1a1a1a;
    border-top: 2px solid #1f1f1f;
    scrollbar-width: none;
}
.hand-area::-webkit-scrollbar { display: none; }

#p1-hand-area {
    height: 30vh;
    position: absolute;
    bottom: 0;
}

#p2-hand-area {
    transform: rotateZ(180deg);
    overflow: hidden;
    height:     3vh;
    min-height: 3vh;
    max-height: 3vh;
    position: relative;
}

/* ===== Cards ===== */
.card {
    flex: 0 0 auto;
    width: var(--card-w);
    height: var(--card-h);
    max-height: 28vh;
    background: #222;
    color: #fff;
    border-radius: 10px;
    border: 1px solid rgba(255,255,255,0.2);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2.3vh;
    transition: transform 0.18s ease;
    transform-origin: bottom center;
    position: relative;
}

/* ===== GamePlay ===== */
#game-wrapper {
    margin: auto;
    width: 100%;
    top: 3vh;
    height: 67vh;
    position: absolute;
}

#game-play {
    position: relative;
    width: 210vw;
    height: 130vh;
    left: -55vw;
    top: -40vh;
    transform: scale(0.40) perspective(100vh) rotateX(20deg);
}

.field-container {
    height: 60vh;
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: visible;
    margin: 2vh;
    padding: 2vh;
}

/* make the battlefield a stable 5-column grid */
.field-row {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 3vw;
  align-items: start;
  padding: 8vw;
  box-sizing: border-box;
  width: 100%;
  height: 100%;
  background: var(--panel);
}

/* inside the battlefield, cards take full grid cell,
   keep aspect ratio so they don't squish */
.field-row .card,
.field-row .flip-wrapper {
  margin: 0;
  width: 100% !important;
  height: auto !important;
  aspect-ratio: 63.5 / 88.9;
  max-height: calc( (100vh - 120px) / 2 );
  box-sizing: border-box;
  display: block;
}

/* if you want the cards slightly smaller in tight heights */
@media (max-height: 640px) {
  .field-row .card { max-height: 20vh; }
}

#end-turn {
    position: absolute;
    right: 10px;
    bottom: 32vh;
    padding: 10px 16px;
    width: 6rem;
    background: var(--accent);
    border: none;
    border-radius: 6px;
    color: #fff;
    font-weight: 700;
    cursor: pointer;
}

/* ---------- Notification ---------- */
#notif {
    position: fixed;
    left: 18px;
    bottom: 18px;
    z-index: 12000;
    pointer-events: none;
    font-weight: 700;
    color: #fff;
    background: rgba(0, 0, 0, 0.5);
    padding: 8px 12px;
    border-radius: 10px;
    backdrop-filter: blur(4px);
    opacity: 0;
    transform: translateY(10px);
    transition:
        opacity 0.28s ease,
        transform 0.28s ease;
}
#notif.show {
    opacity: 1;
    transform: translateY(0);
}

/* ---------- Card base (visual border on card wrapper) ---------- */
.card {
    width: var(--card-w);
    height: var(--card-h);
    max-height: 100%;
    background: #222;
    /* FORCE a visible border so cards always show a frame */
    border: 2px solid rgba(255, 255, 255, 0.82) !important;
    border-radius: 10px;
    padding: 8px;
    margin: 2vw;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    transform-origin: center;
    transition:
        transform 0.16s ease,
        box-shadow 0.16s ease;
    position: relative;
    user-select: none;
    opacity: 0;
    transform: translateY(14px) scale(0.98);
    animation: cardDrop 0.26s ease forwards;
    box-sizing: border-box;
}
@keyframes cardDrop {
    from {
        opacity: 0;
        transform: translateY(14px) scale(0.98);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}
.card:hover {
    transform: translateY(-6px) scale(1.02);
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.45);
}

.card-image {
    width: 100%;
    height: 50%;
    border-radius: 6px;
    background: #333;
    background-size: cover;
    background-position: center;
    position: relative;
}
#p2-field .card-image {
    transform: rotateX(0deg);
}
.card-name {
    font-weight: 700;
    font-size: 10px;
    white-space: normal;
}
.card-text {
    font-size: 8px;
    opacity: 0.85;
    min-height: 30px;
    margin-top: 6px;
    white-space: normal;
}
.card-stats {
    display: flex;
    justify-content: space-between;
    font-size: 10px;
    margin-top: 6px;
}

/* field drop (slower more dramatic) */
.card.field-drop {
    animation: cardFieldDrop 0.36s cubic-bezier(0.2, 0.9, 0.2, 1) forwards;
}
@keyframes cardFieldDrop {
    from {
        opacity: 0;
        transform: translateY(28px) scale(0.9) rotate(-2deg);
    }
    60% {
        transform: translateY(-8px) scale(1.02) rotate(0);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

/* draw-in (hand) */
.card.draw-in {
    animation: cardDrawIn 0.36s cubic-bezier(0.2, 0.9, 0.2, 1) forwards;
}
@keyframes cardDrawIn {
    from {
        opacity: 0;
        transform: translateY(20px) scale(0.88) rotate(-3deg);
    }
    60% {
        transform: translateY(-6px) scale(1.02);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

/* attack wiggle (soft) */
.card.attack-animation {
    animation: attackAnim 0.34s ease;
}
@keyframes attackAnim {
    0% {
        transform: translateX(0);
    }
    40% {
        transform: translateX(-10px);
    }
    70% {
        transform: translateX(4px);
    }
    100% {
        transform: translateX(0);
    }
}

/* hit flash */
.card.hit-flash {
    animation: hitFlash 0.28s ease;
}
@keyframes hitFlash {
    0% {
        box-shadow: 0 0 0 rgba(255, 255, 255, 0);
    }
    30% {
        box-shadow: 0 0 14px rgba(255, 220, 120, 0.9);
    }
    100% {
        box-shadow: 0 0 0 rgba(255, 220, 120, 0);
    }
}

/* Card destroy effect (fix for opponent cards with rotateY) */
.card.destroying {
    animation: destroyAnim 0.5s forwards;
    position: absolute !important;
    left: 0; top: 0;
    z-index: 100;
}

@keyframes destroyAnim {
    0% {
        filter: drop-shadow(0 0 0 rgba(255, 255, 255, 0));
        opacity: 1;
        transform: rotateY(var(--card-rotateY, 0deg)) scale(1) rotate(0deg);
    }
    30% {
        filter: drop-shadow(0 0 15px rgba(255, 255, 200, 0.8));
        transform: rotateY(var(--card-rotateY, 0deg)) scale(1.1) rotate(5deg);
    }
    60% {
        filter: drop-shadow(0 0 30px rgba(255, 255, 200, 1));
        transform: rotateY(var(--card-rotateY, 0deg)) scale(0.95) rotate(-5deg);
        opacity: 0.6;
    }
    100% {
        filter: drop-shadow(0 0 0 rgba(255, 255, 200, 0));
        opacity: 0;
        transform: rotateY(var(--card-rotateY, 0deg)) scale(0.5) rotate(15deg);
    }
}

/* tapped */
.tapped {
    opacity: 0.5 !important;
    transform: rotate(5deg) !important;
}

/* attacker outline */
.attacker {
    outline: 3px solid rgba(255, 220, 80, 0.95);
    box-shadow: 0 10px 30px rgba(255, 220, 80, 0.06);
}

/* ---------- Flip (reveal) wrappers (NO visual border/padding) ---------- */
.flip-wrapper,
.flip {
    border: none !important;
    padding: 0 !important;
    background: transparent !important;
    box-shadow: none !important;
}
.flip-wrapper {
    perspective: 900px;
    position: relative;
    display: inline-block;
}
.flip {
    transform-style: preserve-3d;
    transition: transform 0.42s cubic-bezier(0.2, 0.9, 0.2, 1);
    width: 100%;
    height: 100%;
    position: relative;
    outline: 1px solid rgba(192, 192, 192, 0.95);
    border-radius: 8px;
}

#p1-field .flip.show-back {
    transform: rotateY(180deg);
}
.face {
    backface-visibility: hidden;
    position: absolute;
    width: 100%;
    height: 100%;
    padding: 8px;
    box-sizing: border-box;
    border-radius: 8px;
}
.face.front {
    position: relative;
}
.face.back {
    transform: rotateY(180deg);
    top: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    background: linear-gradient(120deg, #2b2b2b, #222);
}

/* tooltip */
.tooltip {
    position: absolute;
    bottom: calc(100% + 8px);
    left: 50%;
    transform: translateX(-50%) translateY(6px);
    background: rgba(18, 18, 18, 0.98);
    padding: 8px 10px;
    border-radius: 6px;
    font-size: 12px;
    opacity: 0;
    pointer-events: none;
    transition:
        transform 0.18s ease,
        opacity 0.18s ease;
    box-shadow: 0 6px 18px rgba(0, 0, 0, 0.6);
    z-index: 40;
}
.card:hover .tooltip {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
}

/* projectile */
.proj {
    position: fixed;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: radial-gradient(circle, #ffd9a3 0%, #ff8a00 60%);
    pointer-events: none;
    z-index: 9999;
    transform: translate3d(0, 0, 0);
    transition:
        transform 0.42s linear,
        opacity 0.42s linear;
}

/* hp pop */
.hp-pop {
    position: fixed;
    font-weight: 800;
    color: #ffdddd;
    text-shadow: 0 2px 6px rgba(0, 0, 0, 0.7);
    z-index: 10000;
    pointer-events: none;
    transform: translateY(0);
    opacity: 1;
    transition:
        transform 0.7s cubic-bezier(0.2, 0.9, 0.2, 1),
        opacity 0.7s ease;
}
.hp-pop.heal {
    color: #d8ffd8;
}
.hp-pop.hide {
    opacity: 0;
    transform: translateY(-40px);
}

#p2-field {
    transform: rotate(180deg);
}

#p2-field .card {
    transform: rotate(180deg);
}

#p2-field .tooltip {
    transform: rotateX(180deg);
}

#p2-field .flip.show-back {
  transform: rotateY(-180deg);
}

</style>
</head>
<body>

<div id="p2-hand-area" class="hand-area">
    Text
</div>

<div id="game-wrapper">
    <div id="game-play">
        <div id="p2-container" class="field-container">
            <div id="p2-field" class="field-row" style="transform: rotateZ(180deg);">
            </div>
        </div>

        <div id="p1-container" class="field-container">
            <div id="p1-field" class="field-row">
            </div>
        </div>
    </div>
</div>

<div id="p1-hand-area" class="hand-area"></div>

<button id="end-turn">End Turn</button>
<div id="notif" aria-hidden="true"></div>
  <div id="addToHomeBanner" class="add-to-home" style="display:none; position: absolute; width: calc(90vw - 40px); height: auto; bottom: 4vh; background: black; border-radius: 8px; margin: 0 5vw; text-align: center; padding: 20px; font-size: 12px;">
    <div class="banner shadow">
      <a href="" id="closeButton" class="close-button" style="position: absolute; top: 3px; right: 8px; text-decoration: none; color: white;">&times;</a>
      <div class="text">
        You can install this app on your device, simply tap<br>
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" style="position: relative; top: 6px;" viewBox="0 0 50 50" fill="currentColor">
          <path fill="currentColor" d="M30.3 13.7L25 8.4l-5.3 5.3-1.4-1.4L25 5.6l6.7 6.7z"/>
          <path fill="currentColor" d="M24 7h2v21h-2z"/>
          <path fill="currentColor" d="M35 40H15c-1.7 0-3-1.3-3-3V19c0-1.7 1.3-3 3-3h7v2h-7c-.6 0-1 .4-1 1v18c0 .6.4 1 1 1h20c.6 0 1-.4 1-1V19c0-.6-.4-1-1-1h-7v-2h7c1.7 0 3 1.3 3 3v18c0 1.7-1.3 3-3 3z"/>
        </svg>
        and then 'Add to Home Screen'.
      </div>
    </div>
  </div>

<script>
// =======================
// Add to Home Screen
// =======================

function isEligible() {
  const ua = navigator.userAgent.toLowerCase();

  const isiOS = /iphone|ipad|ipod/.test(ua);
  const isSafari = /safari/.test(ua) && !/crios|fxios|opios/.test(ua);
  const isChrome = /crios/.test(ua);

  // Safari PWA support check
  let safariVersionSupported = false;
  if (isSafari) {
    const match = navigator.userAgent.match(/Version\/(\d+(\.\d+)?)/);
    if (match) safariVersionSupported = parseFloat(match[1]) >= 16.4;
  }

  // Safari: real support
  if (isSafari && safariVersionSupported) return true;

  // Chrome: show banner anyway (optional)
  if (isChrome && isiOS) return true;

  return false;
}

document.addEventListener('DOMContentLoaded', () => {
  if (isEligible()) {
    document.getElementById('addToHomeBanner').style.display = 'block';
    document.getElementById('closeButton').addEventListener('click', (e) => {
      e.preventDefault();
      document.getElementById('addToHomeBanner').style.display = 'none';
    });
  }
});
</script>

<script>

// =======================
// Game Settings
// =======================

const life        = 20;
const startCards  = 4;
const maxCards    = 7;
const maxDeckSize = 30;

</script>

<script>
// =======================
// PWA Manifest (Blob)
// =======================
const manifest = {
    name: "Minimal Card Hand",
    short_name: "TCG",
    start_url: ".",
    display: "standalone",
    background_color: "#121212",
    theme_color: "#121212",
    icons: [{
        src: "data:image/png;base64,iVBORw0KGgo=",
        sizes: "192x192",
        type: "image/png"
    }]
};
const blob = new Blob([JSON.stringify(manifest)], {type: "application/json"});
const url = URL.createObjectURL(blob);
const link = document.createElement("link");
link.rel = "manifest";
link.href = url;
document.head.appendChild(link);

// =======================
// Service Worker
// =======================
if ('serviceWorker' in navigator) {
    const swCode = `
        self.addEventListener('install', e => self.skipWaiting());
        self.addEventListener('activate', e => clients.claim());
        self.addEventListener('fetch', e => {
            e.respondWith(fetch(e.request).catch(() => new Response('', {status:200})));
        });
    `;
    const swBlob = new Blob([swCode], {type: "text/javascript"});
    const swURL = URL.createObjectURL(swBlob);
    navigator.serviceWorker.register(swURL);
}

</script>




<script>
/* ============================
Core Data & Helpers
============================ */
const MASTER_CARDS = [
    {
        id: "fire-dragon",
        name: "Fire Dragon",
        attack: 7,
        health: 5,
        cost: 4,
        text: "Breathes fire for +2 damage.",
        image: "",
    },
    {
        id: "forest-wolf",
        name: "Forest Wolf",
        attack: 3,
        health: 2,
        cost: 1,
        text: "Fast and agile.",
        image: "",
    },
    {
        id: "guardian-golem",
        name: "Guardian Golem",
        attack: 1,
        health: 8,
        cost: 3,
        text: "Takes reduced damage.",
        image: "",
    },
    {
        id: "light-mage",
        name: "Light Mage",
        attack: 2,
        health: 3,
        cost: 2,
        text: "Can heal allies.",
        image: "",
    },
    {
        id: "shadow-assassin",
        name: "Shadow Assassin",
        attack: 5,
        health: 1,
        cost: 2,
        text: "Strikes first.",
        image: "",
    },
];

const players = [
    { name: "Player 1", deck: [], hand: [], field: [], mana: 1, maxMana: 1, life: 20 },
    { name: "Player 2", deck: [], hand: [], field: [], mana: 1, maxMana: 1, life: 20 },
];

let currentPlayer = 0;
let selectedAttacker = null;

/* uid generator */
function uid(prefix = "c") {
    return prefix + "-" + Math.floor(Math.random() * 1e9).toString(36) + "-" + Date.now().toString(36);
}

/* clone base card + assign uid */
function cloneCard(id) {
    const base = MASTER_CARDS.find((c) => c.id === id);
    const copy = JSON.parse(JSON.stringify(base));
    copy.uid = uid("card");
    return copy;
}

/* shuffle */
function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
}

/* build decks */
function buildDeck() {
    const ids = MASTER_CARDS.map((c) => c.id);
    players.forEach((p) => {
        p.deck = [];
        for (let i = 0; i < 10; i++) {
            p.deck.push(cloneCard(ids[i % ids.length]));
        }
        shuffle(p.deck);
    });
}

/* notification helper */
function showNotif(text, time = 1400) {
    const n = document.getElementById("notif");
    n.textContent = text;
    n.classList.add("show");
    setTimeout(() => n.classList.remove("show"), time);
    console.info("[NOTIF]", text);
}

/* ============================
Rendering
============================ */

function renderGame() {
    renderHand(0); // P1
    renderHand(1); // P2
    renderField();
    updateLifeDisplay();
}

function updateLifeDisplay() {
    // document.getElementById("p1-life").textContent = players[0].life;
    // document.getElementById("p2-life").textContent = players[1].life;
}

/* create card element (wrapper with flip support & tooltip)
wrapper has .card class so visual border stays on wrapper.
*/

function createCardElement(card, inField = false) {
    const wrapper = document.createElement("div");
    wrapper.className = "card flip-wrapper";
    wrapper.dataset.uid = card.uid || "";
    wrapper.dataset.owner = card.owner ?? 0;

    const innerFlip = document.createElement("div");
    innerFlip.className = "flip";

    const front = document.createElement("div");
    front.className = "face front";
    front.innerHTML = `
<div class="card-image" style="background-image:url(${card.image})"></div>
<div class="card-name">${card.name}</div>
<div class="card-text">${card.text}</div>
<div class="card-stats"><span>ATK:${card.attack}</span><span>HP:${card.health}</span></div>
`;

    const back = document.createElement("div");
    back.className = "face back";
    back.textContent = card.name;

    innerFlip.append(front, back);
    wrapper.appendChild(innerFlip);

    // Opponent cards are face-down in hand
    if (!inField && card.owner === 1) {
        innerFlip.classList.add("show-back");
        wrapper.style.transform = "rotateX(180deg)";
    }

    if (inField) wrapper.classList.add("field-drop");
    if (card.tapped) wrapper.classList.add("tapped");
    if (selectedAttacker === card) wrapper.classList.add("attacker");

    // Make sure wrapper is clickable
    wrapper.style.pointerEvents = "auto";

    return wrapper;
}

// --- Hand rendering ---
function renderP1Hand() {
    const hand = document.getElementById("p1-hand-area");
    hand.innerHTML = "";
    players[0].hand.forEach((card, idx) => {
        card.owner = 0;
        const el = createCardElement(card);
        el.onclick = () => playCard(idx);
        hand.appendChild(el);
    });
}

function renderP2Hand() {
    const hand = document.getElementById("p2-hand-area");
    hand.innerHTML = "";
    players[1].hand.forEach((card) => {
        card.owner = 1;
        const el = createCardElement(card);
        hand.appendChild(el); // no click for opponent cards
    });
}

function updateTurnDisplay() {
    // const turnDiv = document.getElementById("turn-display");
    // turnDiv.textContent = (currentPlayer === 0 ? "Player 1's Turn" : "Player 2's Turn");
}

function renderField() {
    const p1 = document.getElementById("p1-field");
    const p2 = document.getElementById("p2-field");
    p1.innerHTML = "";
    p2.innerHTML = "";

    // Player 1 field
    players[0].field.forEach((c, i) => {
        const el = createCardElement(c, true);
        el.dataset.owner = 0;
        el.dataset.index = i;
        el.onclick = () => fieldCardClicked(0, i);
        p1.appendChild(el);
    });

    // Player 2 field
    players[1].field.forEach((c, i) => {
        const el = createCardElement(c, true);
        el.dataset.owner = 1;
        el.dataset.index = i;
        el.onclick = () => fieldCardClicked(1, i);
        p2.appendChild(el);
    });

    // Direct attack: click on empty space
    p2.parentElement.onclick = (e) => {
        if (!selectedAttacker) return;
        if (e.target === p2.parentElement) {
            attackPlayer(selectedAttacker, players[1]);
            selectedAttacker = null;
        }
    };
    p1.parentElement.onclick = (e) => {
        if (!selectedAttacker) return;
        if (e.target === p1.parentElement) {
            attackPlayer(selectedAttacker, players[0]);
            selectedAttacker = null;
        }
    };
}

function findCardElement(card) {
    if (!card || !card.uid) return null;
    return document.querySelector(`[data-uid="${card.uid}"]`);
}
</script>

<script>
/* Game logic (functions defined BEFORE event wiring) */
function updateTopBar() {
    document.getElementById("turn-info").textContent = players[currentPlayer].name + "'s Turn";
    document.getElementById("mana-info").textContent =
        `Mana: ${players[currentPlayer].mana} / ${players[currentPlayer].maxMana}`;
}

// function createCardElement(card, inField=false){
//   const wrapper = document.createElement('div');
//   wrapper.className = 'card';
//   wrapper.dataset.uid = card.uid || '';

//   const front = document.createElement('div');
//   front.className = 'card-image';
//   front.style.backgroundImage = `url(${card.image})`;

//   const nameEl = document.createElement('div');
//   nameEl.className = 'card-name';
//   nameEl.textContent = card.name;

//   const textEl = document.createElement('div');
//   textEl.className = 'card-text';
//   textEl.textContent = card.text;

//   const statsEl = document.createElement('div');
//   statsEl.className = 'card-stats';
//   statsEl.innerHTML = `<span>ATK: ${card.attack}</span><span>HP: ${card.health}</span>`;

//   wrapper.append(front, nameEl, textEl, statsEl);

//   if(card.tapped) wrapper.classList.add('tapped');
//   if(selectedAttacker === card) wrapper.classList.add('attacker');
//   if(inField) wrapper.classList.add('field-drop');

//   return wrapper;
// }

function renderHand(playerIndex) {
    const hand =
        playerIndex === 0
            ? document.getElementById("p1-hand-area")
            : document.getElementById("p2-hand-area");
    hand.innerHTML = "";
    players[playerIndex].hand.forEach((card, idx) => {
        const el = createCardElement(card);
        if (playerIndex === currentPlayer) {
            el.onclick = () => playCard(idx);
        }
        hand.appendChild(el);
    });
}

function drawCard(player) {
    if (player.deck.length > 0) {
        const card = player.deck.pop();
        card._justDrawn = true; // A2: mark so draw triggers flip and draw-in animations
        player.hand.push(card);
        return card;
    }
    return null;
}

function playCard(handIndex) {
    const p = players[currentPlayer];
    const card = p.hand[handIndex];
    if (!card) return;
    if (card.cost > p.mana) {
        showNotif("Not enough mana!");
        return;
    }
    p.mana -= card.cost;
    card.owner = currentPlayer;
    p.field.push(card);
    p.hand.splice(handIndex, 1);
    renderGame();

    // A2: flip when entering battlefield (soft reveal)
    requestAnimationFrame(() => {
        const el = findCardElement(card);
        if (el) {
            const flipInner = el.querySelector(".flip");
            if (flipInner) {
                flipInner.classList.add("show-back");
                setTimeout(() => flipInner.classList.remove("show-back"), 420);
            }
        }
    });
}

function attackCard(attacker, defender) {
    showNotif(`${attacker.name} attacks ${defender.name}!`, 900);

    const attackerDom = findCardElement(attacker);
    const defenderDom = findCardElement(defender);

    if (attackerDom) {
        const inner = attackerDom.querySelector(".flip") || attackerDom;
        inner.classList.add("attack-animation");
        inner.addEventListener("animationend", () => inner.classList.remove("attack-animation"), {
            once: true,
        });
    }

    if (attackerDom && defenderDom) {
        const aRect = attackerDom.getBoundingClientRect();
        const dRect = defenderDom.getBoundingClientRect();
        const startX = aRect.left + aRect.width / 2;
        const startY = aRect.top + aRect.height / 2;
        const endX = dRect.left + dRect.width / 2;
        const endY = dRect.top + dRect.height / 2;

        const proj = document.createElement("div");
        proj.className = "proj";
        document.body.appendChild(proj);
        proj.style.left = startX - 9 + "px";
        proj.style.top = startY - 9 + "px";
        proj.style.opacity = "1";

        requestAnimationFrame(() => {
            proj.style.transform = `translate(${endX - startX}px, ${endY - startY}px)`;
            proj.style.opacity = "0.95";
        });

        setTimeout(() => {
            proj.remove();
            const dInner = defenderDom.querySelector(".flip") || defenderDom;
            if (dInner) {
                dInner.classList.add("hit-flash");
                setTimeout(() => dInner.classList.remove("hit-flash"), 300);
            }

            showHpPop(defender, endX, endY, -attacker.attack);

            defender.health -= attacker.attack;
            attacker.health -= defender.attack;
            attacker.tapped = true;

            // remove dead cards
            // handle destroyed cards with effect
            players.forEach((p) => {
                p.field.forEach((c) => {
                    if (c.health <= 0) {
                        const el = findCardElement(c);
                        if (el) {
                            if (el.closest("#p2-field")) {
                                el.style.setProperty("--card-rotateY", "180deg");
                            } else {
                                el.style.setProperty("--card-rotateY", "0deg");
                            }
                            el.classList.add("destroying");
                            setTimeout(() => {
                                p.field = p.field.filter((f) => f.uid !== c.uid);
                                renderGame();
                            }, 500);
                        }
                        if (el) {
                            el.classList.add("destroying");
                            setTimeout(() => {
                                p.field = p.field.filter((f) => f.uid !== c.uid);
                                renderGame();
                            }, 500); // match animation duration
                        } else {
                            p.field = p.field.filter((f) => f.uid !== c.uid);
                        }
                    }
                });
            });
        }, 420);
    } else {
        defender.health -= attacker.attack;
        attacker.health -= defender.attack;
        attacker.tapped = true;
        players.forEach((p) => (p.field = p.field.filter((c) => c.health > 0)));
        renderGame();
    }
}

function fieldCardClicked(ownerIndex, fieldIndex) {
    const card = players[ownerIndex].field[fieldIndex];

    if (ownerIndex === currentPlayer) {
        if (card.tapped) {
            showNotif("Card is tapped!");
            return;
        }
        selectedAttacker = card;
        renderGame();
        return;
    }

    // If an attacker is selected
    if (!selectedAttacker) return;

    if (ownerIndex === (currentPlayer === 0 ? 1 : 0)) {
        // Defender card exists: normal attack
        attackCard(selectedAttacker, card);
    } else {
        // No card? Attack opponent directly
        attackPlayer(selectedAttacker, players[ownerIndex]);
    }

    selectedAttacker = null;
    renderGame();
}

function attackPlayer(attacker, targetPlayer) {
    showNotif(`${attacker.name} attacks ${targetPlayer.name}!`, 900);

    // Reduce life
    targetPlayer.life -= attacker.attack;
    attacker.tapped = true;

    // Show HP pop near opponent row
    const field =
        targetPlayer === players[0]
            ? document.getElementById("p1-field")
            : document.getElementById("p2-field");
    const rect = field.getBoundingClientRect();
    showHpPop(
        { name: targetPlayer.name },
        rect.left + rect.width / 2,
        rect.top + rect.height / 2,
        -attacker.attack
    );

    renderGame();
}

function endTurn() {
    selectedAttacker = null;
    currentPlayer = currentPlayer === 0 ? 1 : 0;

    const p = players[currentPlayer];
    p.maxMana = Math.min(10, p.maxMana + 1);
    p.mana = p.maxMana;
    p.field.forEach(c => c.tapped = false);

    drawCard(p); // <--- must pass player object, not index

    // Update mana display
    // document.getElementById("p1-mana").textContent = players[0].mana;
    // document.getElementById("p2-mana").textContent = players[1].mana;

    // Update turn display
    updateTurnDisplay();

    renderGame();
}



/* HP pop visual */
function showHpPop(card, x, y, delta) {
    const pop = document.createElement("div");
    pop.className = "hp-pop" + (delta > 0 ? " heal" : "");
    pop.textContent = delta > 0 ? "+" + delta : delta.toString();
    pop.style.left = x - 12 + "px";
    pop.style.top = y - 40 + "px";
    document.body.appendChild(pop);
    requestAnimationFrame(() => pop.classList.add("hide"));
    setTimeout(() => pop.remove(), 750);
}

/* Wiring & start */
document.getElementById("end-turn").addEventListener("click", () => endTurn());
document.addEventListener("keydown", (e) => {
    if (e.key === "d") {
        drawCard(players[currentPlayer]);
        renderGame();
    }
});

buildDeck();
drawCard(players[0]);
drawCard(players[0]);
drawCard(players[1]);
drawCard(players[1]);
renderGame();
</script>

</body>
</html>
