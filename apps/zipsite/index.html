<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ZIPSite</title>
<script>
const OFFLINE_MODE = false; // Changes to use "/_/" directory instead of actual http
const SOFT_TABS    = true;  // Use spaces instead of actual tabs
const TAB_SIZE     = 2;     // Number of spaces to use for soft tabs
</script>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

:root {
  --ui-bg: #252526;
  --main-bg: #323232;
  --accent: #0e639c;
  --tab-bg: #2d2d2d;
  --border: #444;
  --accent: #317696;
  --text: #d4d4d4;
  --hover: #444444;
  --menubar-bg: #181818;

  --bg-darker: #181818;
  --bg-dark: #1f1f1f;
  --bg-editor: #121212;
  --bg-status: #181818;
  --bg-tabs: #181818;
  --border: #2b2b2b;
  --text-main: #cccccc;
  --text-muted: #8b8b8b;
  --accent: #0078d4;
  --tab-active-bg: #121212;
  --tab-inactive-bg: #181818;
  --item-hover: #2a2d2e;
  --selection: #37373d;
}

/* Scrollbars */
::-webkit-scrollbar {
  width: 10px;
  height: 10px;
}
::-webkit-scrollbar-track {
  background: var(--bg-dark);
}
::-webkit-scrollbar-thumb {
  background: #424242;
  border-radius: 5px;
  border: 2px solid var(--bg-dark);
}
::-webkit-scrollbar-thumb:hover {
  background: #4f4f4f;
}
::-webkit-scrollbar-corner {
  background: var(--bg-dark);
}


html, body {
  margin: 0; height: 100%;
  background: var(--main-bg);
  color: var(--text);
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Trebuchet MS", "Lucida Grande", sans-serif;
  font-size: 10px;
  overflow: hidden;
}

body {
  font-size: 12px;
}

body.preview-focus .preview-body {
  position: absolute;
}

body #toggle-condense {
  display: none;
}

body.preview-focus #toggle-condense {
  display: block;
}

body #SNSPreviewWindow{
  position: absolute;
  top: 50px;
  right: 35px;
  width: 600px;
  height: 525px;
  display: none;
  z-index: 15000;
  background: var(--bg-editor);
  border-radius: 8px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  overflow: hidden;
}

body.preview-sns #SNSPreviewWindow{
  display: block;
}

::selection {
  background: transparent;
}

textarea::selection {
  background: Highlight;
}

:focus:not(:focus-visible) {
  outline: none;
}

textarea:focus-visible {
  outline: auto;
}

select {
  border: 1px solid var(--border);
  background-color: var(--ui-bg);
  color: var(--text);
  border-radius: 4px;
  outline: 0;
}

option {
  padding: .25rem;
  background-color: var(--ui-bg);
  font-size: 1.2rem;
  color: var(--text);
}

option:hover {
  background-color: var(--hover);
}

select:focus option:checked {
  background: var(--accent) linear-gradient(0deg, var(--accent) 0%, var(--accent) 100%);
}

#app {
  height: 100vh;
  display: grid;
  grid-template-rows: auto /*41px*/ 1fr; /* Menu, Toolbar, Main content */
  overflow: hidden;
  position: relative;
}

/* Menus amd Toolbar */
/* ================================================== */

.mainmenu {
  width: 100vw;
  background-color: var(--menubar-bg);
  display: flex;
}

.mainmenu > * {
  background-color: transparent;
  display: flex;
}

nav .appicon {
  max-height: 32px;
  max-width: 32px;
}

nav .app-title
{
  font-weight: 700;
  font-size: 12px;
  color: lightgray;
}

nav, .toolbar {
  background-color: var(--menubar-bg);
  color: var(--text);
  font-size: 14px;
  align-items: center;
  display: flex;
  height: 41px;
  padding: 4px;
}

.mainmenu, .toolbar {
  border-bottom: 1px solid var(--border);
}

nav hr, .toolbar hr {
  max-height: 32px;
  min-width: 1px;
  border-color:var(--border);
  background-color: var(--border);
  align-self: stretch;
  border-style: none;
}

nav * {
  display: flex;
  flex: 0 0 auto;
  margin: 4px;
}

nav {
  flex-grow: 1;
}

menu {
  color-scheme: dark;
  user-select: none;
}

menu > ul {
  color: initial;
  position: relative;
  display: flex;
}

menu li {
  all: unset;
  border: 1px solid transparent;
  border-radius: 3px;
  box-sizing: border-box;
  display: block;
  justify-content: space-between;
  position: relative;
  white-space: nowrap;
}

menu hr, .context-menu hr {
  background-color: var(--border);
  border-bottom-color: var(--border);
  content: "";
  display: block;
  height: 1px;
  border: 0px;
  margin: 3px 12px;
  pointer-events: none;
}

menu ul {
  cursor: default;
  list-style: none;
  margin: 0;
  padding: 0;
}

menu > ul {
  background-color: var(--menubar-bg);
  display: flex;
}

menu > ul > li {
  padding: 2px 10px;
  position: relative;
  color: var(--text);
}

menu > ul > li:focus,
menu > ul > li:focus-within,
menu > ul > li:hover {
  background: var(--hover);
  color: var(--text);
  outline: none;
}

menu > ul > li:focus-within ~ li:focus,
menu > ul > li:focus-within ~ li:focus-within,
menu > ul > li:focus ~ li:focus,
menu > ul > li:focus ~ li:focus-within,
menu > ul > li:hover ~ li:focus,
menu > ul > li:hover ~ li:focus-within {
  background: transparent;
  color: inherit;
}

menu > ul > li:focus-within:has(~ li:hover),
menu > ul > li:focus:has(~ li:hover),
menu > ul > li:hover:has(~ li:hover) {
  background: transparent;
  color: inherit;
}

menu ul ul,
.menu ul {
  background: var(--menubar-bg);
  border: 1px solid rgba(0, 0, 0, 0.4);
  box-shadow: 4px 4px 3px -2px rgba(0, 0, 0, 0.5);
  color: var(--color);
  min-width: 150px;
  padding: 2px;
  position: relative;
}
menu li ul {
  display: none;
  left: 0;
  position: absolute;
  top: 100%;
  z-index: 99;
}

menu ul.can-hover  ul li:hover > ul,
.menu.can-hover ul li:hover > ul {
  display: block;
}

menu ul.can-hover li:hover ~ li:focus,
menu ul.can-hover li:hover ~ li:focus-within,
.menu.can-hover li:hover ~ li:focus,
.menu.can-hover li:hover ~ li:focus-within {
  background: transparent;
  color: inherit;
}

menu ul.can-hover li:hover ~ li:focus-within > ul,
menu ul.can-hover li:hover ~ li:focus > ul,
.menu.can-hover li:hover ~ li:focus-within > ul,
.menu.can-hover li:hover ~ li:focus > ul {
  display: none;
}

.menubar {
  padding: 0;
  z-index: 12000;
  position: relative;
  height: 100%;
}

.menubar > ul > li > ul{
    margin-top: 8px;
}

menu > ul > li:focus,
menu > ul > li:focus-within,
menu > ul > li:hover {
  color: var(--text);
  outline: none;
}

menu > ul > li:focus-within ~ li:focus,
menu > ul > li:focus-within ~ li:focus-within,
menu > ul > li:focus ~ li:focus,
menu > ul > li:focus ~ li:focus-within,
menu > ul > li:hover ~ li:focus,
menu > ul > li:hover ~ li:focus-within {
  background: transparent;
  color: inherit;
}

menu > ul > li:focus-within:has(~ li:hover),
menu > ul > li:focus:has(~ li:hover),
menu > ul > li:hover:has(~ li:hover) {
  background: transparent;
  color: inherit;
}

menu ul ul,
.menu ul {
  border: 1px solid rgba(0, 0, 0, 0.4);
  box-shadow: 4px 4px 3px -2px rgba(0, 0, 0, 0.5);
  min-width: 150px;
  padding: 2px;
  position: relative;
  background-color: var(--menubar-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--text);
  color-scheme: dark;
  user-select: none;
}

menu.menubar > ul > ul {
  min-width: 0;
}


menu li ul {
  display: none;
  left: 0;
  position: absolute;
  top: 100%;
  z-index: 99;
}

menu > ul > ul ul li > ul,
.menu > ul ul li > ul {
  left: 100%;
  top: -4px;
}

menu > ul ul > li > a,
menu > ul ul > li > button,
menu > ul ul > li > label,
menu > ul ul > li[aria-haspopup="true"],
.menu ul > li > a,
.menu ul > li > button,
.menu ul > li > label,
.menu ul > li[aria-haspopup="true"] {
  all: unset;
  border: 1px solid transparent;
  border-radius: 3px;
  box-sizing: border-box;
  display: flex;
  justify-content: space-between;
  padding: 4px 10px 4px 32px;
  position: relative;
  white-space: nowrap;
  width: 100%;
  font-size: 1.2rem;
}

menu > ul ul ul > li[aria-haspopup="true"] {
  padding: 0;
}

menu ul ul > li > a:focus,
menu ul ul > li > a:hover,
menu ul ul > li > button:focus,
menu ul ul > li > button:hover,
menu ul ul > li > label:focus,
menu ul ul > li > label:hover,
menu ul ul > li[aria-haspopup="true"]:focus,
menu ul ul > li[aria-haspopup="true"]:hover,
.menu ul > li > a:focus,
.menu ul > li > a:hover,
.menu ul > li > button:focus,
.menu ul > li > button:hover,
.menu ul > li > label:focus,
.menu ul > li > label:hover,
.menu ul > li[aria-haspopup="true"]:focus,
.menu ul > li[aria-haspopup="true"]:hover {
  background-color: var(--hover);
  color:var(--text);
}

menu >ul ul > li[aria-haspopup="true"]:after,
.menu ul > li[aria-haspopup="true"]:after {
  border: 4px solid transparent;
  border-left-color: currentcolor;
  content: "";
  color: var(--text);
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
}

menu ul li,
.menu li {
  position: relative;
  font-size: 1.2rem;
}

menu ul li > input[type],
.menu li > input[type] {
  position: absolute;
  z-index: 2;
  margin: 0.7rem 1.2rem;
  height: 1.2rem;
  width: 1.2rem;
}

menu ul li > svg,
.menu ul li > svg {
  position: absolute;
  z-index: 2;
  margin: 0.4rem 0.6rem;
  height: 1.8rem;
  width: 1.8rem;
  stroke: var(--text);
}

menu ul li > input[type] + label,
.menu li > input[type] + label {
  display: block;
  position: relative;
}

menu ul li > input[type] + label:before,
.menu li > input[type] + label:before {
  all: unset;
  border-radius: inherit;
  box-sizing: border-box;
  height: 22px;
  left: 0;
  position: absolute;
  top: 0;
  width: 22px;
}

menu ul li > input[type]:checked + label:before,
.menu li > input[type]:checked + label:before {
  content: "";
}

menu ul li > input[type][type="radio"]:checked + label:after,
.menu li > input[type][type="radio"]:checked + label:after {
  box-shadow: none;
  left: 8px;
  top: 50%;
  transform: translateY(-50%);
}

menu ul li > input[type][type="checkbox"]:checked + label:after,
.menu li > input[type][type="checkbox"]:checked + label:after {
  font-size: 10pt;
  left: 6px;
  top: 50%;
  transform: translateY(-52%);
}

menu ul li:focus-within > ul,
menu ul li:focus > ul,
.menu li:focus-within > ul,
.menu li:focus > ul {
  display: block;
}

menu ul li:focus-within:has(~ li:hover) > ul,
menu ul li:focus:has(~ li:hover) > ul,
.menu li:focus-within:has(~ li:hover) > ul,
.menu li:focus:has(~ li:hover) > ul {
  display: none;
}

menu ul li[aria-disabled],
.menu li[aria-disabled] {
  opacity: 0.5;
  pointer-events: none;
}

menu ul li.has-divider:after,
.menu li.has-divider:after {
  box-shadow: inset 0 1px rgba(0, 0, 0, 0.15), inset 0 -1px var(--text);
  content: "";
  display: block;
  height: 2px;
  margin: 3px 0 2px 30px;
  pointer-events: none;
}

menu ul li img,
.menu li img {
  left: 2px;
  pointer-events: none;
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  z-index: 1;
}

menu ul li span,
.menu li span {
  margin-left: 32px;
}

menu > ul ul.can-hover  ul li:hover > ul,
.menu.can-hover ul li:hover > ul {
  display: block;
}

menu > ul ul.can-hover li:hover ~ li:focus,
menu > ul.can-hover li:hover ~ li:focus-within,
.menu.can-hover li:hover ~ li:focus,
.menu.can-hover li:hover ~ li:focus-within {
  background: transparent;
  color: inherit;
}

menu ul > ul.can-hover li:hover ~ li:focus-within > ul,
menu ul > ul.can-hover li:hover ~ li:focus > ul,
.menu.can-hover li:hover ~ li:focus-within > ul,
.menu.can-hover li:hover ~ li:focus > ul {
  display: none;
}

.toolbar > ul {
  margin: 0;
  padding: 0 11px 0 12px;
  display: flex;
}

.toolbar > ul > li {
  display: inline-block;
}

.toolbar button {
  display: inline-block;
  position: relative;
  min-width: 28px;
  height: 28px;
  margin: 5px 2px;
  border: 0;
  padding: 2px;
  background-color: transparent;
  color: var(--text);
  border-radius: 4px;
}

.toolbar hr {
  margin: 4px;
}

.toolbar button:hover {
  background-color: var(--hover);
}

main { 
  position: relative;
  display: flex; 
  flex-direction: row;
  overflow: hidden; /* Prevents the whole app from scrolling */
  height: 100%; /* Fills the remaining grid row */
}

/* Status Bar */
.status-bar {
  height: 22px;
  background: var(--bg-status);
  border-top: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 12px;
  font-size: 12px;
  color: var(--text-muted);
  justify-content: space-between;
  flex-shrink: 0;
}

.status-left, .status-right {
  display: flex;
  gap: 16px;
  align-items: center;
}

.mobile-menu {
  display: none;
  padding: 0;
  width: 0;
  height: 32px;
}

@media screen and (max-width: 649px) {
  .appicon, .app-title, .app-title + hr { display: none; }
  .mobile-menu {
    display: block;
    padding: 0;
    width: 32px;
  }

  .mobile-menu + ul {
    display: none;
  }

  .menubar:hover > ul > ul {
    display: flex;
    flex-direction: column;
    position: absolute;
    top: 0;
    left: 32px;
    min-width: 0;
  }

  menu.menubar > ul > ul > li {
    padding: 2px 32px 2px 10px;
  }

  menu.menubar > ul > ul > li > ul {
    position: absolute;
    left: 100%;
    top: -0.4rem;
  }
}

@media screen and (min-width: 650px) {
  menu > ul > ul {
    border: 0;
    box-shadow: none;
  }

  menu.menubar > ul > ul > li {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 0 10px;
  }
  
  menu > ul > ul > li::after{
    display: none;
  }
}

/* Rest of CSS
   ================================================== */

.context-menu {
  display: none;
  position: fixed;
  z-index: 10000;
}

.context-menu ul {
  list-style: none;
  margin: 0;
  padding: 4px;
}

</style>

<style>
.tabs-nav {
  display: flex;
  border-bottom: 1px solid var(--border-color);
  /* background: #f9fafb; */
}

.tab-btn {
  flex: 1;
  padding: 15px;
  border: none;
  background: none;
  cursor: pointer;
  font-weight: 600;
  color: var(--text-secondary);
  font-size: 0.95rem;
  transition: all 0.2s;
  border-bottom: 2px solid transparent;
}
.tab-btn:hover { background: var(--item-hover); color: var(--text-main); }
.tab-btn.active {background: var(--tab-active-bg); color: #fff; border-bottom-color: var(--accemt); }

.tab-content { display: none; padding: 40px 20px; justify-content: center; background: var(--bg-editor)}
.tab-content.active { display: flex; }

/* Common Card Utilities */
.card-image {
  width: 100%;
  height: 0;
  padding-bottom: 52.25%; /* 1.91:1 Aspect Ratio */
  background-color: #e1e4e8;
  background-size: cover;
  background-position: center;
  position: relative;
  overflow: hidden;
}
.card-image.empty::after {
  content: 'Image Preview';
  position: absolute;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  color: #9ca3af;
  font-weight: 500;
}

/* Facebook Preview */
.fb-card {
  background: #fff;
  border: 1px solid #dadde1;
  max-width: 500px;
  width: 100%;
  overflow: hidden;
  font-family: Helvetica, Arial, sans-serif;
}
.fb-text {
  padding: 10px 12px;
  background-color: #f0f2f5;
  border-top: 1px solid #dadde1;
}
.fb-domain {
  font-size: 12px;
  color: #65676b;
  text-transform: uppercase;
  margin-bottom: 4px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.fb-title {
  font-size: 16px;
  font-weight: 700;
  color: #050505;
  margin-bottom: 4px;
  line-height: 1.2;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}
.fb-desc {
  font-size: 14px;
  color: #65676b;
  line-height: 1.3;
  display: -webkit-box;
  -webkit-line-clamp: 1;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

/* X (Twitter) Preview */
.tw-card {
  background: #fff;
  border: 1px solid #cfd9de;
  border-radius: 12px;
  width: 100%;
  max-width: 500px;
  overflow: hidden;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
}
.tw-text {
  padding: 12px;
  border-top: 1px solid #cfd9de;
}
.tw-domain {
  font-size: 15px;
  color: #536471;
  margin-bottom: 2px;
  display: flex;
  align-items: center;
}
.tw-title {
  font-size: 15px;
  font-weight: 700;
  color: #0f1419;
  margin-bottom: 2px;
  line-height: 1.3;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.tw-desc {
  font-size: 15px;
  color: #536471;
  line-height: 1.3;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

/* LinkedIn Preview */
.li-card {
  background: #fff;
  border: 1px solid #e0e0e0;
  box-shadow: 0 0 0 1px rgba(0,0,0,0.05),
              0 2px 4px rgba(0,0,0,0.05);
  border-radius: 8px;

  width: 100%;
  max-width: 500px;
  height: 98px;

  display: flex;
  align-items: center;
  overflow: hidden;

  font-family: system-ui, -apple-system, BlinkMacSystemFont;
}

.li-image {
  width: 108px;
  height: 72px;
  margin-left: 12px;
  flex-shrink: 0;
  background-color: #e1e4e8;
  background-size: cover;
  background-position: center;
  border-radius: 4px;
}

.li-text {
  padding: 12px 16px;
  overflow: hidden;
}

.li-title {
  font-size: 16px;
  font-weight: 600;
  color: #000000e6;
  line-height: 1.25;

  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.li-domain {
  font-size: 12px;
  color: #00000099;
}

/* Activity Bar */
.activity-bar {
  width: 48px;
  background: var(--bg-darker);
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  align-items: center;
  padding-top: 10px;
  flex-shrink: 0;
}

.activity-icon {
  width: 48px;
  height: 48px;
  padding: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--text-muted);
  cursor: pointer;
}

.activity-icon.active {
  color: #fff;
  border-left: 2px solid var(--accent);
}

.search-result-item { padding: 4px 0; cursor: pointer; font-size: 12px; color: var(--text-muted); display: flex; flex-direction: column; }
.search-result-file { font-weight: 600; color: var(--text-main); padding: 2px 4px; display: flex; align-items: center; gap: 6px; overflow: hidden; }
.search-result-file > span:first-child { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex: 1; min-width: 0; }
.search-result-file:hover { background: var(--item-hover); }
.search-result-match { padding-left: 20px; white-space: pre; overflow: hidden; text-overflow: ellipsis; font-family: monospace; }
.search-result-match:hover { background: var(--item-hover); color: var(--text-main); }
.search-badge { background: var(--accent); color: white; border-radius: 10px; padding: 0 6px; font-size: 10px; margin-left: auto; flex-shrink: 0; }

/* Sidebar / Explorer */
#sidebar {
  background: var(--bg-dark);
  display: flex;
  flex-direction: column;
  width: 260px;
  min-width: 120px;
  flex-shrink: 0;
  border-right: 1px solid var(--border);
}

.sidebar-header {
  height: 35px;
  padding: 0 12px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  font-size: 11px;
  font-weight: 700;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.sidebar-content {
  flex: 1;
  overflow-x: hidden;
  overflow-y: auto;
}

/* VS Code Tree Styling */
.folder-header, .file-item {
  display: flex;
  align-items: center;
  height: 22px;
  font-size: 13px;
  cursor: pointer;
  color: var(--text-main);
  user-select: none;
  white-space: nowrap;
  border: 1px solid transparent;
}

.folder-header:hover, .file-item:hover {
  background: var(--item-hover);
}

.folder-header.selected, .file-item.selected, .file-item.active {
  background: var(--selection) !important;
  color: #fff;
}

/* Native Resizers (Gutters) */
.resizer {
  width: 4px;
  cursor: col-resize;
  background: transparent;
  z-index: 100;
  margin: 0;
}

.resizer:hover, .resizer.dragging {
  background: var(--accent);
}

/* Editor Pane */
#editorPane {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: var(--bg-editor);
  min-width: 0;
  overflow: hidden;
}

.tabs-container {
  height: 35px;
  background: var(--bg-tabs);
  display: flex;
  overflow-x: auto;
  scrollbar-width: none;
}

.tab {
  display: flex;
  align-items: center;
  padding: 0 12px;
  height: 35px;
  background: var(--tab-inactive-bg);
  border-right: 1px solid #121212;
  font-size: 13px;
  color: var(--text-muted);
  cursor: pointer;
  min-width: 120px;
  max-width: 200px;
  position: relative;
  gap: 6px;
}

.tab.active {
  background: var(--tab-active-bg);
  color: #fff;
}

.tab.active::after {
  content: '';
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 1px;
  background: var(--accent);
}

.tab-name {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.tab-close {
  margin-left: auto;
  padding: 2px;
  border-radius: 4px;
  font-size: 14px;
  visibility: hidden;
  flex-shrink: 0;
}

.tab:hover .tab-close {
  visibility: visible;
}

.tab-close:hover {
  background: var(--item-hover);
}

.editor-content {
  flex: 1;
  position: relative;
}

#editor {
  position: absolute;
  top: 0; bottom: 0; left: 0; right: 0;
  min-width: 0;
  font-family: "Fira Code", Menlo, Monaco, "Courier New", monospace;
}

/* Preview Pane */
#previewPane {
  width: 45%;
  background: #fff;
  display: flex;
  flex-direction: column;
  min-width: 150px;
  flex-shrink: 0;
}

.preview-header {
  height: 35px;
  background: var(--bg-dark);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 12px;
  font-size: 11px;
  color: var(--text-muted);
  gap: 8px;
}

.preview-header-left {
  display: flex;
  align-items: center;
  gap: 8px;
  flex: 1 1 auto;
}

.url-container {
  display: flex;
  gap: 6px;
  align-items: center;
  background: var(--bg-darker);
  padding: 4px 6px;
  border-radius: 100rem;
  border: 1px solid var(--border);
  height: 26px;
  flex: 1 1 auto;
}

.url-input {
  background: var(--bg-darker);
  border: none;
  color: var(--text-main);
  font-size: 11px;
  height: 16px;
  padding: 0 6px 0 0;
  outline: none;
  flex: 1;
  min-width: 0;
  font-family: 'Inter', sans-serif;
}

.url-input::placeholder {
  color: var(--text-muted);
}

.url-input:focus {
  outline: none;
}

.focus-btn {
  background: var(--bg-status);
  color: var(--text-main);
  border: 1px solid var(--border);
  padding: 4px 8px;
  margin: 8px 4px;
  cursor: pointer;
  border-radius: 3px;
  font-size: 10px;
}

.focus-btn:hover {
  background: var(--item-hover);
}

.preview-body {
  position: relative;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 12000;
  flex: 1;
  background: #fff;
  overflow: hidden;
}

.preview-body iframe {
  width: 100%;
  height: 100%;
  border: none;
  display: block;
}

.preview-body svg {
  max-width: 100%;
  max-height: 100%;
}

/* Upload Section */
.upload-section {
  padding: 24px 16px;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.upload-area {
  border: 2px dashed var(--border);
  border-radius: 6px;
  padding: 32px 16px;
  text-align: center;
  /* background: var(--bg-secondary); */
  cursor: pointer;
  transition: all 0.3s ease;
}

.upload-area:hover {
  border-color: var(--accent);
  background: var(--item-hover);
}

.upload-area.dragover {
  border-color: var(--success-green);
  background: rgba(137, 209, 133, 0.1);
}

.upload-icon {
  font-size: 40px;
  margin-bottom: 12px;
  opacity: 0.6;
}

.upload-area h3 {
  font-size: 13px;
  font-weight: 500;
  margin-bottom: 6px;
  color: var(--text-primary);
}

.upload-area p {
  font-size: 11px;
  color: var(--text-secondary);
}

.file-input {
  display: none;
}

.hidden { display: none; }
/* Additional styles for folder tree */
.tree-folder {
  margin: 0;
  padding: 0;
}

.folder-header {
  display: flex;
  align-items: center;
  padding: 0 8px;
  height: 22px;
  font-size: 13px;
  cursor: pointer;
  color: var(--text-main);
  user-select: none;
}

.folder-header:hover {
  background: var(--item-hover);
}

.folder-header.selected {
  background: var(--selection);
}

.folder-arrow {
  font-size: 10px;
  width: 16px;
  text-align: center;
  flex-shrink: 0;
  transition: transform 0.1s;
  color: var(--text-muted);
}

.folder-arrow.expanded {
  transform: rotate(90deg);
}

.folder-icon, .folder-arrow, .file-icon {
  font-size: 14px;
  flex-shrink: 0;
  margin: 0 6px;
  width: 1.5rem;
  text-align: center;
}

.folder-name, .file-name {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.folder-children {
  display: none;
  padding-left: 0;
  margin: 0;
  list-style: none;
}

.folder-children.expanded {
  display: block;
}

.sidebar-actions {
  display: flex;
  gap: 4px;
}

.sidebar-action-btn {
  width: 22px;
  height: 22px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: transparent;
  border: none;
  color: var(--text-muted);
  cursor: pointer;
  border-radius: 3px;
  transition: all 0.15s;
}

.sidebar-action-btn:hover {
  background: var(--item-hover);
  color: var(--text-main);
}

.sidebar-action-btn svg {
  width: 16px;
  height: 16px;
}

.tab-icon {
  font-size: 14px;
  flex-shrink: 0;
}

.tab-name {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.tab-dirty-indicator {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--text-main);
  display: none;
  flex-shrink: 0;
}

.tab.dirty .tab-dirty-indicator {
  display: block;
}

.tab.dirty .tab-close {
  display: none;
}

.tab.dirty:hover .tab-close {
  display: block;
}

.tab.dirty:hover .tab-dirty-indicator {
  display: none;
}

.editor-panel {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.preview-panel {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: var(--bg-dark);
}

.preview-empty {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: var(--text-muted);
  font-size: 13px;
  background: #1e1e1e;
}

.explorer-menu {
  position: fixed;
  background: #252526;
  border: 1px solid var(--border);
  border-radius: 4px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.5);
  z-index: 10000;
  min-width: 180px;
  padding: 4px 0;
  font-size: 13px;
}

.explorer-menu-item {
  padding: 6px 12px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 8px;
  color: var(--text-main);
  transition: background 0.15s;
}

.explorer-menu-item:hover {
  background: var(--accent);
}

.explorer-menu-separator {
  height: 1px;
  background: var(--border);
  margin: 4px 0;
}

.explorer-menu-item.danger:hover {
  background: #f48771;
}

.notification {
  position: fixed;
  bottom: 40px;
  right: 20px;
  padding: 12px 20px;
  background: #252526;
  border: 1px solid var(--border);
  border-radius: 6px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.5);
  font-size: 13px;
  z-index: 100000000;
  animation: slideInBottom 0.3s ease;
  display: flex;
  align-items: center;
  gap: 10px;
}

.notification.success {
  border-left: 3px solid #89d185;
}

.notification.error {
  border-left: 3px solid #f48771;
}

@keyframes slideInBottom {
  from {
    transform: translateY(100px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

.new-item-input {
  padding: 0 8px;
  height: 22px;
  font-size: 13px;
  background: #252526;
  border: 1px solid var(--accent);
  outline: none;
  color: var(--text-main);
  font-family: 'Inter', sans-serif;
  width: 100%;
}

.icon-btn {
  padding: 4px 8px;
  background: transparent;
  color: var(--text-muted);
  border: none;
  border-radius: 3px;
  cursor: pointer;
  transition: all 0.15s;
  font-size: 14px;
}

.icon-btn:hover {
  background: var(--item-hover);
  color: var(--text-main);
}
</style>

<style>
/* DevTools */
.devtools-pane {
  background: #242424;
  border-top: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  height: 33%;
  min-height: 0;
  z-index: 11558;
}

.devtools-resizer {
  height: 4px;
  cursor: row-resize;
  background: var(--bg-dark);
  border-top: 1px solid var(--border);
  flex-shrink: 0;
  z-index: 11559;
}

.devtools-resizer:hover {
  background: var(--accent);
}

.devtools-header {
  display: flex;
  background: #333333;
  border-bottom: 1px solid var(--border);
  height: 28px;
  align-items: center;
  flex-shrink: 0;
}

.devtools-tab {
  padding: 0 10px;
  height: 100%;
  display: flex;
  align-items: center;
  font-size: 12px;
  color: #aaaaaa;
  cursor: pointer;
  border-bottom: 2px solid transparent;
}

.devtools-tab:hover {
  color: #ffffff;
}

.devtools-tab.active {
  color: #ffffff;
  border-bottom: 2px solid #8ab4f8;
}

.devtools-actions {
  margin-left: auto;
  padding-right: 8px;
}

.devtools-content {
  flex: 1;
  overflow: auto;
  font-family: 'Consolas', 'Menlo', monospace;
  font-size: 13px;
  background: #242424;
  color: #e8eaed;
  position: relative;
  user-select: text;
}

.devtools-tab-content {
  display: none;
  height: 100%;
}

.devtools-tab-content.active {
  display: block;
}

#devtoolsElements.active {
  display: flex;
  flex-direction: row;
}

.console-msg {
  padding: 4px 0;
  border-bottom: 1px solid #3c4043;
  display: flex;
  gap: 8px;
  white-space: pre-wrap;
  word-break: break-all;
  font-family: 'Consolas', monospace;
}

.console-msg.error {
  color: #ff8080;
  background: rgba(255, 0, 0, 0.1);
  border-left: 2px solid #ff8080;
  padding-left: 4px;
}

.console-msg.warn {
  color: #fddd5c;
  background: rgba(255, 255, 0, 0.1);
  border-left: 2px solid #fddd5c;
  padding-left: 4px;
}

.console-msg.info { color: #e8eaed; }
.console-msg.log { color: #e8eaed; }

.devtools-input-container {
  display: flex;
  align-items: center;
  padding: 4px 8px;
  border-top: 1px solid #3c4043;
  background: #242424;
  flex-shrink: 0;
}

.devtools-input {
  background: transparent;
  border: none;
  color: #e8eaed;
  flex: 1;
  font-family: monospace;
  font-size: 11px;
  outline: none;
  margin-left: 4px;
}

/* Elements Tree */
.dom-node { font-family: Consolas, monospace; white-space: nowrap; min-width: 100%; width: fit-content; }
.dom-tag { color: #569cd6; }
.dom-attr-name { color: #9cdcfe; }
.dom-attr-val { color: #ce9178; }
.dom-text { color: #d4d4d4; white-space: pre; display: inline-block; min-width: 100%; }
.dom-comment { color: #6a9955; }
.dom-line { cursor: default; display: flex; align-items: center; min-height: 16px; height: 16px; }
.dom-line:hover { background-color: #2a2d2e; }
.dom-node.dom-text:hover { background-color: #2a2d2e; }
.dom-line.selected, .dom-node.dom-text.selected { background-color: #264f78 !important; }
.icon-btn.active { color: #8ab4f8; background: rgba(138, 180, 248, 0.1); }

.dom-arrow {
  display: inline-block;
  width: 12px;
  height: 12px;
  margin-right: 4px;
  flex-shrink: 0;
  cursor: pointer;
  color: #858585;
  font-size: 9px;
  line-height: 12px;
  text-align: center;
  transform: rotate(-90deg);
  transition: transform 0.1s;
}
.dom-arrow.expanded { transform: rotate(0deg); }
.dom-spacer { width: 16px; flex-shrink: 0; }
.dom-children { padding-left: 12px; display: none; }
.dom-children.expanded { display: block; }

.devtools-tree-view {
  flex: 2;
  overflow: auto;
  padding: 4px;
}
.devtools-style-view {
  flex: 1;
  overflow: auto;
  padding: 4px;
  background: #242424;
}
.style-section { margin-bottom: 8px; border-bottom: 1px solid #3c4043; padding-bottom: 8px; }
.style-selector { color: #d7ba7d; }
.style-property { color: #9cdcfe; }
.style-value { color: #e8eaed; }
.style-property.overwritten, .style-value.overwritten {
  text-decoration: line-through;
  color: #808080;
}

.style-rules-pane {
  flex: 1;
  overflow: auto;
  padding: 4px;
}
.computed-pane {
  flex: 0 0 50%;
  overflow: hidden auto;
  padding: 4px;
  background: #242424;
}
.style-panes-resizer {
  width: 4px;
  cursor: col-resize;
  background: var(--bg-dark);
  border-left: 1px solid var(--border);
  border-right: 1px solid var(--border);
  flex-shrink: 0;
}
.style-panes-resizer:hover {
  background: var(--accent);
}

/* Box Model */
.box-model-container { padding: 16px 0; display: flex; justify-content: center; font-size: 10px; font-family: sans-serif; }
.box-layer-solid { border: 1px solid black; padding: 2px; text-align: center; position: relative; display: inline-block; }
.box-layer-dashed { border: 1px dashed black; padding: 2px; text-align: center; position: relative; display: inline-block; }
.box-margin { background-color: #b08354; color: black; margin: 4px; }
.box-border { background-color: #e4c482; color: black; margin: 4px; }
.box-padding { background-color: #b8c480; color: black; margin: 4px; }
.box-content { background-color: #88b2bd; color: black; min-width: 100px; padding: 8px 4px; }
.box-label { position: absolute; top: 2px; left: 3px; font-size: 10px; opacity: 0.7; pointer-events: none; }
.box-top, .box-bottom { display: block; padding: 2px 0; }
.box-middle { display: flex; align-items: center; justify-content: center; }
.box-left, .box-right { display: inline-block; padding: 0 4px; }

/* Computed List */
.computed-property { padding: 2px 4px; border-bottom: 1px solid #3c4043; font-family: Consolas, monospace; font-size: 11px; }
.computed-name { color: #9cdcfe; flex: 1; }
.computed-value { color: #e8eaed; }

.devtools-h-resizer {
  width: 4px;
  cursor: col-resize;
  background: var(--bg-dark);
  border-left: 1px solid var(--border);
  border-right: 1px solid var(--border);
  flex-shrink: 0;
}
.devtools-h-resizer:hover {
  background: var(--accent);
}

/* Network Tab */
.network-table { width: 100%; border-collapse: collapse; font-family: Consolas, monospace; font-size: 11px; table-layout: fixed; }
.network-table th { text-align: left; padding: 4px 8px; border-bottom: 1px solid #3c4043; background: #333; color: #ccc; font-weight: normal; position: sticky; top: 0; z-index: 1; }
.network-table td { padding: 2px 8px; border-bottom: 1px solid #2a2a2a; color: #ccc; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.network-table tr:hover { background: #2a2d2e; }
.network-status-200 { color: #89d185; }
.network-status-404, .network-status-500 { color: #f48771; }
.network-table tr.network-error td { color: #f48771; }
.network-col-name { width: 35%; }
.network-col-status { width: 10%; }
.network-col-type { width: 15%; }
.network-col-size { width: 15%; }
.network-col-time { width: 25%; }

.network-toolbar { display: flex; padding: 4px; background: #333; border-bottom: 1px solid #3c4043; gap: 4px; flex-shrink: 0; }
.network-filter { background: transparent; border: none; color: #aaa; cursor: pointer; padding: 2px 6px; border-radius: 3px; font-size: 11px; }
.network-filter:hover { background: #444; color: #eee; }
.network-filter.active { background: #444; color: #fff; font-weight: bold; }
#devtoolsNetwork.active { display: flex; flex-direction: column; }
</style>

<style>
/* =====================================
  VS Code Dark Modern theme for Ace
  ===================================== */

.ace-tm { background-color: #1f1f1f; color: #d4d4d4; }
.ace-tm .ace_gutter { background: #1f1f1f; color: #858585; }
.ace-tm .ace_gutter-active-line { background-color: #2a2d2e; }
.ace-tm .ace_cursor { color: #aeafad; }
.ace-tm .ace_print-margin { width: 1px; background: #2a2a2a; }
.ace-tm .ace_fold { background-color: #c586c0; }
.ace-tm .ace_invisible { color: #404040; }

/* ===============================
   Selection & active line
   =============================== */

.ace-tm .ace_marker-layer .ace_selection { background: #264f78; }
.ace-tm.ace_multiselect .ace_selection.ace_start { box-shadow: 0 0 3px 0px #1f1f1f; }
.ace-tm .ace_marker-layer .ace_active-line { background: #2a2d2e; }
.ace-tm .ace_marker-layer .ace_bracket { border: 1px solid #515a6b; }
.ace-tm .ace_marker-layer .ace_selected-word { background: #37373d; border: 1px solid #515a6b; }
.ace-tm .ace_marker-layer .ace_step { background: #2d2d30; }
.ace-tm .ace_marker-layer .ace_stack { background: #2d2d30; }

/* ===============================
   Syntax colors (Dark Modern)
   =============================== */

.ace-tm .ace_keyword, .ace-tm .ace_storage { color: #569cd6; }
.ace-tm .ace_keyword.ace_operator { color: #d4d4d4; }
.ace-tm .ace_string { color: #ce9178; }
.ace-tm .ace_string.ace_regex { color: #d16969; }
.ace-tm .ace_constant.ace_numeric { color: #b5cea8; }
.ace-tm .ace_constant { color: #4fc1ff; }
.ace-tm .ace_constant.ace_buildin { color: #4fc1ff; }
.ace-tm .ace_constant.ace_language { color: #4fc1ff; }
.ace-tm .ace_constant.ace_library { color: #4ec9b0; }
.ace-tm .ace_variable { color: #9cdcfe; }
.ace-tm .ace_entity.ace_name.ace_function, .ace-tm .ace_support.ace_function { color: #dcdcaa; }
.ace-tm .ace_support.ace_type, .ace-tm .ace_support.ace_class { color: #4ec9b0; }
.ace-tm .ace_comment { color: #6a9955; }
.ace-tm .ace_comment.ace_doc { color: #6a9955; }
.ace-tm .ace_comment.ace_doc.ace_tag { color: #608b4e; }
.ace-tm .ace_meta.ace_tag { color: #569cd6; }
.ace-tm .ace_xml-pe { color: #808080; }
.ace-tm .ace_heading { color: #569cd6; }
.ace-tm .ace_list { color: #c586c0; }
.ace-tm .ace_invalid { background-color: #f44747; color: #ffffff; }

/* ===============================
   Indent guides (VS Code style)
   =============================== */

.ace-tm .ace_indent-guide {
  background: linear-gradient(
    to bottom,
    rgba(255,255,255,0.15) 50%,
    rgba(255,255,255,0) 50%
  ) right repeat-y;
  background-size: 1px 4px;
}

.ace-tm .ace_indent-guide-active {
  background: linear-gradient(
    to bottom,
    rgba(255,255,255,0.35) 50%,
    rgba(255,255,255,0) 50%
  ) right repeat-y;
  background-size: 1px 4px;
}

/* ===============================
   ACE Editor Autocomplete
   =============================== */
.ace_editor.ace_autocomplete {
  background: #252526;
  color: #cccccc;
  border: 1px solid #454545;
  box-shadow: 0 4px 10px rgba(0,0,0,0.45);
  width: 300px;
  line-height: 1.4;
  position: fixed;
  z-index: 200000;
  font-family: Consolas, "Courier New", monospace;
}

.ace_autocomplete .ace_line { display: flex; align-items: center; padding: 2px 6px; }
.ace_editor.ace_autocomplete .ace_line-hover { background: #2a2d2e; }
.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line { background: #094771; z-index: 1; }
.ace_editor.ace_autocomplete .ace_completion-highlight { color: #4fc1ff; font-weight: normal; }
.ace_autocomplete .ace_ { flex: 0 1 auto; overflow: hidden; text-overflow: ellipsis; }
.ace_autocomplete .ace_completion-spacer { flex: 1; }
.ace_completion-meta { margin-left: 0.75em; color: #8c8c8c; opacity: 1; }
.ace_completion-message { margin-left: 0.75em; color: #c586c0; }
.ace_autocomplete.ace_loading::after { background: #0e639c; content: ""; position: absolute; top: 0; left: 0; height: 2px; width: 30%; animation: ace_progress 1.5s infinite linear; }
@keyframes ace_progress { 0%   { transform: translateX(-100%); } 100% { transform: translateX(350%); }}
@media (prefers-reduced-motion) { .ace_autocomplete.ace_loading::after { animation: none; transform: translateX(0); }}

/* ===============================
   ACE Editor Search Box
   =============================== */
.ace_search { background-color: #1f1f1f; color: #cccccc; }
.ace_search_form.ace_nomatch { outline: 1px solid #f14c4c; }
.ace_search_field { background-color: #2a2a2a; color: #d4d4d4; border: 1px solid #3c3c3c; }
.ace_search_field:focus { border-color: #0078d4; }
.ace_searchbtn { background-color: #2a2a2a; color: #cccccc; border: 1px solid #3c3c3c; border-left: 1px solid #3c3c3c; }
.ace_searchbtn:last-child { border-right: 1px solid #3c3c3c; }
.ace_searchbtn:hover { background-color: #373737; }
.ace_searchbtn:active { background-color: #094771; }
.ace_searchbtn.prev:after, .ace_searchbtn.next:after { border: 0; transform: none; }
.ace_searchbtn.prev:after { content: "-"; }
.ace_searchbtn.next:after { content: "+"; }
.ace_searchbtn_close { color: #cccccc; }
.ace_searchbtn_close:hover { background-color: #333333; color: #ffffff; }
.ace_button { background-color: #2a2a2a; border: 1px solid #3c3c3c; color: #cccccc; }
.ace_button:hover { background-color: #373737; }
.ace_button:active { background-color: #094771; }
.ace_button.checked { border-color: #0078d4; background-color: #094771; color: #ffffff; }
.ace_search_counter { color: #9cdcfe; }
</style>
</head>
<body>

<div id="app">
  <div class="mainmenu">
    <nav>
      <svg version="1.1" class="appicon" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="20px" height="20px" fill="#4298b8" viewBox="796 796 200 200" enable-background="new 796 796 200 200" xml:space="preserve"><g><g><path d="M976.83,857.4l-56.943-56.941c-2.873-2.875-6.694-4.458-10.76-4.458H825.93c-8.393,0-15.218,6.828-15.218,15.222v169.56 c0,8.393,6.825,15.219,15.218,15.219H966.07c8.39,0,15.218-6.826,15.218-15.219V868.162 C981.288,864.099,979.706,860.275,976.83,857.4z M969.676,980.781c0,1.989-1.616,3.609-3.605,3.609h-140.14 c-1.988,0-3.604-1.62-3.604-3.609V811.22c0-1.988,1.616-3.605,3.604-3.605h79.41c2.174,0,3.936,1.762,3.936,3.936v42.937 c0,7.25,5.877,13.126,13.123,13.126h43.343c1.044,0,2.045,0.415,2.783,1.153c0.738,0.738,1.153,1.739,1.153,2.783L969.676,980.781 z"/></g><g><path d="M909.442,946.483l-10.948-41.951c-2.142-8.205-9.554-13.931-18.034-13.931h-4.952h-4.952 c-8.48,0-15.893,5.726-18.034,13.931l-10.947,41.951c-1.458,5.586-0.244,11.532,3.284,16.101c3.53,4.568,8.977,7.244,14.75,7.244 h15.899h15.9c5.772,0,11.219-2.676,14.749-7.244C909.686,958.016,910.899,952.069,909.442,946.483z M887.747,958.91H863.27 c-5.004,0-9.062-4.057-9.062-9.062s4.058-9.062,9.062-9.062h24.478c5.005,0,9.062,4.057,9.062,9.062 S892.752,958.91,887.747,958.91z"/></g><g><path d="M888.548,884.37h-26.08c-3.296,0-5.967-2.671-5.967-5.967s2.671-5.967,5.967-5.967h26.08c3.296,0,5.968,2.671,5.968,5.967 S891.844,884.37,888.548,884.37z"/></g><g><path d="M888.548,864.501h-26.08c-3.296,0-5.967-2.671-5.967-5.967c0-3.295,2.671-5.967,5.967-5.967h26.08 c3.296,0,5.968,2.671,5.968,5.967C894.516,861.83,891.844,864.501,888.548,864.501z"/></g><g><path d="M888.548,844.632h-26.08c-3.296,0-5.967-2.671-5.967-5.967s2.671-5.967,5.967-5.967h26.08 c3.296,0,5.968,2.671,5.968,5.967S891.844,844.632,888.548,844.632z"/></g><g><path d="M888.548,825.226h-26.08c-3.296,0-5.967-2.671-5.967-5.967c0-3.295,2.671-5.967,5.967-5.967h26.08 c3.296,0,5.968,2.671,5.968,5.967C894.516,822.555,891.844,825.226,888.548,825.226z"/></g></g></svg>
      <div class="app-title">ZIPSite</div>
      <hr>
      <menu class="menubar">
        <ul>
          <li class="mobile-menu">
            <svg fill="currentColor" viewBox="0 0 18 18" aria-hidden="true" aria-label="" focusable="false"><rect fill-rule="evenodd" x="2" y="8" width="14" height="2" rx="0.5"></rect><rect fill-rule="evenodd" x="2" y="3" width="14" height="2" rx="0.5"></rect><rect fill-rule="evenodd" x="2" y="13" width="14" height="2" rx="0.5"></rect></svg><a></a>
          </li>
          <ul class="can-hover">
            <li tabindex="0" aria-haspopup="true">File
              <ul>
                <li><a onclick="OpenFile()">Open ZIP File</a></li>
                <hr>
                <li><a onclick="SaveStoredFile()">Save Stored ZIP File</a></li>
                <li><a onclick="SaveCompressedFile()">Save Compressed ZIP file</a></li>
                <hr>
                <li><a onclick="NewZIPSite()">Create New Blank ZIPSite</a></li>
                <li><a onclick="NewPHPZIPSite()">Create New PHP ZIPSite</a></li>
              </ul>
            </li>
          </ul>
        </ul>
      </menu>
    </nav>

    <div>
      <button class="focus-btn" id="toggle-snspreview">SNS Preview</button>
      <button class="focus-btn" id="toggle-focus">‚õ∂ Expand</button>
    </div>

    <div id="SNSPreviewWindow">
      <div class="tabs-nav">
        <button class="tab-btn active" data-tab="fb">Facebook</button>
        <button class="tab-btn" data-tab="tw">ùïè (Twitter)</button>
        <button class="tab-btn" data-tab="li">LinkedIn</button>
      </div>

        <div class="tab-content active" id="tab-fb">
          <div class="fb-card">
            <div class="card-image empty" id="fb-img"></div>
            <div class="fb-text">
              <div class="fb-domain" id="fb-domain">EXAMPLE.COM</div>
              <div class="fb-title" id="fb-title">How to Create Amazing Web Pages</div>
              <div class="fb-desc" id="fb-desc">Learn the secrets of modern web design and how to implement social share previews effectively.</div>
            </div>
          </div>
        </div>

        <div class="tab-content" id="tab-tw">
          <div class="tw-card">
            <div class="card-image empty" id="tw-img"></div>
            <div class="tw-text">
              <div class="tw-domain" id="tw-domain">example.com</div>
              <div class="tw-title" id="tw-title">How to Create Amazing Web Pages</div>
              <div class="tw-desc" id="tw-desc">Learn the secrets of modern web design and how to implement social share previews effectively.</div>
            </div>
          </div>
        </div>

        <div class="tab-content" id="tab-li">
        <div class="li-card">
          <div id="li-img" class="li-image empty"></div>
          <div class="li-text">
            <div id="li-title" class="li-title"></div>
            <div id="li-domain" class="li-domain"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <main>
    <div class="activity-bar">
      <div class="activity-icon active" title="Explorer" onclick="virtualEditor.switchSidebarView('explorer')" id="act-explorer">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"/>
        </svg>
      </div>
      <div class="activity-icon" title="Search" onclick="virtualEditor.switchSidebarView('search')" id="act-search">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="11" cy="11" r="8"></circle>
          <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
        </svg>
      </div>
    </div>

    <div class="sidebar" id="sidebar">
     <div id="explorerView" style="display: flex; flex-direction: column; height: 100%;">
      <div class="sidebar-header">
        <span>EXPLORER</span>
        <div class="sidebar-actions" id="sidebarActions" style="display: none;">
          <button class="sidebar-action-btn" onclick="virtualEditor.saveZip('STORE')" title="Save ZIP (Ctrl+S)">
            <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
              <path d="M12 14H4a1 1 0 01-1-1V3a1 1 0 011-1h6l3 3v8a1 1 0 01-1 1z"/>
              <path d="M10 2v4h3"/>
              <path d="M5 9h6"/>
            </svg>
          </button>
          <button class="sidebar-action-btn" onclick="virtualEditor.createNewFile()" title="New File">
            <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
              <path d="M9 2H4a1 1 0 00-1 1v10a1 1 0 001 1h8a1 1 0 001-1V6l-4-4z"/>
              <path d="M9 2v4h4"/>
            </svg>
          </button>
          <button class="sidebar-action-btn" onclick="virtualEditor.createNewFolder()" title="New Folder">
            <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
              <path d="M2 4v8a1 1 0 001 1h10a1 1 0 001-1V6a1 1 0 00-1-1H7L6 3H3a1 1 0 00-1 1z"/>
            </svg>
          </button>
        </div>
      </div>
      <div class="sidebar-content">
        <div class="upload-section" id="uploadSection">
          <div class="upload-area" id="uploadArea">
            <div class="upload-icon">
              <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="100px" height="100px" fill="#ccc" viewBox="796 796 200 200" enable-background="new 796 796 200 200" xml:space="preserve"><g><g><path d="M976.83,857.4l-56.943-56.941c-2.873-2.875-6.694-4.458-10.76-4.458H825.93c-8.393,0-15.218,6.828-15.218,15.222v169.56 c0,8.393,6.825,15.219,15.218,15.219H966.07c8.39,0,15.218-6.826,15.218-15.219V868.162 C981.288,864.099,979.706,860.275,976.83,857.4z M969.676,980.781c0,1.989-1.616,3.609-3.605,3.609h-140.14 c-1.988,0-3.604-1.62-3.604-3.609V811.22c0-1.988,1.616-3.605,3.604-3.605h79.41c2.174,0,3.936,1.762,3.936,3.936v42.937 c0,7.25,5.877,13.126,13.123,13.126h43.343c1.044,0,2.045,0.415,2.783,1.153c0.738,0.738,1.153,1.739,1.153,2.783L969.676,980.781 z"/></g><g><path d="M909.442,946.483l-10.948-41.951c-2.142-8.205-9.554-13.931-18.034-13.931h-4.952h-4.952 c-8.48,0-15.893,5.726-18.034,13.931l-10.947,41.951c-1.458,5.586-0.244,11.532,3.284,16.101c3.53,4.568,8.977,7.244,14.75,7.244 h15.899h15.9c5.772,0,11.219-2.676,14.749-7.244C909.686,958.016,910.899,952.069,909.442,946.483z M887.747,958.91H863.27 c-5.004,0-9.062-4.057-9.062-9.062s4.058-9.062,9.062-9.062h24.478c5.005,0,9.062,4.057,9.062,9.062 S892.752,958.91,887.747,958.91z"/></g><g><path d="M888.548,884.37h-26.08c-3.296,0-5.967-2.671-5.967-5.967s2.671-5.967,5.967-5.967h26.08c3.296,0,5.968,2.671,5.968,5.967 S891.844,884.37,888.548,884.37z"/></g><g><path d="M888.548,864.501h-26.08c-3.296,0-5.967-2.671-5.967-5.967c0-3.295,2.671-5.967,5.967-5.967h26.08 c3.296,0,5.968,2.671,5.968,5.967C894.516,861.83,891.844,864.501,888.548,864.501z"/></g><g><path d="M888.548,844.632h-26.08c-3.296,0-5.967-2.671-5.967-5.967s2.671-5.967,5.967-5.967h26.08 c3.296,0,5.968,2.671,5.968,5.967S891.844,844.632,888.548,844.632z"/></g><g><path d="M888.548,825.226h-26.08c-3.296,0-5.967-2.671-5.967-5.967c0-3.295,2.671-5.967,5.967-5.967h26.08 c3.296,0,5.968,2.671,5.968,5.967C894.516,822.555,891.844,825.226,888.548,825.226z"/></g></g></svg>
            </div>
            <h3>Open ZIP Archive</h3>
            <p>Drop ZIP file or click to browse</p>
            <input type="file" class="file-input" id="fileInput" accept=".zip">
          </div>
        </div>
        <ul class="file-tree" id="fileTree"></ul>
      </div>
     </div>
     <div id="searchView" style="display: none; flex-direction: column; height: 100%;">
        <div class="sidebar-header">
          <span>SEARCH</span>
        </div>
        <div class="sidebar-content" style="padding: 10px;">
           <input type="text" id="searchInput" class="new-item-input" placeholder="Search" style="width: 100%; margin-bottom: 10px;">
           <div id="searchResults"></div>
        </div>
     </div>
    </div>

    <div class="resizer" id="resizer1"></div>

    <div id="editorPane">
      <div class="tabs-container" id="tabsContainer"></div>
      <div class="editor-content" id="editorContent">
        <div class="empty-state" style="display: flex; flex-direction: column; align-content: center; justify-content: center; width: 100%; height: 100%;">
          <div style="font-size: 48px; opacity: 0.3; display: flex; justify-content: center;">üìÑ</div>
          <div style="font-size: 14px; font-weight: 500; display: flex; justify-content: center;">No file open</div>
        </div>
      </div>
    </div>

    <div class="resizer" id="resizer2"></div>

    <div id="previewPane">
      <div class="preview-header">
        <div class="preview-header-left">
          <span>PREVIEW</span>
          <div class="url-container">
            <button id="homeButton" style="background-color: transparent; border: 0; cursor: pointer; margin-left: 4px;">
              <svg width="16" height="16" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                <polyline fill="none" stroke="#aaaaaa" stroke-width="2" stroke-miterlimit="10" points="3,17 16,4 29,17 "/>
                <polyline fill="none" stroke="#aaaaaa" stroke-width="2" stroke-miterlimit="10" points="6,14 6,27 13,27 13,17 19,17 19,27 26,27 26,14 "/>
              </svg>
            </button>
            <span style="width: 65%; display: flex; flex-wrap: nowrap; flex-direction: row; align-items: center;">
              <span style="height: 16px;">www.site.com</span>
              <input type="text" class="url-input" id="virtualUrl" placeholder="/" value="">
            </span>
            <input type="text" class="url-input" style="width: 35%; display: flex; flex-wrap: nowrap; flex-direction: row;" id="virtualQuery" placeholder="Query String" value="">
          </div>
        </div>
        <button class="icon-btn" onclick="virtualEditor.refreshPreview()" title="Refresh Preview">üîÑ</button>
      </div>
      <div style="flex: 1; display: flex; flex-direction: column; overflow: hidden; background: var(--bg-dark);">
        <div class="preview-body" id="previewBody" style="flex: 1; min-height: 0;">
          <div class="preview-empty">No HTML file active</div>
        </div>
        <div class="devtools-resizer" id="devtoolsResizer"></div>
        <div class="devtools-pane" id="devtoolsPane">
          <div class="devtools-header">
            <button class="icon-btn" id="inspectorBtn" onclick="virtualEditor.toggleInspector()" title="Select an element in the page to inspect it" style="margin: 0 4px;">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14">
                <path d="M3 3h12v12H3z"/>
                <path d="M14 14l7 7m-4-7l-7-4"/>
              </svg>
            </button>
            <div class="devtools-tab active" data-tab="elements" onclick="virtualEditor.switchDevToolsTab('elements')">Elements</div>
            <div class="devtools-tab" data-tab="network" onclick="virtualEditor.switchDevToolsTab('network')">Network</div>
            <div class="devtools-tab" data-tab="console" onclick="virtualEditor.switchDevToolsTab('console')">Console</div>
            <div class="devtools-actions">
              <button class="icon-btn" onclick="virtualEditor.clearConsole()" title="Clear Console">üö´</button>
            </div>
          </div>
          <div class="devtools-content">
            <div id="devtoolsElements" class="devtools-tab-content active"></div>
            <div id="devtoolsNetwork" class="devtools-tab-content">
              <div class="network-toolbar">
                <button class="network-filter active" onclick="virtualEditor.filterNetwork('all')">All</button>
                <button class="network-filter" onclick="virtualEditor.filterNetwork('fetch')">Fetch/XHR</button>
                <button class="network-filter" onclick="virtualEditor.filterNetwork('document')">Doc</button>
                <button class="network-filter" onclick="virtualEditor.filterNetwork('stylesheet')">CSS</button>
                <button class="network-filter" onclick="virtualEditor.filterNetwork('script')">JS</button>
                <button class="network-filter" onclick="virtualEditor.filterNetwork('font')">Font</button>
                <button class="network-filter" onclick="virtualEditor.filterNetwork('image')">Img</button>
              </div>
              <div style="flex: 1; overflow: auto;">
                <table class="network-table">
                  <thead>
                    <tr>
                      <th class="network-col-name">Name</th>
                      <th class="network-col-status">Status</th>
                      <th class="network-col-type">Type</th>
                      <th class="network-col-size">Size</th>
                      <th class="network-col-time">Time</th>
                    </tr>
                  </thead>
                  <tbody id="networkTableBody"></tbody>
                </table>
              </div>
            </div>
            <div id="devtoolsConsole" class="devtools-tab-content"></div>
          </div>
          <div class="devtools-input-container" id="devtoolsInputContainer" style="display: none;">
            <span style="color: #3574f0;">&gt;</span>
            <input type="text" class="devtools-input" id="devtoolsInput" placeholder="Run JavaScript...">
          </div>
        </div>
      </div>
    </div>
  </main>

  <div class="status-bar">
    <div class="status-left">
      <div id="fileCount">No files loaded</div>
    </div>
    <div class="status-right">
      <span id="cursorPosition">Ln 1, Col 1</span>
      <span id="encoding">UTF-8</span>
      <span id="fileType">Plain Text</span>
    </div>
  </div>
</div>

<!-- scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.2/ace.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.2/ext-language_tools.js"></script>

<script>
</script>

<script>
class PHPTranspiler {
  constructor(files, currentPath) {
    this.files = files;
    this.currentPath = currentPath;
    this.includedFiles = new Set();
  }

  transpile(phpCode, filePath, requestedUri, queryString) {
    
    // Collect variables from ALL files to ensure scope availability for includes
    this.declaredVars = this.collectAllVariables(filePath, phpCode);
    const transpiledCode = this.transpileCode(phpCode);
    
    // Create a closure that has access to the files Map
    const filesMap = this.files;
    const currentFilePath = filePath;
    const currentDir = filePath.substring(0, filePath.lastIndexOf('/'));
    const escapeForJs = (str) => String(str).replace(/\\/g, '\\\\').replace(/'/g, "\\'");
    const actualRequestUri = escapeForJs(requestedUri || filePath);
    const actualQueryString = escapeForJs(queryString || '');
    
    // Build __transpileInner function separately to avoid template literal escaping issues
    const transpileInnerSource = this.buildTranspileInnerFunction();
    
    // Set up the execution context
    let jsCode = `(function() {
  let __output = '';
  let __currentFile = '${filePath}';
  let __cwd = '${currentDir}';
  let __includedFiles = new Set();

  // Access to files via closure
  const __getFile = (path) => {
    // Try exact match
    let fileData = __filesMap.get(path);
    // Try stripping leading slash (absolute -> relative)
    if (!fileData && path.startsWith('/')) {
      fileData = __filesMap.get(path.substring(1));
    }
    // Try adding leading slash (relative -> absolute)
    if (!fileData && !path.startsWith('/')) {
      fileData = __filesMap.get('/' + path);
    }
    if (!fileData) return null;
    const decoder = new TextDecoder();
    return decoder.decode(fileData);
  };

  // PHP superglobals
  let _SERVER = {
  'REQUEST_URI': '${actualRequestUri}',
  'SCRIPT_NAME': '${filePath}',
  'PHP_SELF': '${filePath}',
  'QUERY_STRING': '${actualQueryString}',
  'REQUEST_METHOD': 'GET',
  'HTTP_HOST': 'localhost',
  'DOCUMENT_ROOT': '/'
  };
  let _GET = {};
  if ('${actualQueryString}') {
    const params = new URLSearchParams('${actualQueryString}');
    for (const [key, value] of params) {
      _GET[key] = value;
    }
  }
  let _POST = {};
  let _REQUEST = {};

  // PHP constants (use var so eval can access them)
  var ENT_QUOTES = 3;
  var ENT_COMPAT = 2;
  var PATHINFO_FILENAME = 8;
  var ENT_NOQUOTES = 0;
  var PHP_URL_PATH = 1;

  // PHP functions

  class DateTime {
    constructor(time, timezone) {
      this.date = new Date();
      if (time && time !== 'now') {
         if (String(time).startsWith('@')) {
             this.date = new Date(parseInt(time.substring(1)) * 1000);
         } else {
             const parsed = Date.parse(time);
             if (!isNaN(parsed)) this.date = new Date(parsed);
         }
      }
    }
    format(format) { return date(format, this.date.getTime() / 1000); }
    getTimestamp() { return Math.floor(this.date.getTime() / 1000); }
    setTimezone(timezone) { return this; }
  }

  function __include_file(filepath, isRequire, once) {
    let resolvedPath = __resolveIncludePath(filepath, __currentFile);

    if (once && __includedFiles.has(resolvedPath)) {
      return true;
    }

    let content = __getFile(resolvedPath);
    
    // Fallback: If relative path failed, try resolving from initial directory (simulating CWD)
    if (!content && (filepath.startsWith('./') || filepath.startsWith('../'))) {
        const cwdResolvedPath = __resolveIncludePath(filepath, __cwd + '/.');
        if (__getFile(cwdResolvedPath)) {
            resolvedPath = cwdResolvedPath;
            if (once && __includedFiles.has(resolvedPath)) {
                return true;
            }
            content = __getFile(resolvedPath);
        }
    }

    if (!content) {
      console.error('[PHP] File not found:', resolvedPath);
      if (isRequire) {
        throw new Error('Required file not found: ' + resolvedPath);
      }
      return false;
    }

    __includedFiles.add(resolvedPath);

    const prevFile = __currentFile;
    __currentFile = resolvedPath;

    try {
      const transpiled = __transpileInner(content);
      
      // Save ALL transpiled includes for debugging
      if (!window.allTranspiledIncludes) window.allTranspiledIncludes = [];
      window.allTranspiledIncludes.push({path: resolvedPath, code: transpiled});
      window.lastTranspiledInner = transpiled;
      
      eval(transpiled);
    } catch (error) {
      console.error('Include error:', error);
      if (isRequire) throw error;
    }

    __currentFile = prevFile;
    return true;
  }

  function __resolveIncludePath(path, currentFile) {
    // Handle absolute paths (from root)
    if (path.startsWith('/')) {
       const parts = path.split('/').filter(p => p && p !== '.');
       const resolved = [];
       for (const part of parts) {
           if (part === '..') resolved.pop();
           else resolved.push(part);
       }
       return resolved.join('/');
    }

    if (path.startsWith('./') || path.startsWith('../')) {
      const currentDir = currentFile.substring(0, currentFile.lastIndexOf('/'));
      const parts = currentDir.split('/').filter(p => p);
      const pathParts = path.split('/');
      
      for (const part of pathParts) {
        if (part === '..') parts.pop();
        else if (part !== '.') parts.push(part);
      }
    
      return parts.join('/');
    }

    // Handle paths that might contain .. but don't start with ./ or ../ (e.g. from __DIR__)
    const parts = path.split('/').filter(p => p && p !== '.');
    const resolved = [];
    for (const part of parts) {
        if (part === '..') resolved.pop();
        else resolved.push(part);
    }
    return resolved.join('/');
  }

  function array_filter(array, callback) {
    const arr = Array.isArray(array) ? array : Object.values(array);
    return arr.filter(callback || (x => x));
  }

  function array_flip(arr) {
    const result = {};
    if (Array.isArray(arr)) {
      arr.forEach((val, idx) => result[val] = idx);
    } else {
      for (const key in arr) {
        result[arr[key]] = key;
      }
    }
    return result;
  }

  function array_intersect_key(arr1, arr2) {
    const result = {};
    const keys2 = Object.keys(arr2);
    for (const key in arr1) {
      if (keys2.includes(key)) {
        result[key] = arr1[key];
      }
    }
    return result;
  }

  function array_merge(...arrays) {
    return Object.assign({}, ...arrays);
  }

  function array_search(needle, haystack, strict = false) {
    return haystack.indexOf(needle);
  }

  function array_shift(array) {
    return array.shift();
  }

  function array_values(array) {
    return Array.isArray(array) ? array : Object.values(array);
  }

  function basename(path, suffix) {
    let b = String(path);
    if (b.length > 1 && b.endsWith('/')) b = b.slice(0, -1);
    b = b.split('/').pop();
    if (suffix && b.endsWith(suffix)) {
      b = b.substring(0, b.length - suffix.length);
    }
    return b;
  }

  function count(arr) {
    if (Array.isArray(arr)) return arr.length;
    if (typeof arr === 'object' && arr !== null) return Object.keys(arr).length;
    return 0;
  }

  function date(format, timestamp) {
    const d = timestamp ? new Date(timestamp * 1000) : new Date();
    return d.toISOString().split('T')[0];
  }

  function dirname(path, levels) {
    if (levels === undefined) levels = 1;
    let dir = String(path);
    if (dir.length > 1 && dir.endsWith('/')) dir = dir.slice(0, -1);
    
    for (let i = 0; i < levels; i++) {
        const lastSlash = dir.lastIndexOf('/');
        if (lastSlash === -1) return '.';
        if (lastSlash === 0) return '/';
        dir = dir.substring(0, lastSlash);
    }
    return dir;
  }

  function echo(...args) {
    __output += args.map(a => String(a)).join('');
  }

  function empty(v) {
    return !v || v === '' || v === '0' || v === 0 || (Array.isArray(v) && v.length === 0);
  }

  function end(array) {
    return array[array.length - 1];
  }

  function explode(delimiter, string, limit) {
    const parts = String(string).split(delimiter);
    return limit ? parts.slice(0, limit) : parts;
  }

  function file_get_contents(filename) {
    let resolvedPath = __resolveIncludePath(filename, __currentFile);
    let content = __getFile(resolvedPath);
    
    if (content === null && (filename.startsWith('./') || filename.startsWith('../'))) {
        const cwdResolvedPath = __resolveIncludePath(filename, __cwd + '/.');
        if (__getFile(cwdResolvedPath)) {
            content = __getFile(cwdResolvedPath);
        }
    }
    
    return content === null ? false : content;
  }

  function header(header, replace = true, httpResponseCode) {
    // console.log('PHP header():', header);
  }

  function http_response_code(code) {
    return code || 200;
  }

  function htmlspecialchars(string, flags, encoding) {
    const map = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#039;'
    };
    return String(string).replace(/[&<>"']/g, m => map[m]);
  }

  function implode(glue, pieces) {
    if (!Array.isArray(pieces)) {
      pieces = Object.values(pieces);
    }
    return pieces.join(glue);
  }

  function in_array(needle, haystack, strict = false) {
    return haystack.includes(needle);
  }

  function include(filepath) {
    return __include_file(filepath, false, false);
  }

  function include_once(filepath) {
    return __include_file(filepath, false, true);
  }

  function is_array(variable) {
    return Array.isArray(variable) || (typeof variable === 'object' && variable !== null);
  }

  function isset(...vars) {
    return vars.every(v => v !== undefined && v !== null);
  }

  function json_decode(json, assoc = false) {
    try {
      if (json === null || json === '') return null;
      return JSON.parse(json);
    } catch (e) {
      return null;
    }
  }

  function json_encode(value, options = 0) {
    try {
      return JSON.stringify(value);
    } catch (e) {
      return false;
    }
  }

  function ltrim(str, characters) {
    if (!characters) return String(str).trimStart();
    const chars = String(characters).replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');
    return String(str).replace(new RegExp('^[' + chars + ']+'), '');
  }

  function parse_url(url, component) {
    try {
      const fullUrl = url.startsWith('http') ? url : 'http://localhost' + url;
      const parsed = new URL(fullUrl);
      if (component === 1) return parsed.pathname;
      return parsed.pathname;
    } catch {
      return false;
    }
  }

  function pathinfo(path, options = null) {
    const parts = path.split('/');
    const filename = parts.pop();
    const dirname = parts.join('/') || '.';

    const PATHINFO_DIRNAME = 1;
    const PATHINFO_BASENAME = 2;
    const PATHINFO_EXTENSION = 4;
    const PATHINFO_FILENAME = 8;
    const dot = filename.lastIndexOf('.');
    const extension = dot > -1 ? filename.substring(dot + 1) : '';

    return { dirname, basename: filename, extension, filename };
  }

  function phpversion() {
    return '8.2.11-transpiled';
  }

  function preg_match(pattern, subject, matches) {
    const p = String(pattern);
    const match = p.match(/^~(.+)~([igm]*)$/) || p.match(/^\\/(.+)\\/([igm]*)$/);
    if (!match) return 0;
    try {
      const regex = new RegExp(match[1], (match[2] || '').replace('g', ''));
      const result = String(subject).match(regex);
      if (result) {
        if (matches && typeof matches === 'object') {
          if (Array.isArray(matches)) matches.length = 0;
          for (let i = 0; i < result.length; i++) matches[i] = result[i];
        }
        return 1;
      }
      return 0;
    } catch (e) { return false; }
  }

  function preg_match_all(pattern, subject, matches) {
    const p = String(pattern);
    const match = p.match(/^~(.+)~([igm]*)$/) || p.match(/^\\/(.+)\\/([igm]*)$/);
    if (!match) return 0;
    try {
      const flags = (match[2] || '').replace('g', '') + 'g';
      const regex = new RegExp(match[1], flags);
      const results = [...String(subject).matchAll(regex)];
      if (results.length > 0) {
        if (matches && typeof matches === 'object') {
          if (Array.isArray(matches)) matches.length = 0;
          // Default is PREG_PATTERN_ORDER
          if (results[0]) {
            const numGroups = results[0].length;
            for (let g = 0; g < numGroups; g++) matches[g] = [];
            
            for (const res of results) {
              for (let g = 0; g < res.length; g++) {
                matches[g].push(res[g]);
              }
            }
          }
        }
        return results.length;
      }
      return 0;
    } catch (e) { return false; }
  }

  function preg_replace(pattern, replacement, subject) {
    const match = String(pattern).match(/^~(.+)~([igm]*)$/);
    if (!match) return subject;
    const regex = new RegExp(match[1], match[2] || 'g');
    return String(subject).replace(regex, replacement);
  }

  function print_r(value, returnValue = false) {
    const output = JSON.stringify(value, null, 2);
    if (returnValue) return output;
    __output += output;
  }

  function require(filepath) {
    return __include_file(filepath, true, false);
  }

  function require_once(filepath) {
    return __include_file(filepath, true, true);
  }

  function rtrim(str, characters) {
    if (!characters) return String(str).trimEnd();
    const chars = String(characters).replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');
    return String(str).replace(new RegExp('[' + chars + ']+$'), '');
  }

  function strtotime(text, now) {
    if (!text) return false;
    if (text === 'now') return now || Math.floor(Date.now() / 1000);
    
    const d = new Date(text);
    if (!isNaN(d.getTime())) {
      return Math.floor(d.getTime() / 1000);
    }
    return false;
  }

  function strtok(str, token) {
    if (token === undefined) {
      token = str;
    } else {
      __strtok_str = String(str);
      __strtok_idx = 0;
    }

    if (!__strtok_str) return false;

    while (__strtok_idx < __strtok_str.length && token.indexOf(__strtok_str[__strtok_idx]) !== -1) {
      __strtok_idx++;
    }

    if (__strtok_idx >= __strtok_str.length) return false;

    const start = __strtok_idx;
    while (__strtok_idx < __strtok_str.length && token.indexOf(__strtok_str[__strtok_idx]) === -1) {
      __strtok_idx++;
    }

    return __strtok_str.substring(start, __strtok_idx);
  }

  function str_replace(search, replace, subject) {
    if (Array.isArray(search)) {
      let result = subject;
      for (let i = 0; i < search.length; i++) {
        result = result.replaceAll(search[i], replace[i] || '');
      }
      return result;
    }
    return String(subject).replaceAll(String(search), String(replace));
  }

  function strlen(str) {
    return String(str).length;
  }

  function strpos(haystack, needle, offset = 0) {
    const pos = String(haystack).indexOf(String(needle), offset);
    return pos === -1 ? false : pos;
  }

  function substr(str, start, length) {
    return String(str).substr(start, length);
  }

  function time() {
    return Math.floor(Date.now() / 1000);
  }

  function trim(str, characters) {
    if (!characters) return String(str).trim();
    const chars = String(characters).replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');
    return String(str).replace(new RegExp('^[' + chars + ']+|[' + chars + ']+$', 'g'), '');
  }

  function var_dump(...values) {
    values.forEach(val => {
      __output += typeof val + '(' + JSON.stringify(val) + ')\\n';
    });
  }

  ${transpileInnerSource}

  // Execute the main PHP code
  try {
    // Dynamic variable declarations
    ${this.declaredVars}
    ${transpiledCode}
  } catch (error) {
    __output += '<pre>PHP Error: ' + error.message + '</pre>';
    console.error('PHP execution error:', error);
  }

  return __output;
})();
`;
        
    // Return a function that will be called with the files map
    return `(function(__filesMap) {
      return ${jsCode}
    })`;
  }

  buildTranspileInnerFunction() {
    // Build this as a plain string to avoid template literal escaping issues
    return `function __transpileInner(phpCode) {
    // Handle mixed HTML/PHP content properly
    let code = phpCode;
    
    // First, handle <?= shorthand
    code = code.replace(/<\\?=/g, '<?php echo ');
    
    // Split by PHP tags and process each section
    let result = '';
    let inPhp = false;
    let parts = code.split(/(<\\?php|\\?>)/g);
    
    for (let i = 0; i < parts.length; i++) {
      let part = parts[i];
      
      if (part === '<?php') {
        inPhp = true;
      } else if (part === '?>') {
        inPhp = false;
      } else if (part) {
        if (inPhp) {
          // PHP code - keep as is
          result += part;
        } else {
          // HTML content - convert to output statement
          if (part.trim()) {
            // Escape quotes and newlines for the string literal
            let escaped = part
              .replace(/\\\\/g, '\\\\\\\\\\\\\\\\')
              .replace(/'/g, "\\\\'")
              .replace(/\\r/g, '')
              .replace(/\\n/g, '\\\\n');
            result += '__output += \\'' + escaped + '\\';';
          }
        }
      }
    }
    
    code = result;
    
    // Now continue with the rest of the transpilation
    // Convert list() to destructuring assignment
    code = code.replace(/\\blist\\s*\\(([^)]+)\\)/g, '[$1]');

    code = code.replace(/\\/\\*[\\s\\S]*?\\*\\//g, '');
    // Remove // comments but not // in URLs - match // after whitespace/semicolon or at line start
    code = code.replace(/(^|[\\s;])\\/\\/[^\\r\\n]*/gm, '$1');
    code = code.replace(/\\$_(\\w+)\\[['\"](\\w+)['\"]\\]\\s*\\?\\?\\s*([^;]+)/g, 
      '(_$1[\"$2\"] !== undefined && _$1[\"$2\"] !== null ? _$1[\"$2\"] : $3)');
    code = code.replace(/\\$(\\w+)\\s*\\?\\?\\s*([^;]+)/g, 
      '($1 !== undefined && $1 !== null ? $1 : $2)');
    code = code.replace(/\\$_SERVER\\[['\"](\\w+)['\"]\\]/g, '_SERVER[\"$1\"]');
    code = code.replace(/\\$_GET\\[['\"](\\w+)['\"]\\]/g, '_GET[\"$1\"]');
    code = code.replace(/\\$_POST\\[['\"](\\w+)['\"]\\]/g, '_POST[\"$1\"]');
    
    // Handle Heredoc/Nowdoc
    code = code.replace(/<<<(['"]?)([a-zA-Z_]\\w*)\\1\\s*\\r?\\n([\\s\\S]*?)\\r?\\n\\2/g, (match, quote, id, content) => {
      let safeContent = content.replace(/\`/g, '\\\\\`');
      if (quote === "'") {
        safeContent = safeContent.replace(/\\$\\{/g, '\\\\\${');
      } else {
        safeContent = safeContent.replace(/\\{\\$([^}]+)\\}/g, (m, inner) => {
             return '\\\${' + inner.replace(/\\$([a-zA-Z_]\\w*)/g, '\$1') + '}';
        });
        safeContent = safeContent.replace(/\\$([a-zA-Z_]\\w*)/g, '\\\${$1}');
      }
      return '\`' + safeContent + '\`';
    });

    // String interpolation DISABLED - causes syntax errors with backticks
    // PHP templates with interpolation like "text $var" won't work, but
    // concatenation like "text " . $var works fine
    code = code.replace(/\\$(?=[a-zA-Z_]\\w*)/g, '');
    code = code.replace(/\\becho\\s+((?:[^;"'\\\`]|"[^"\\\\]*(?:\\\\.[^"\\\\]*)*"|'[^'\\\\]*(?:\\\\.[^'\\\\]*)*'|\\\`[^\\\`\\\\\\\\]*(?:\\\\\\\\.[^\\\`\\\\\\\\]*)*\\\`)+);/g, '__output += String($1);');
    code = code.replace(/\\s\\.\\s/g, ' + ');
    code = code.replace(/(\\w+)\\s*\\.=/g, '$1 +=');
    
    // Convert foreach loops BEFORE converting => to :
    code = code.replace(/\\bforeach\\s*\\(\\s*(\\w+)\\s+as\\s+(\\w+)\\s*\\)/g,
      'for (let $2 of (Array.isArray($1) ? $1 : Object.values($1)))');
    code = code.replace(/\\bforeach\\s*\\(\\s*(\\w+)\\s+as\\s+(\\w+)\\s*=>\\s*(\\w+)\\s*\\)/g,
      'for (let [$2, $3] of Object.entries($1))');
    
    // Convert array() calls - must skip is_array, array_merge, etc
    var arrayPositions = [];
    var searchPos = 0;
    while (true) {
      var pos = code.indexOf('array(', searchPos);
      if (pos === -1) break;
      
      // Check if preceded by word character (part of function name like is_array)
      if (pos > 0) {
        var prevChar = code.charAt(pos - 1);
        if (new RegExp('[a-zA-Z0-9_]').test(prevChar)) {
          // Skip this - it's part of a function name
          searchPos = pos + 1;
          continue;
        }
      }
      
      arrayPositions.push(pos);
      searchPos = pos + 1;
    }
    
    // Process in reverse order to maintain indices
    for (var idx = arrayPositions.length - 1; idx >= 0; idx--) {
      var startPos = arrayPositions[idx];
      var openParenPos = startPos + 5; // 'array'.length
      
      // Find matching closing paren
      var depth = 1;
      var closeParenPos = openParenPos + 1;
      while (depth > 0 && closeParenPos < code.length) {
        if (code.charAt(closeParenPos) === '(') depth++;
        else if (code.charAt(closeParenPos) === ')') depth--;
        if (depth > 0) closeParenPos++;
      }
      
      // Extract content
      var content = code.substring(openParenPos + 1, closeParenPos);
      if (content.indexOf('=>') !== -1) {
        var newContent = content.replace(/(\\w+|"[^"]+"|'[^']+')\\s*=>\\s*/g, '$1: ');
        code = code.substring(0, startPos) + '{' + newContent + '}' + code.substring(closeParenPos + 1);
      } else {
        code = code.substring(0, startPos) + '[' + content + ']' + code.substring(closeParenPos + 1);
      }
    }

    // Convert [...] to {...} if they contain =>
    var bracketPositions = [];
    for (var i = 0; i < code.length; i++) {
      if (code.charAt(i) === '[') bracketPositions.push(i);
    }
    for (var i = bracketPositions.length - 1; i >= 0; i--) {
      var startPos = bracketPositions[i];
      var depth = 1;
      var closePos = startPos + 1;
      while (depth > 0 && closePos < code.length) {
        if (code.charAt(closePos) === '[') depth++;
        else if (code.charAt(closePos) === ']') depth--;
        if (depth > 0) closePos++;
      }
      if (closePos < code.length) {
        var content = code.substring(startPos + 1, closePos);
        if (content.indexOf('=>') !== -1) {
           var newContent = content.replace(/(\\w+|"[^"]+"|'[^']+')\\s*=>\\s*/g, '$1: ');
           code = code.substring(0, startPos) + '{' + newContent + '}' + code.substring(closePos + 1);
        }
      }
    }
    
    // NOTE: We do NOT add variable declarations here like the main transpiler does
    // because in PHP, include() shares the same variable scope as the including file.
    // Variables are already declared in the main file using var.
    
    // Remove any existing 'let' keywords
    code = code.replace(/^(\\s*)let\\s+(\\w+)\\s*=/gm, '$1$2 =');
    
    return code;
  }`;
  }

  collectAllVariables(currentFilePath, currentContent) {
    const varNames = new Set();
    const superGlobals = ['_GET', '_POST', '_SERVER', '_REQUEST', '_COOKIE', '_SESSION', '_FILES', '_ENV', 'this'];

    const scan = (code) => {
      const matches = code.match(/\$([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)/g);
      if (matches) {
        matches.forEach(v => {
          const name = v.substring(1);
          if (!superGlobals.includes(name)) {
            varNames.add(name);
          }
        });
      }
    };

    // Scan current content
    scan(currentContent);

    // Scan all files
    if (this.files) {
      for (const [path, content] of this.files.entries()) {
        if (path === currentFilePath) continue;
        if (path.endsWith('.php') || path.endsWith('.html') || path.endsWith('.inc')) {
          const text = new TextDecoder().decode(content);
          scan(text);
        }
      }
    }
    
    if (varNames.size > 0) {
      return 'var ' + Array.from(varNames).join(', ') + ';';
    }
    return '';
  }

  transpileCode(phpCode) {
    // First, handle mixed HTML/PHP content properly
    let code = phpCode;
    
    // Handle <?= shorthand
    code = code.replace(/<\?=/g, '<?php echo ');
    
    // Split by PHP tags and process each section
    let result = '';
    let inPhp = false;
    let parts = code.split(/(<\?php|\?>)/g);
    
    for (let i = 0; i < parts.length; i++) {
      let part = parts[i];
      
      if (part === '<?php') {
        inPhp = true;
      } else if (part === '?>') {
        inPhp = false;
      } else if (part) {
        if (inPhp) {
          // PHP code - keep as is
          result += part;
        } else {
          // HTML content - convert to output statement
          if (part.trim()) {
            // Check if this part contains <script> tags
            const hasScript = /<script[^>]*>[\s\S]*?<\/script>/i.test(part);
            
            if (hasScript) {
              // For content with script tags, use template literals to preserve JavaScript
              // Replace backticks with escaped backticks
              let escaped = part
                .replace(/\\/g, '\\\\')
                .replace(/`/g, '\\`')
                .replace(/\${/g, '\\${')
                .replace(/\r/g, '');
              result += '__output += `' + escaped + '`;';
            } else {
              // Regular HTML content - use single quotes
              let escaped = part
                .replace(/\\/g, '\\\\')
                .replace(/'/g, "\\'")
                .replace(/\r/g, '')
                .replace(/\n/g, '\\n');
              result += '__output += \'' + escaped + '\';';
            }
          }
        }
      }
    }
    
    code = result;
    
    // NOW continue with the rest of the transpilation
    
    // Convert list() to destructuring assignment
    code = code.replace(/\blist\s*\(([^)]+)\)/g, '[$1]');

    // Remove comments
    code = code.replace(/\/\*[\s\S]*?\*\//g, '');
    // Remove // comments but not // in URLs - match // after whitespace/semicolon or at line start
    code = code.replace(/(^|[\s;])\/\/[^\r\n]*/gm, '$1');
    
    // Handle null coalescing operator ?? FIRST (before removing $)
    code = code.replace(/\$_(\w+)\[['"](\w+)['"]\]\s*\?\?\s*([^;]+)/g, 
      '(_$1["$2"] !== undefined && _$1["$2"] !== null ? _$1["$2"] : $3)');
    code = code.replace(/\$(\w+)\s*\?\?\s*([^;]+)/g, 
      '($1 !== undefined && $1 !== null ? $1 : $2)');
    
    // Convert $_SERVER, $_GET, $_POST references (before removing $)
    code = code.replace(/\$_SERVER\[['"](\w+)['"]\]/g, '_SERVER["$1"]');
    code = code.replace(/\$_GET\[['"](\w+)['"]\]/g, '_GET["$1"]');
    code = code.replace(/\$_POST\[['"](\w+)['"]\]/g, '_POST["$1"]');
    
    // Convert string interpolation (before removing $)
    code = code.replace(/"([^"\\]*(?:\\.[^"\\]*)*)"/g, (match, content) => {
      // Check if this string contains PHP variable interpolation
      if (/\$|{\$/.test(content)) {
        // This string has interpolation - convert it to template literal
        let jsContent = content.replace(/`/g, '\\`');
        jsContent = jsContent.replace(/\{\$([^}]+)\}/g, (m, inner) => {
             return '${' + inner.replace(/\$([a-zA-Z_]\w*)/g, '$1') + '}';
        });
        jsContent = jsContent.replace(/\$([a-zA-Z_]\w*)/g, '${$1}');
        return '`' + jsContent + '`';
      }
      // Regular string with no interpolation - keep as is
      return match;
    });
    
    code = code.replace(/fn\s*\(([^)]+)\)\s*=>/g, '($1) =>');
  
    // Handle Heredoc/Nowdoc
    code = code.replace(/<<<(['"]?)([a-zA-Z_]\w*)\1\s*\r?\n([\s\S]*?)\r?\n\2/g, (match, quote, id, content) => {
      let safeContent = content.replace(/`/g, '\\`');
      if (quote === "'") {
        safeContent = safeContent.replace(/\$\{/g, '\\${');
      } else {
        safeContent = safeContent.replace(/\{\$([^}]+)\}/g, (m, inner) => {
             return '${' + inner.replace(/\$([a-zA-Z_]\w*)/g, '$1') + '}';
        });
        safeContent = safeContent.replace(/\$([a-zA-Z_]\w*)/g, '${$1}');
      }
      return '`' + safeContent + '`';
    });

    // Convert remaining $variables to variables
    code = code.replace(/\$(?=[a-zA-Z_]\w*)/g, '');
    
    // Convert echo statements to __output +=
    code = code.replace(/\becho\s+((?:[^;"'`]|"[^"\\]*(?:\\.[^"\\]*)*"|'[^'\\]*(?:\\.[^'\\]*)*'|`[^`\\]*(?:\\.[^`\\]*)*`)+);/g, (match, args) => {
      if (args.trim().startsWith('`')) {
        return `__output += ${args};`;
      }
      return `__output += String(${args});`;
    });
    
    // Convert string concatenation . to +
    // Simple approach: replace " . " with " + "
    // This works because PHP string concatenation always has spaces around the dot
    code = code.replace(/\s\.\s/g, ' + ');
    
    // Convert .= to +=
    code = code.replace(/(\w+)\s*\.=/g, '$1 +=');
    
    // Now convert array() calls
    // Strategy: Find array(...) and check if content has : (was =>)
    // If yes, convert to {...}, if no, convert to [...]
    let arrayPositions = [];
    let regex = /(?<![_])array\s*\(/g;
    let match;
    while ((match = regex.exec(code)) !== null) {
      arrayPositions.push({index: match.index, hasColon: false});
    }
    
    // Convert in reverse order to maintain indices
    for (let i = arrayPositions.length - 1; i >= 0; i--) {
      let startPos = arrayPositions[i].index;
      let openParenPos = code.indexOf('(', startPos);
      
      // Find matching closing paren
      let depth = 1;
      let closeParenPos = openParenPos + 1;
      while (depth > 0 && closeParenPos < code.length) {
        if (code[closeParenPos] === '(') depth++;
        else if (code[closeParenPos] === ')') depth--;
        if (depth > 0) closeParenPos++;
      }
      
      // Check if content has : (meaning it was an associative array with =>)
      let content = code.substring(openParenPos + 1, closeParenPos);
      if (content.includes('=>')) {
        let newContent = content.replace(/(\w+|"[^"]+"|'[^']+')\s*=>\s*/g, '$1: ');
        code = code.substring(0, startPos) + '{' + newContent + '}' + code.substring(closeParenPos + 1);
      } else {
        code = code.substring(0, startPos) + '[' + content + ']' + code.substring(closeParenPos + 1);
      }
    }
    
    // Convert PHP_URL_PATH constant
    code = code.replace(/PHP_URL_PATH/g, '1');
    
    // Handle is_file
    code = code.replace(/is_file\s*\(\s*([^)]+)\s*\)/g, 
      '(__getFile($1) !== null)');
    
    // Handle http_response_code
    code = code.replace(/http_response_code\s*\([^)]*\)/g, 
      '/* http_response_code() */');
    
    // Handle exit/die
    code = code.replace(/\b(exit|die)\s*\([^)]*\)\s*;/g, 'return __output;');
    code = code.replace(/\b(exit|die)\s*;/g, 'return __output;');
    
    // Replace __DIR__
    const currentDir = this.currentPath.substring(0, this.currentPath.lastIndexOf('/'));
    const dirValue = currentDir || '/'; // Use '/' if empty (root directory)
    code = code.replace(/__DIR__/g, `'${dirValue}'`);
    
    // Clean up unnecessary empty string concatenations
    // Remove patterns like '' + "..." or '' + `...` or '' . anything
    code = code.replace(/['"]{2}\s*\+\s*/g, '');
    
    // Merge concatenated strings to avoid syntax errors
    // This must happen AFTER __DIR__ replacement and string interpolation
    // Pass 1: 'string' + `template` becomes `stringtemplate`
    code = code.replace(/'([^']*)'\s*\+\s*`/g, '`$1');
    code = code.replace(/"([^"]*)"\s*\+\s*`/g, '`$1');
    
    // Pass 2: `template` + 'string' becomes `templatestring`
    code = code.replace(/`\s*\+\s*'([^']*)'/g, '$1`');
    code = code.replace(/`\s*\+\s*"([^"]*)"/g, '$1`');
    
    // Pass 3: 'string1' + 'string2' merge into 'string1string2'
    code = code.replace(/'([^']*)'\s*\+\s*'([^']*)'/g, "'$1$2'");
    code = code.replace(/"([^"]*)"\s*\+\s*"([^"]*)"/g, '"$1$2"');
    
    // Clean up double slashes in paths (e.g., '//pages/...' -> '/pages/...')
    // Match quoted strings or template literals with //
    code = code.replace(/(['"`])\/\/+/g, '$1/');
    
    // Fix require/include statements
    code = code.replace(/(require|include|require_once|include_once)\s+([^;]+);/g, 
      (match, func, arg) => {
        arg = arg.trim();
        // Remove '' + or "" + or `` + from start
        arg = arg.replace(/^(['"`])\s*\+\s*/, '');
        // If it doesn't have parens, add them
        if (!arg.match(/^\(/)) {
          arg = `(${arg})`;
        }
        return `${func}${arg};`;
      });
    
    return code;
  }
}
</script>

<script>
const MarkdownRenderer = {
  rules: [
    { name: "Block quote", pattern: /&gt; ?(.*)/g, replacement: "<div class='quote'>$1</div>" },
    { name: "H6", pattern: /#{6} (.*)/g, replacement: "<h6>$1</h6>" },
    { name: "H5", pattern: /#{5} (.*)/g, replacement: "<h5>$1</h5>" },
    { name: "H4", pattern: /#{4} (.*)/g, replacement: "<h4>$1</h4>" },
    { name: "H3", pattern: /#{3} (.*)/g, replacement: "<h3>$1</h3>" },
    { name: "H2", pattern: /#{2} (.*)/g, replacement: "<h2>$1</h2>" },
    { name: "H1", pattern: /# (.*)/g, replacement: "<h1>$1</h1>" },
    { name: "Horizontal line", pattern: /(-{3,}|_{3,}|\*{3,})/g, replacement: "<hr>" },
    { name: "Bold", pattern: /(\*{2}|_{2})(.*?)\1/g, replacement: "<b>$2</b>" },
    { name: "Italic", pattern: /(\*|_)(.*?)\1/g, replacement: "<em>$2</em>" },
    { name: "Strikethrough", pattern: /~~(.*?)~~/g, replacement: "<strike>$1</strike>" },
    { name: "Marked", pattern: /==(.*?)==/g, replacement: "<mark>$1</mark>" },
    { name: "Insert", pattern: /\+\+(.*?)\+\+/g, replacement: "<ins>$1</ins>" },
    { name: "Code block", pattern: /`{3}(.*?)`{3}/gs, replacement: "<pre class='code-block'><code>$1</code></pre>" },
    { name: "Inline code", pattern: /`([^`]+)`/g, replacement: "<span class='code-inline'>$1</span>" },
    { name: "Images with title", pattern: /!\[([^\]]+)\]\(([^ )]+) "([^"]+)"\)/g, replacement: "<img src='$2' title='$3' alt='$1' style='max-width:100%'>" },
    { name: "Images", pattern: /!\[([^\]]+)\]\(([^ )]+)\)/g, replacement: "<img src='$2' alt='$1' style='max-width:100%'>" },
    { name: "Links with title", pattern: /\[([^\]]+)\]\(([^ )]+) "([^"]+)"\)/g, replacement: "<a target='_blank' href='$2' title='$3'>$1</a>" },
    { name: "Links", pattern: /\[([^\]]+)\]\(([^ )]+)\)/g, replacement: "<a target='_blank' href='$2'>$1</a>" },
    { name: "Copyright", pattern: /\((c|C)\)/g, replacement: "¬©" },
    { name: "Registered", pattern: /\((r|R)\)/g, replacement: "¬Æ" },
    { name: "Trademark", pattern: /\((tm|TM)\)/g, replacement: "‚Ñ¢" },
    { name: "Paragraph", pattern: /\((p|P)\)/g, replacement: "¬ß" },
    { name: "Plus minus", pattern: /\+-/g, replacement: "¬±" },
    { name: "Line breaks", pattern: /\n/g, replacement: "<br>" }
  ],

  render(text) {
    // 1. Escape HTML first (so &gt; matches work)
    let output = text
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");

    // 2. Apply rules
    this.rules.forEach(rule => {
      if (rule.name === 'Line breaks') return;
      output = output.replace(rule.pattern, rule.replacement);
    });

        // 3. Paragraphs
    const codeBlocks = [];
    output = output.replace(/<pre class='code-block'><code>[\s\S]*?<\/code><\/pre>/g, (match) => {
      codeBlocks.push(match);
      return `__CODE_BLOCK_${codeBlocks.length - 1}__`;
    });

    const lines = output.split('\n');
    const newLines = [];
    let inParagraph = false;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const isBlank = line.trim() === '';
      const isHeader = /^<h[1-6]/.test(line);
      const isQuote = /^<div class='quote'>/.test(line);
      const isHr = /^<hr>/.test(line);
      const isCode = /^__CODE_BLOCK_/.test(line);
      
      if (isHeader || isQuote || isHr || isCode || isBlank) {
        if (inParagraph) {
          newLines.push('</p>');
          inParagraph = false;
        }
        newLines.push(line);
      } else {
        if (!inParagraph) {
          newLines.push('<p>');
          inParagraph = true;
        } else {
          if (newLines.length > 0) newLines[newLines.length - 1] += '<br>';
        }
        newLines.push(line);
      }
    }
    if (inParagraph) newLines.push('</p>');
    
    output = newLines.join('\n');
    
    output = output.replace(/__CODE_BLOCK_(\d+)__/g, (match, id) => {
      return codeBlocks[id];
    });

    return output;
  }
};

class VSCodeLikeEditor {
  constructor() {
    this.dirtyFiles = new Set();
    this.openTabs = [];
    this.currentTab = null;
    this.editor = null;
    this.currentMode = 'edit';
    this.previewVisible = false;
    this.previewTimeout = null;
    this.selectedFolder = '';
    this.contextMenuTarget = null;
    this.openFolders = new Set();
    this.offline = OFFLINE_MODE; // Use global config
    this.zipFileName = null;
    this.lastBlobUrl = null;
    this.fileHandle = null; // Store file handle for direct saving
    this.currentVirtualUri = null;
    this.currentQueryString = null;
    this.isVirtualNavigation = false;
    this.files = new Map();
    this.folders = new Set();
    this.phpTranspiler = new PHPTranspiler(this.files, '');
    this.sessions = new Map();
    this.activeDevToolsTab = 'elements';
    this.isInspecting = false;
    this.currentPreviewFile = null;
    this.initializeUI();
  }

  async triggerFileOpen() {
    // Try to use File System Access API first
    if ('showOpenFilePicker' in window) {
      try {
        const [handle] = await window.showOpenFilePicker({
          types: [{
            description: 'ZIPSite Files',
            accept: { 'application/zip': ['.zip'] }
          }],
          multiple: false
        });
        this.fileHandle = handle;
        const file = await handle.getFile();
        this.loadZipFile(file);
      } catch (err) {
        // User cancelled, do nothing
      }
    } else {
      // Fallback to file input
      document.getElementById('fileInput').click();
    }
  }

  newProject() {
    if (this.dirtyFiles.size > 0) {
      if (!confirm('You have unsaved changes. Are you sure you want to create a new project?')) return;
    }

    this.files.clear();
    this.folders.clear();
    this.sessions.clear();
    this.openTabs = [];
    this.dirtyFiles.clear();
    this.currentTab = null;
    this.currentPreviewFile = null;
    this.fileHandle = null;
    this.zipFileName = 'untitled.zip';

    this.displayFileTree();
    document.getElementById('tabsContainer').innerHTML = '';
    document.getElementById('editorContent').innerHTML = '<div class="empty-state" style="display: flex; flex-direction: column; align-content: center; justify-content: center; width: 100%; height: 100%;"><div style="font-size: 48px; opacity: 0.3; display: flex; justify-content: center;">üìÑ</div><div style="font-size: 14px; font-weight: 500; display: flex; justify-content: center;">No file open</div></div>';
    document.getElementById('previewBody').innerHTML = '<div class="preview-empty">No HTML file active</div>';
    document.getElementById('fileCount').innerHTML = '<span>üì¶</span><span>Untitled</span>';
    document.getElementById('uploadSection').style.display = 'none';
    document.getElementById('sidebarActions').style.display = 'flex';
    document.title = 'ZIPSite - Untitled';
  }

  newPHPProject() {
    if (this.dirtyFiles.size > 0) {
      if (!confirm('You have unsaved changes. Are you sure you want to create a new project?')) return;
    }

    this.files.clear();
    this.folders.clear();
    this.sessions.clear();
    this.openTabs = [];
    this.dirtyFiles.clear();
    this.currentTab = null;
    this.currentPreviewFile = null;
    this.fileHandle = null;
    this.zipFileName = 'php-project.zip';

    const encoder = new TextEncoder();

        // add folder
    this.folders.add('_/');
    this.folders.add('admin/');
    this.folders.add('assets/');
    this.folders.add('assets/images/');
    this.folders.add('data/');
    this.folders.add('layout/');
    this.folders.add('layout/css/');
    this.folders.add('layout/images/');
    this.folders.add('pages/');

    // .htaccess
    const htaccess = `<IfModule mod_rewrite.c>

SetEnv HTTP_MOD_REWRITE On
Options +FollowSymLinks
RewriteEngine On

# BLOCK folders from web access
RewriteRule ^admin/data(/|$) - [F,L]
RewriteRule ^data(/|$) - [F,L]

# Redirects
# ==================================================
RewriteCond %{REQUEST_FILENAME} -f [OR]
RewriteCond %{REQUEST_FILENAME} -d
RewriteRule ^ - [L]

# Skip these folders
RewriteRule ^(admin|assets|data|layout)(/|$) - [L]

FallbackResource /index.php

# ==================================================

RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d

</IfModule>
`;
    this.files.set('.htaccess', encoder.encode(htaccess));

    // index.php
    const indexPhp = `<?php
/*
============================================================
REQUEST PARSING
============================================================
*/

$uri = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH);

// Normalize slashes
$uri = rtrim($uri, '/');
if ($uri === '') {
  $uri = '/';
}

// Build route
$route = trim($uri, '/');

/*
============================================================
LANGUAGE DETECTION
============================================================
*/

$lang = 'en';         // default language
$langFromUrl = false; // For multi-language support

$route = trim($uri, '/');
$segments = $route === '' ? [] : explode('/', $route);

if (isset($segments[0]) && in_array($segments[0], ['jp', 'en'], true)) {
  $lang = $segments[0];
  $langFromUrl = true;
  array_shift($segments);
}

$route = implode('/', $segments);

/*
============================================================
ROUTING
============================================================
*/

$pagesDir = __DIR__ . '/pages';
$file = null;

// ROOT
if ($route === '') {
  $file = "$pagesDir/index.php";
}

// ALL OTHER ROUTES
else {
  // Remove .php extension if present
  $route = preg_replace('~\.php$~i', '', $route);

  // Split route into segments
  $segments = explode('/', $route);

  // Default behavior
  $mapped = str_replace('/', '__', $route);

  // Try direct page
  $file = "$pagesDir/$mapped.php";

  // Fallback to index
  if (!is_file($file)) {
    $file = "$pagesDir/{$mapped}__index.php";
  }
}

/*
============================================================
RESPONSE
============================================================
*/

if ($file && is_file($file)) {
  require $file;
  exit;
}

http_response_code(404);

$notFound = __DIR__ . '/404.php';

if (is_file($notFound)) {
  require $notFound;
  exit;
}

echo "<h1>404 Not Found</h1>";
echo "<p>No page found for <code>/$route</code></p>";`;
    this.files.set('index.php', encoder.encode(indexPhp));

    // pages/index.php
    const pagesIndex = `<?php

switch ($lang) {
  case "jp":
    $add_meta = array(
      "title"       => "„Çø„Ç§„Éà„É´",
      "description" => "Ë™¨Êòé",
      "keywords"    => "„Ç≠„Éº„ÉØ„Éº„Éâ"
    );
    // OpenGraph (og) : https://ogp.me/
    $share_og = array(
      // required
      "title"            => "SNS „Çø„Ç§„Éà„É´",
      "image"            => "https://www.example/assets/share/index.jpg",
      "url"              => "https://www.example.com/",
      "type"             => "website",

      // optional
      "description"      => "SNS Ë™¨Êòé",
      "locale"           => "ja_JP",
      "locale:alternate" => array("en_US")
    );

    // Twitter / ùïè specific
    $share_x = array(
      "creator"     => "@example",
      "site"        => "@example",
      "card"        => "summary_large_image"
    );

    $header_logo = "";
    $header_text = "";
    break;

  case "en":
    default:
    $add_meta = array(
      "title"       => "Title",
      "description" => "Description",
      "keywords"    => "Keywords"
    );
    // OpenGraph (og) : https://ogp.me/
    $share_og = array(
      // required
      "title"            => "SNS Title",
      "image"            => "https://www.example/assets/share/index.jpg",
      "url"              => "https://www.example.com/",
      "type"             => "website",

      // optional
      "description"      => "SNS Description",
      "locale"           => "en_US",
      "locale:alternate" => array("ja_JP")
    );

    // Twitter / ùïè specific
    $share_x = array(
      "creator"     => "@example",
      "site"        => "@example",
      "card"        => "summary_large_image"
    );

    $header_logo = "";
    $header_text = "";
    break;
}

$add_css  = array(
);

$add_jstop  = array(
);

$add_jsbottom  = array(
);

include($_SERVER['DOCUMENT_ROOT'] . '/layout/top.php');

?>

<style>

</style>

<main>
  <h1>Welcome to your PHP ZIPSite!</h1>
  <p>This is served from pages/index.php</p>
  <p>Request URI: <?php echo $_SERVER["REQUEST_URI"]; ?></p>
</main>

<?php
include($_SERVER['DOCUMENT_ROOT'] . '/layout/bottom.php');
?>`;
    this.files.set('pages/index.php', encoder.encode(pagesIndex));

    // 404.php
    const errorFile = `
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>404 - Page not found</title>
<style>
body {
  font-family: monospace;
  padding: 20px;
}

.debug {
  margin-top: 10px;
  color: #a00;
}
</style>
</head>
<body>

<h1>404 - Page not found</h1>

<p>The requested URL could not be resolved.</p>

<div class="debug">
<?php
http_response_code(404);

echo "<strong>Requested URI:</strong><br>";
echo htmlspecialchars($_SERVER['REQUEST_URI']) . "<br><br>";
?>
</div>

</body>
</html>
`;
    this.files.set('404.php', encoder.encode(errorFile));

    // README.md
    const readmeFile = `# README.md`;
    this.files.set('README.md', encoder.encode(readmeFile));

    // layout/top.php
    const layoutTop = `<?php

$hText = ""; 
$hImage = "";
$links = "";
$morelink = ""; 

$path  = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH);
$parts = explode('/', trim($path, '/'));

$lang   = "jp";
$sub    = null;
$pieces = null;

echo "\\n\\n";

if (isset($parts[0]) && ($parts[0] === 'en' || $parts[0] === 'jp')) {
    $lang = $parts[0];
    array_shift($parts);
}

if (isset($parts[0]) && $parts[0] !== 'pages') {
    $sub = $parts[0];
}

if (isset($parts[0]) && $parts[0] === 'pages' && isset($parts[1])) {

    $filename = $parts[1];
    
    if ($parts[1] === 'discography') {
      $filename = $parts[2];
    }

    if (strpos($filename, '__') !== false) {
        $pieces = explode('__', $filename, 2);
        $sub = $pieces[0];
    } else {
        $sub = $filename;
    }
}

echo <<<HTML
<!DOCTYPE html>
<html lang="{$lang}">
<head>
  <meta charset="UTF-8">
HTML;

if ($langFromUrl) {
  echo "\\n  <base href=\\"/" . htmlspecialchars($lang) . "/\\">\\n";
} else {
  echo "\\n  <base href=\\"/\\">\\n";
}

if (isset($add_meta) && is_array($add_meta)) {
  echo "\\n<!-- „É°„Çø„Çø„Ç∞Ë®òËø∞ -->\\n";

  foreach ($add_meta as $name => $content) {
    if (!empty($content)) {
      if ($name === 'title') {
        echo "<title>" . htmlspecialchars($content, ENT_QUOTES, 'UTF-8') . "</title>\\n";
        echo "<meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no\\" />\\n";
      } else {
        echo "<meta name=\\"" . htmlspecialchars($name, ENT_QUOTES, 'UTF-8') . "\\" content=\\"" . htmlspecialchars($content, ENT_QUOTES, 'UTF-8') . "\\" />\\n";
      }
    }
  }
}

if (isset($share_og)) {
  echo "\\n<!-- ogÁ≥ªË®òËø∞ -->\\n";

  foreach ($share_og as $property => $content) {
    if (is_array($content)) {
      foreach ($content as $subcontent) {
        echo "<meta property=\\"og:" . $property . "\\" content=\\"" . htmlspecialchars($subcontent, ENT_QUOTES, 'UTF-8') . "\\" />\\n";
      }
    } else {
      echo "<meta property=\\"og:" . $property . "\\" content=\\"" . htmlspecialchars($content, ENT_QUOTES, 'UTF-8') . "\\" />\\n";
    }
  }
}

if (isset($share_x) || isset($share_og)) {
  echo "\\n<!-- Twitter/ùïèÁ≥ªË®òËø∞ -->\\n";

  $share_twitter = array_merge(
    array_intersect_key($share_og, array_flip(['title', 'description', 'image', 'url'])),
    $share_x
  );

  foreach ($share_twitter as $property => $content) {
    if (is_array($content)) {
      foreach ($content as $subcontent) {
        echo "<meta property=\\"twitter:" . $property . "\\" content=\\"" . htmlspecialchars($subcontent, ENT_QUOTES, 'UTF-8') . "\\" />\\n";
      }
    } else {
      echo "<meta property=\\"twitter:" . $property . "\\" content=\\"" . htmlspecialchars($content, ENT_QUOTES, 'UTF-8') . "\\" />\\n";
    }
  }
}

echo "\\n";
?>
<title>Document</title>
</head>
<body>

<header></header>

`;
    this.files.set('layout/top.php', encoder.encode(layoutTop));

    // layout/bottom.php
    const layoutBottom = `
<footer></footer>

<?php

if (isset($add_jsbottom) && is_array($add_jsbottom)) {
  foreach ($add_jsbottom as $jsbottom_file) {
    echo "<script src=\\"" . htmlspecialchars($jsbottom_file, ENT_QUOTES, 'UTF-8') . "\\" /><\/script>\\n";
  }
}

?>

</body>
</html>
`;
    this.files.set('layout/bottom.php', encoder.encode(layoutBottom));

    this.displayFileTree();
    
    document.getElementById('tabsContainer').innerHTML = '';
    document.getElementById('editorContent').innerHTML = '<div class="empty-state" style="display: flex; flex-direction: column; align-content: center; justify-content: center; width: 100%; height: 100%;"><div style="font-size: 48px; opacity: 0.3; display: flex; justify-content: center;">üìÑ</div><div style="font-size: 14px; font-weight: 500; display: flex; justify-content: center;">No file open</div></div>';
    document.getElementById('previewBody').innerHTML = '<div class="preview-empty">No HTML file active</div>';
    document.getElementById('fileCount').innerHTML = '<span>üì¶</span><span>PHP Project</span>';
    document.getElementById('uploadSection').style.display = 'none';
    document.getElementById('sidebarActions').style.display = 'flex';
    document.title = 'ZIPSite - PHP Project';

    this.openFile('index.php');
  }

  initializeUI() {
    // Setup preview navigation
    const urlInput = document.getElementById('virtualUrl');
    const queryInput = document.getElementById('virtualQuery');
    
    const handleNav = (e) => {
      const activeEl = document.activeElement;
      if (e.key === 'Enter' && (activeEl === urlInput || activeEl === queryInput)) {
        e.preventDefault(); // Prevent form submission if it's in a form
        this.handleVirtualNavigation(); 
      }
    };

    document.getElementById("homeButton").addEventListener("click", () => {
      urlInput.value = "/";
      queryInput.value = "";

      this.handleVirtualNavigation();
    });


    // Listen on the document to catch Enter key presses
    document.addEventListener('keydown', handleNav);

    // Search Input
    const searchInput = document.getElementById('searchInput');
    if (searchInput) {
      searchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') this.performSearch(e.target.value);
      });
    }

    // DevTools Input
    const devtoolsInput = document.getElementById('devtoolsInput');
    if (devtoolsInput) {
      devtoolsInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') this.handleConsoleInput(e.target.value);
      });
    }

    const uploadArea = document.getElementById('uploadArea');
    const fileInput = document.getElementById('fileInput');

    uploadArea.addEventListener('click', async () => {
      this.triggerFileOpen();
    });
   
    uploadArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadArea.classList.add('dragover');
    });

    uploadArea.addEventListener('dragleave', () => {
      uploadArea.classList.remove('dragover');
    });

    uploadArea.addEventListener('drop', (e) => {
      e.preventDefault();
        uploadArea.classList.remove('dragover');
        const file = e.dataTransfer.files[0];
        if (file && file.name.endsWith('.zip')) {
          this.loadZipFile(file);
        } else {
          this.showNotification('Please drop a ZIP file', 'error');
        }
      });

      fileInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (file) {
          // Try to get a file handle if File System Access API is supported
          try {
            if ('showOpenFilePicker' in window) {
              const [handle] = await window.showOpenFilePicker({
                types: [{
                  description: 'ZIPSite Files',
                  accept: { 'application/zip': ['.zip'] }
                }],
                multiple: false
              });
              this.fileHandle = handle;
              const file = await handle.getFile();
              this.loadZipFile(file);
            } else {
              // Fallback to regular file input (no handle available)
              this.fileHandle = null;
              this.loadZipFile(file);
            }
          } catch (err) {
            // User cancelled or error - try regular file if we have one
            if (file) {
              this.fileHandle = null;
              this.loadZipFile(file);
            }
          }
        }
      });

      // Keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if (e.ctrlKey || e.metaKey) {
          if (e.key === 's') {
            e.preventDefault();
            this.saveZip('STORE'); // Save entire ZIP
          } else if (e.key === 'w') {
            e.preventDefault();
            this.closeCurrentTab();
          } else if (e.key === 'r') {
            e.preventDefault();
            this.refreshPreview();
          }
        }
      });

      // Horizontal scrolling for tabs with mouse wheel
      const tabsContainer = document.getElementById('tabsContainer');
      tabsContainer.addEventListener('wheel', (e) => {
        e.preventDefault();
        tabsContainer.scrollLeft += e.deltaY;
      });

      // Close context menu on click outside
      document.addEventListener('click', () => {
        this.closeContextMenu();
      });

      document.addEventListener('contextmenu', (e) => {
        // Only prevent default if not on our context menu items
        const contextMenu = document.querySelector('.explorer-menu');
        if (!contextMenu || !contextMenu.contains(e.target)) {
          this.closeContextMenu();
        }
      });

      // Listen for resource requests from iframe
      window.addEventListener('message', (e) => {
        // Handle old-style asset fetching (from old preview engine)
        if (e.data.type === 'FETCH_ZIP_ASSET') {
          const { path, base, requestId } = e.data;
          
          const normalize = (p) => {
            const parts = [];
            p.split("/").forEach(seg => {
              if (!seg || seg === ".") return;
              if (seg === "..") parts.pop();
              else parts.push(seg);
            });
            return parts.join("/");
          };

          let zipPath = path.startsWith("/") 
            ? normalize(path.slice(1)) 
            : normalize(base.split("/").slice(0, -1).join("/") + "/" + path);

          try {
            const fileData = this.files.get(zipPath);
            if (fileData) {
              const ext = zipPath.split(".").pop().toLowerCase();
              const mime = ext === "svg" ? "image/svg+xml" : `image/${ext}`;
              this.logNetworkRequest(zipPath.split('/').pop(), 200, 'image', fileData.byteLength, '10ms');
              
              // Convert to base64
              let data;
              if (ext === "svg") {
                const text = new TextDecoder().decode(fileData);
                data = btoa(unescape(encodeURIComponent(text)));
              } else {
                const bytes = new Uint8Array(fileData);
                let binary = '';
                const chunkSize = 0x8000;
                for (let i = 0; i < bytes.length; i += chunkSize) {
                  binary += String.fromCharCode.apply(null, bytes.subarray(i, Math.min(i + chunkSize, bytes.length)));
                }
                data = btoa(binary);
              }

              e.source.postMessage({
                type: 'ZIP_ASSET_READY',
                requestId: requestId,
                dataUrl: `data:${mime};base64,${data}`
              }, "*");
            }
          } catch (err) {
            this.logNetworkRequest(zipPath.split('/').pop(), 404, 'image', 0, '10ms');
            console.error("Asset not found:", zipPath, err);
          }
        }
        
        // Handle navigation from links in preview
        if (e.data.type === 'ZIP_NAV') {
          const { href, base } = e.data;

          // Split query string
          let pathPart = href;
          let queryPart = '';
          if (href.indexOf('?') !== -1) {
            const qIdx = href.indexOf('?');
            pathPart = href.substring(0, qIdx);
            queryPart = href.substring(qIdx + 1);
          }

          const normalizePath = (p) => {
            const parts = [];
            p.split("/").forEach(seg => {
              if (!seg || seg === ".") return;
              if (seg === "..") parts.pop();
              else parts.push(seg);
            });
            return parts.join("/");
          };

          let virtualPath;
          
          // Handle root navigation
          if (pathPart === "/" || pathPart === "") {
            virtualPath = "/";
          } else if (pathPart.startsWith("/")) {
            // Absolute path from root
            virtualPath = "/" + normalizePath(pathPart.slice(1));
          } else {
            // Relative path
            const baseDir = base ? base.split("/").slice(0, -1).join("/") : "";
            const normalized = normalizePath(baseDir ? baseDir + "/" + pathPart : pathPart);
            virtualPath = "/" + normalized;
          }

          const resolvedFile = this.resolveHtaccess(virtualPath);

          if (resolvedFile) {
            this.isVirtualNavigation = true;
            this.currentVirtualUri = virtualPath;
            this.currentQueryString = queryPart;
            this.openFile(resolvedFile);
            this.isVirtualNavigation = false;
          } else {
            this.showNotification(`File not found: ${virtualPath}`, 'error');
          }
        }
        
        // Handle double-click to open source (don't navigate, just open in editor)
        if (e.data.type === 'ZIP_OPEN_SOURCE') {
          const { href, base } = e.data;

          // Split query string
          let pathPart = href;
          if (href.indexOf('?') !== -1) {
            pathPart = href.substring(0, href.indexOf('?'));
          }

          const normalizePath = (p) => {
            const parts = [];
            p.split("/").forEach(seg => {
              if (!seg || seg === ".") return;
              if (seg === "..") parts.pop();
              else parts.push(seg);
            });
            return parts.join("/");
          };

          let virtualPath;
          
          // Handle root navigation
          if (pathPart === "/" || pathPart === "") {
            virtualPath = "/";
          } else if (pathPart.startsWith("/")) {
            // Absolute path from root
            virtualPath = "/" + normalizePath(pathPart.slice(1));
          } else {
            // Relative path
            const baseDir = base ? base.split("/").slice(0, -1).join("/") : "";
            const normalized = normalizePath(baseDir ? baseDir + "/" + pathPart : pathPart);
            virtualPath = "/" + normalized;
          }

          const resolvedFile = this.resolveHtaccess(virtualPath);

          if (resolvedFile) {
            if (!this.openTabs.includes(resolvedFile)) {
              this.openTabs.push(resolvedFile);
              this.createTab(resolvedFile);
            }
            this.switchToTab(resolvedFile);
          } else {
            this.showNotification(`File not found: ${virtualPath}`, 'error');
          }
        }
        
        // Handle new-style resource requests
        if (e.data.type === 'REQUEST_ZIP_RESOURCE') {
          const { path, elementId } = e.data;
          
          if (this.files.has(path)) {
            const fileData = this.files.get(path);
            this.logNetworkRequest(path.split('/').pop(), 200, 'fetch', fileData.byteLength, '15ms');
            const mimeType = this.getMimeType(path);
            const dataUrl = this.createDataUrl(fileData, mimeType);
            
            // Send the data URL back to the iframe
            e.source.postMessage({
              type: 'ZIP_RESOURCE_RESPONSE',
              path: path,
              dataUrl: dataUrl,
              elementId: elementId
          }, '*');
          } else {
            this.logNetworkRequest(path.split('/').pop(), 404, 'fetch', 0, '15ms');
          }
        }

        // Handle Console Logs
        if (e.data.type === 'CONSOLE_LOG') {
          this.logToConsole(e.data.logType, e.data.args);
        }

        if (e.data.type === 'REFRESH_PREVIEW') {
          this.refreshPreview();
        }

        // Handle generic file fetch from iframe
        if (e.data.type === 'FETCH_ZIP_FILE') {
          const { path, base, requestId } = e.data;
          
          const normalize = (p) => {
            const parts = [];
            p.split("/").forEach(seg => {
              if (!seg || seg === ".") return;
              if (seg === "..") parts.pop();
              else parts.push(seg);
            });
            return parts.join("/");
          };

          let zipPath;
          if (path.startsWith("/")) {
             zipPath = normalize(path.slice(1));
          } else {
             const baseDir = base ? base.split("/").slice(0, -1).join("/") : "";
             zipPath = normalize(baseDir ? baseDir + "/" + path : path);
          }
          
          let fileData = this.files.get(zipPath);
          
          // Case-insensitive fallback
          if (!fileData) {
             const lowerZipPath = zipPath.toLowerCase();
             for (const [key, value] of this.files.entries()) {
                if (key.toLowerCase() === lowerZipPath) {
                   fileData = value;
                   zipPath = key; // Update zipPath for mime type check
                   break;
                }
             }
          }
          
          if (fileData) {
             const mime = this.getMimeType(zipPath);
             this.logNetworkRequest(zipPath.split('/').pop(), 200, 'fetch', fileData.byteLength, '20ms');
             const dataUrl = this.createDataUrl(fileData, mime);
             
             e.source.postMessage({
               type: 'ZIP_FILE_RESPONSE',
               requestId: requestId,
               dataUrl: dataUrl
             }, '*');
          } else {
             this.logNetworkRequest(zipPath.split('/').pop(), 404, 'fetch', 0, '20ms');
             console.warn('[ZIP] File not found:', zipPath);
             e.source.postMessage({
               type: 'ZIP_FILE_RESPONSE',
               requestId: requestId,
               error: 'Not found'
             }, '*');
          }
        }
      });

      // Setup drag and drop for file tree root
      const fileTree = document.getElementById('fileTree');
      
      fileTree.addEventListener('dragover', (e) => {
        e.preventDefault();
        fileTree.style.background = 'var(--item-hover)';
      });
      
      fileTree.addEventListener('dragleave', (e) => {
        // Only clear if we're leaving the fileTree itself, not a child
        if (e.target === fileTree) {
          fileTree.style.background = '';
        }
      });
      
      fileTree.addEventListener('drop', (e) => {
        e.preventDefault();
        fileTree.style.background = '';
        
        // Check if this is an internal drag (moving files within ZIP)
        const internalPath = e.dataTransfer.getData('text/plain');
        if (internalPath) {
          this.handleInternalMove(internalPath, '');
        } else {
          // External file drop
          this.handleFileDrop(e, '');
        }
      });

      // Setup resizers
      this.setupResizers();
  }

  setupResizers() {
    const resizer1 = document.getElementById('resizer1');
    const resizer2 = document.getElementById('resizer2');
    const devtoolsResizer = document.getElementById('devtoolsResizer');
    const sidebar = document.getElementById('sidebar');
    const previewPane = document.getElementById('previewPane');
    const devtoolsPane = document.getElementById('devtoolsPane');

    let isResizing = false;
    let currentResizer = null;

    const startResize = (resizer) => {
      isResizing = true;
      currentResizer = resizer;
      resizer.classList.add('dragging');
      document.body.style.cursor = 'col-resize';
      // Disable pointer events on iframes so they don't "swallow" mousemove
      const iframes = document.querySelectorAll('iframe');
      iframes.forEach(f => f.style.pointerEvents = 'none');
    };

    const stopResize = () => {
      if (isResizing) {
        isResizing = false;
        if (currentResizer) currentResizer.classList.remove('dragging');
        document.body.style.cursor = '';
        const iframes = document.querySelectorAll('iframe');
        iframes.forEach(f => f.style.pointerEvents = 'auto');
        if (this.editor) this.editor.resize();
      }
    };

    const doResize = (e) => {
      if (!isResizing) return;

      if (currentResizer === resizer1) {
        // Sidebar Resize (Left)
        const newWidth = e.clientX - sidebar.getBoundingClientRect().left;
        if (newWidth > 50 && newWidth < 600) {
          sidebar.style.width = newWidth + 'px';
        }
      } else if (currentResizer === resizer2) {
        // Preview Resize (Right) - Fixed Logic
        const containerWidth = window.innerWidth;
        // Calculate width from the right side of the screen
        const newWidth = containerWidth - e.clientX; 
        if (newWidth > 50 && newWidth < (containerWidth - 200)) {
          previewPane.style.width = newWidth + 'px';
        }
      } else if (currentResizer === devtoolsResizer) {
        // DevTools Resize (Vertical)
        const previewRect = previewPane.getBoundingClientRect();
        const newHeight = previewRect.bottom - e.clientY;
        if (newHeight > 28 && newHeight < (previewRect.height - 50)) {
          devtoolsPane.style.height = newHeight + 'px';
        }
      }

      if (this.editor) this.editor.resize();
    };

    resizer1.addEventListener('mousedown', () => startResize(resizer1));
    resizer2.addEventListener('mousedown', () => startResize(resizer2));
    devtoolsResizer.addEventListener('mousedown', () => startResize(devtoolsResizer));
    document.addEventListener('mousemove', doResize);
    document.addEventListener('mouseup', stopResize);
  }

  showNotification(message, type = 'success') {
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.innerHTML = `
        <span>${type === 'success' ? '‚úì' : '‚ö†'}</span>
        <span>${message}</span>
      `;
      document.body.appendChild(notification);
      setTimeout(() => {
        notification.remove();
      }, 3000);
  }

  async loadZipFile(file) {
    try {
      this.zipFileName = file.name;
      this.showNotification('Loading ZIP file...', 'success');
      const arrayBuffer = await file.arrayBuffer();
      await this.parseZip(arrayBuffer);
      this.showNotification(`Successfully loaded ${this.files.size} files`, 'success');
      this.displayFileTree();
      document.getElementById('uploadSection').style.display = 'none';
      document.getElementById('sidebarActions').style.display = 'flex';
      document.getElementById('fileCount').innerHTML = `
        <span>üì¶</span>
        <span>${file.name}</span>
      `;
      // Update page title
      document.title = `ZIPSite - ${file.name}`;
    } catch (error) {
      this.showNotification(`Error loading ZIP: ${error.message}`, 'error');
      console.error('ZIP loading error:', error);
    }
  }

  async parseZip(arrayBuffer) {
    this.files = new Map();
    this.folders = new Set();
    this.phpTranspiler.files = this.files;

    const view = new DataView(arrayBuffer);
    const cdOffset = this.findCentralDirectory(arrayBuffer);
    if (cdOffset === -1) {
      throw new Error('Invalid ZIP file: Central directory not found');
    }

    let offset = cdOffset;

    while (offset < arrayBuffer.byteLength - 4) {
      const signature = view.getUint32(offset, true);
      
      if (signature === 0x02014b50) {
        const fileNameLength = view.getUint16(offset + 28, true);
        const extraFieldLength = view.getUint16(offset + 30, true);
        const fileCommentLength = view.getUint16(offset + 32, true);
        const localHeaderOffset = view.getUint32(offset + 42, true);
        
        const fileName = new TextDecoder().decode(
          new Uint8Array(arrayBuffer, offset + 46, fileNameLength)
        );

        if (fileName.endsWith('/')) {
          this.folders.add(fileName);
        } else {
          const fileData = this.extractFileData(arrayBuffer, localHeaderOffset);
          if (fileData) {
            this.files.set(fileName, fileData);
          }
        }

        offset += 46 + fileNameLength + extraFieldLength + fileCommentLength;
      } else {
        break;
      }
    }

    Array.from(this.folders).forEach(folder => {
      let current = '';
      folder.split('/').filter(Boolean).forEach(part => {
        current += part + '/';
        this.folders.add(current);
      });
    });
  }

  findCentralDirectory(arrayBuffer) {
    const view = new DataView(arrayBuffer);
    for (let i = arrayBuffer.byteLength - 22; i >= 0; i--) {
      if (view.getUint32(i, true) === 0x06054b50) {
        return view.getUint32(i + 16, true);
      }
    }
    return -1;
  }

  extractFileData(arrayBuffer, localHeaderOffset) {
    const view = new DataView(arrayBuffer);
    const signature = view.getUint32(localHeaderOffset, true);
    
    if (signature !== 0x04034b50) return null;

    const compressionMethod = view.getUint16(localHeaderOffset + 8, true);
    const compressedSize = view.getUint32(localHeaderOffset + 18, true);
    const fileNameLength = view.getUint16(localHeaderOffset + 26, true);
    const extraFieldLength = view.getUint16(localHeaderOffset + 28, true);

    const dataOffset = localHeaderOffset + 30 + fileNameLength + extraFieldLength;
    const compressedData = new Uint8Array(arrayBuffer, dataOffset, compressedSize);

    if (compressionMethod === 0) {
      return compressedData;
    }

    return compressedData;
  }

  switchSidebarView(view) {
    document.getElementById('explorerView').style.display = view === 'explorer' ? 'flex' : 'none';
    document.getElementById('searchView').style.display = view === 'search' ? 'flex' : 'none';
    
    document.getElementById('act-explorer').classList.toggle('active', view === 'explorer');
    document.getElementById('act-search').classList.toggle('active', view === 'search');
    
    if (view === 'search') {
        document.getElementById('searchInput').focus();
    }
  }

  performSearch(query) {
    if (!query || query.length < 2) return;
    
    const resultsContainer = document.getElementById('searchResults');
    resultsContainer.innerHTML = '<div style="color: var(--text-muted); font-size: 12px; text-align: center; padding: 20px;">Searching...</div>';
    
    const results = [];
    const encoder = new TextDecoder();
    
    this.files.forEach((content, path) => {
      const mime = this.getMimeType(path);
      if (this.isTextFile(mime)) {
        const text = encoder.decode(content);
        const lines = text.split('\n');
        const fileMatches = [];
        
        lines.forEach((line, index) => {
          if (line.toLowerCase().includes(query.toLowerCase())) {
            fileMatches.push({ line: index + 1, content: line.trim() });
          }
        });
        
        if (fileMatches.length > 0) {
          results.push({ path, matches: fileMatches });
        }
      }
    });
    
    resultsContainer.innerHTML = '';
    if (results.length === 0) {
      resultsContainer.innerHTML = '<div style="color: var(--text-muted); font-size: 12px; text-align: center; padding: 20px;">No results found</div>';
      return;
    }
    
    results.forEach(res => {
      const fileDiv = document.createElement('div');
      fileDiv.className = 'search-result-item';
      fileDiv.innerHTML = `
        <div class="search-result-file" onclick="virtualEditor.openFile('${res.path}')" title="${res.path}">
            <span>${res.path}</span>
            <span class="search-badge">${res.matches.length}</span>
        </div>
      `;
      
      res.matches.forEach(match => {
        const matchDiv = document.createElement('div');
        matchDiv.className = 'search-result-match';
        matchDiv.textContent = match.content;
        matchDiv.title = `Line ${match.line}: ${match.content}`;
        matchDiv.onclick = (e) => {
          e.stopPropagation();
          this.openFile(res.path, match.line);
        };
        fileDiv.appendChild(matchDiv);
      });
      
      resultsContainer.appendChild(fileDiv);
    });
  }

  displayFileTree() {
    const fileTree = document.getElementById('fileTree');
    fileTree.innerHTML = '';

    const tree = this.buildTree();
    
    // Render tree
    this.renderTree(tree, fileTree, 0);
    
    // Show sidebar action buttons
    document.getElementById('sidebarActions').style.display = 'flex';
  }

  buildTree() {
    const tree = {};

    // 1. Add folders (even empty ones)
    this.folders.forEach(folderPath => {
      const parts = folderPath.split('/').filter(Boolean);
      let current = tree;

      parts.forEach(part => {
        if (!current[part]) {
          current[part] = {};
        }
        current = current[part];
      });
    });

    // 2. Add files
    this.files.forEach((_, filePath) => {
      const parts = filePath.split('/');
      let current = tree;

      parts.forEach((part, index) => {
        if (index === parts.length - 1) {
          if (!current._files) current._files = [];
          current._files.push(filePath);
        } else {
          if (!current[part]) {
            current[part] = {};
          }
          current = current[part];
        }
      });
    });

    return tree;
  }

  renderTree(node, container, depth, pathPrefix = '') {
    // Render folders first
    const folders = Object.keys(node).filter(key => key !== '_files').sort();
    
    folders.forEach(folderName => {
      const folderPath = pathPrefix ? `${pathPrefix}/${folderName}` : folderName;
      const folderLi = document.createElement('li');
      folderLi.className = 'tree-folder';
      
      const folderHeader = document.createElement('div');
      folderHeader.className = 'folder-header';
      folderHeader.style.paddingLeft = `${8 + depth * 16}px`;
      folderHeader.dataset.folderPath = folderPath;
      folderHeader.title = folderName;
      folderHeader.innerHTML = `
        <span class="folder-arrow">‚ùØ</span>
        <span class="folder-name">${folderName}</span>
      `;
      
      const childrenUl = document.createElement('ul');
      childrenUl.className = 'folder-children';
      
      // Restore folder state
      const isOpen = this.openFolders.has(folderPath);
      if (isOpen) {
        childrenUl.classList.add('expanded');
        folderHeader.querySelector('.folder-arrow').classList.add('expanded');
      }
      
      folderHeader.addEventListener('click', (e) => {
        // Toggle expansion
        const arrow = folderHeader.querySelector('.folder-arrow');
        const isExpanded = childrenUl.classList.toggle('expanded');
        arrow.classList.toggle('expanded', isExpanded);
        
        // Track folder state
        if (isExpanded) {
          this.openFolders.add(folderPath);
        } else {
          this.openFolders.delete(folderPath);
        }
        
        // Set as selected folder
        document.querySelectorAll('.folder-header').forEach(h => h.classList.remove('selected'));
        document.querySelectorAll('.file-item').forEach(f => f.classList.remove('selected'));
        folderHeader.classList.add('selected');
        this.selectedFolder = folderPath + '/';
      });

      // Context menu for folder
      folderHeader.addEventListener('contextmenu', (e) => {
        this.showContextMenu(e, folderHeader, 'folder');
      });

      // Make folder draggable
      folderHeader.draggable = true;
      
      folderHeader.addEventListener('dragstart', (e) => {
        e.stopPropagation();
        e.dataTransfer.setData('text/plain', folderPath);
        e.dataTransfer.effectAllowed = 'move';
        folderHeader.style.opacity = '0.5';
      });
      
      folderHeader.addEventListener('dragend', (e) => {
        folderHeader.style.opacity = '';
      });

      // Drag and drop support for folder
      folderHeader.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.stopPropagation();
        folderHeader.style.background = 'var(--item-hover)';
      });

      folderHeader.addEventListener('dragleave', (e) => {
        folderHeader.style.background = '';
      });

      folderHeader.addEventListener('drop', (e) => {
        e.preventDefault();
        e.stopPropagation();
        folderHeader.style.background = '';
        
        // Check if this is an internal drag (moving files within ZIP)
        const internalPath = e.dataTransfer.getData('text/plain');
        if (internalPath && internalPath !== folderPath) {
          this.handleInternalMove(internalPath, folderPath + '/');
        } else if (!internalPath) {
          // External file drop
          this.handleFileDrop(e, folderPath + '/');
        }
      });
      
      folderLi.appendChild(folderHeader);
      folderLi.appendChild(childrenUl);
      container.appendChild(folderLi);
      
      // Recursively render children
      this.renderTree(node[folderName], childrenUl, depth + 1, folderPath);
    });
    
    // Render files
    if (node._files) {
      node._files.sort().forEach(filePath => {
        const fileName = filePath.split('/').pop();
        const li = document.createElement('li');
        li.className = 'file-item';
        li.style.paddingLeft = `${8 + depth * 16}px`;

        const ext = fileName.split('.').pop().toLowerCase();

        let icon = "";

        switch (ext) {
          case 'htm':
          case 'html': icon = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" viewBox="-10 0 1010 1000"><path fill="#e37933" d="M250 469l188 -175v81l-141 125l141 125v81l-188 -175v-62zM750 534l-187 175v-84l143 -125l-143 -125v-84l187 175v68z" /></svg>`; break;
          case 'css':  icon = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" viewBox="-10 0 1010 1000"><path fill="#519aba" d="M322 728l25 -125h-78v-66h94l15 -78h-81v-65h97l25 -122h87l-25 122h88l25 -122h87l-25 122h78v65h-90l-19 78h81v66h-93l-25 125h-88l25 -125h-87l-25 125h-91zM538 538l15 -79h-87l-16 79h88z" /></svg>`; break;
          case 'js':   icon = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" viewBox="-10 0 1010 1000"><path fill="#f1e05a" d="M356 312h85v238q0 77 -36 112q-33 32 -99 32q-15 0 -33 -2.5t-29 -7.5l9 -68q19 9 44 9q28 0 42 -15q17 -18 17 -60v-238zM516 600q18 10 42 17q27 8 51 8q30 0 45 -10.5t15 -29.5t-14 -30.5t-49 -23.5q-103 -36 -103 -112q0 -50 38.5 -81.5t105.5 -31.5q53 0 97 19 l-19 69l-6 -3q-18 -7 -29 -10q-21 -6 -43 -6q-27 0 -41.5 10.5t-14.5 27.5t16 28q12 9 52 25q50 19 73.5 46t23.5 66q0 50 -38 81q-41 35 -115 35q-29 0 -61 -8q-25 -5 -45 -14z" /></svg>`; break;
          case 'json': icon = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" viewBox="-10 0 1010 1000"><path fill="#cbcb41" d="M234 472q32 0 45 -15q9 -11 9 -32q0 -9 -2 -26.5t-2 -27t-1 -28.5q-2 -17 -2 -24q0 -48 28 -71t79 -23h25v59h-13q-22 0 -31.5 12.5t-9.5 37.5q0 6 2 18q2 15 2 23q0 6 1 19q2 18 2 28q0 38 -16 57q-14 17 -44 24q30 8 44 24q16 20 16 57q0 11 -2 29q-2 13 -1.5 19 t-1.5 21q-2 11 -2 16q0 25 9.5 37.5t31.5 12.5h13v59h-25q-104 0 -104 -94q0 -34 3.5 -52.5t3.5 -53.5q0 -47 -53 -47zM766 525q-53 0 -53 47q0 9 1.5 26.5t1.5 26.5q3 19 3 53q0 94 -106 94h-25v-53h12q22 0 31.5 -12.5t9.5 -37.5t-3 -38q0 -8 -2 -23.5t-2 -23.5 q0 -37 16 -57q14 -16 44 -24q-30 -7 -44 -24q-16 -19 -16 -57q0 -10 2 -28q2 -13 2 -19q3 -16 3 -40t-10 -36t-31 -15h-12v-59h25q50 0 78 23t28 71q0 9 -1.5 26.5t-1.5 26.5q-3 19 -4 53q1 21 9 32q13 15 45 15v53z" /></svg>`; break;
          case 'png':
          case 'jpg':
          case 'jpeg': 
          case 'gif':
          case 'webp': icon = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" viewBox="-10 0 1010 1000"><path fill="#4fc3f7" d="M666 537q23 0 39.5 -16t16.5 -39.5t-16.5 -40t-40 -16.5t-40 16.5t-16.5 40t16.5 39.5t40.5 16zM319 366v387h478v-387h-478zM341 387h434v338l-112 -128l-69 81l-138 -147l-115 144v-288zM647 247h-444v337h60v-284h384v-53z" /></svg>`; break;
          case 'svg':  icon = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" viewBox="-10 0 1010 1000"><path fill="#ff9900" d="M359 356h172q0 -31 -22 -67.5t-57 -59.5q-39 -26 -81 -26t-80.5 22.5t-61.5 60t-23 79.5t26 82q23 35 59.5 58t67.5 23v-172zM425 428h369v369h-369v-369z" /></svg>`; break;
          case 'ico':  icon = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" viewBox="-10 0 1010 1000"><path fill="#cbcb41" d="M500 172l97 197l216 31l-157 150l38 216l-194 -100l-194 100l38 -216l-156 -150l215 -31z" /></svg>`; break;
          case 'pdf':  icon = ``; break;
          case 'php':  icon = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" viewBox="-10 0 1010 1000"><path fill="#4F5D95" d="M397 616q-5 -32 -31 -41l-22 -13q-19 -6 -25 -9q-9 -4 -19 6q-4 9 3 16q3 6 13 16q6 9 22 25l2 3q5 7 6 11q3 6 1 14q-5 36 -28 59q-2 2 -5 3h-1q-7 0 -15.5 -3.5t-13.5 -8.5q-6 -7 -5 -13.5t9 -11.5q2 0 4 -2t2 -5q10 -10 6 -21q-2 -2 -3.5 -5l-2.5 -5q-13 -12 -44 -37 q-58 -45 -62 -113q-5 -72 34 -140q17 -29 41 -41q12 -6 37 -13q63 -17 109 -9q53 11 66 53q10 36 6 63q-2 32 -24.5 58t-53.5 35q-14 5 -22 2.5t-15 -14.5l-5 -7q-12 -18 -17 -27v-4q0 -1 -1.5 -2.5t-1.5 -3.5q3 19 5 28q4 15 10 25q6 8 11.5 12t13.5 4q61 5 97 -41 q35 -48 25 -118q0 -8 -4 -20l-2 -5q0 -6 1 -8.5t5 -4.5q6 0 6 -3q54 -11 97 -6q62 5 103 34q72 45 97 134q3 10 3 25q0 5 -2 5.5t-6.5 -2t-10.5 -8.5l-2 -4q-2 -1 -5 -6t-5 -7t-4 -2t-2 2t-1.5 5t-1.5 5q-16 54 -44 81q-2 3 -4 6.5t-2 6.5l-1 12q-1 17 1 25l9 78 q2 11 -1.5 17t-14.5 11q-18 7 -31 7h-50q0 -19 -2 -27q-3 -14 -13 -20q6 -25 9.5 -41t-6.5 -31q-8 -12 -25 -6q-34 21 -78 6q-11 -3 -17.5 -1t-10.5 10q-10 19 -10 38t6 50q0 8 -1 10.5t-8 4.5q-30 9 -62 4h-4q0 -19 -2 -27q-5 -14 -19 -20q15 -16 9 -53zM269 544 q6 -7 6 -13q2 -7 -3 -16t-13 -12q-4 -2 -6.5 -1t-5.5 4q-5 5 -12.5 14.5t-12.5 13.5q0 2 -1.5 3.5t-1.5 3.5q-3 4 -1 8t7 4q9 0 13 3q18 0 31 -12zM269 441q0 -5 -4 -9t-9 -4t-9.5 4.5t-2.5 11.5q0 5 4.5 8.5t10.5 3.5q10 -9 10 -15z" /></svg>`; break;
          case 'zip':  icon = ``; break;
          case 'xml':  icon = ``; break;
          case 'md':   icon = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" viewBox="-10 0 1010 1000"><path fill="#519aba" d="M813 472q-5 -73 -50 -144q-33 -49 -79 -81.5t-103 -46.5q-33 -9 -62 -9h-50q-90 9 -166 65q-87 73 -109 175q-6 31 -6 50v50q10 87 53 147q55 81 137 113q57 20 103 25h50q114 -10 194 -94q65 -65 84 -156q2 -8 3.5 -22t3.5 -22v-34q-4 -7 -4 -16h1zM500 766 q-72 0 -133 -37q-60 -35 -94.5 -96t-34.5 -133t35.5 -133t96.5 -96q63 -37 136 -37q71 2 131.5 37.5t95.5 95.5q36 61 35 133t-37.5 133t-96.5 96q-62 37 -134 37zM575 669q-9 0 -16 -3q-4 0 -7 -6q-1 -3 -2 -4v-203q-25 2 -73.5 3.5t-73.5 2.5v25h31q9 0 14 6t5 16v144 q0 19 -19 19h-28v25h188v-25h-19zM494 416q23 0 38 -16t15 -37.5t-16 -37.5t-38 -16t-37 16t-15 37.5t16 37.5t37 16z" /></svg>`; break;
          case "htaccess": icon=`<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" viewBox="-10 0 1010 1000"><path fill="#6d8086" d="M766 541q-8 -2 -23 -8l-12 -5q0 -11 -1.5 -31t-1.5 -31q0 -2 1.5 -3.5t1.5 -3.5l35 -15q9 -5 12 -13.5t0 -17.5l-28 -63q-5 -10 -13.5 -13.5t-17.5 1.5l-35 15q-6 0 -6 -3q-4 -6 -15 -16l-7 -6q-3 -3 -10.5 -9.5t-11.5 -9.5q4 -6 8.5 -18.5t7.5 -18.5q5 -12 0.5 -21 t-16.5 -13q-13 -3 -43 -13l-16 -6q-12 -5 -21 -0.5t-13 15.5q-2 8 -8 23l-5 12q-11 0 -31 1.5t-31 1.5q-2 0 -3.5 -1.5t-3.5 -1.5l-15 -35q-5 -9 -13.5 -12t-17.5 0l-63 28q-10 5 -13.5 13.5t1.5 17.5l15 35q0 6 -3 6l-7 6q-7 5 -9 9q-4 5 -12 14.5t-13 14.5q-7 -2 -22 -8 l-12 -5q-12 -5 -21 -0.5t-13 16.5l-5 12q-12 30 -17 44t-1.5 22t16.5 12q8 2 23 8l12 5q0 11 1.5 31t1.5 31q0 2 -1.5 3.5t-1.5 3.5l-35 15q-9 5 -12 13.5t0 17.5l28 63q5 10 13.5 13.5t17.5 -1.5l35 -15q6 0 6 3q4 6 15 16l7 6q3 3 10.5 9t11.5 10q-3 6 -8 18.5t-8 18.5 q-5 12 -0.5 21t16.5 14q7 2 23 8q23 10 36.5 14t21.5 1t12 -17q2 -8 8 -23l5 -12q11 0 31 -1.5t31 -1.5q2 0 3.5 1.5t3.5 1.5l15 35q5 9 13.5 12t17.5 0l63 -28q10 -5 13.5 -13.5t-1.5 -17.5l-15 -34q0 -7 3 -7q6 -4 16 -15l6 -7q3 -3 9 -10.5t10 -10.5q7 1 22 8l12 4 q12 5 21 0.5t13 -16.5q3 -7 9 -23q10 -23 13 -36q11 -26 -15 -34zM547 606q-45 19 -88.5 2t-64.5 -61q-19 -45 -2 -88.5t61 -64.5q45 -19 88.5 -2t64.5 61q19 45 2 88.5t-61 64.5z" /></svg>`; break;
          default:     icon = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" viewBox="-10 0 1210 1000"><path fill="#d1dbe0" d="M394 538h412v54h-412v-54zM394 407h230v55h-230v-55zM394 277h412v55h-412v-55zM394 668h306v55h-306v-55z" /></svg>`; break;
        }

        li.innerHTML = `
          <span class="file-icon">${icon}</span>
          <span class="file-name">${fileName}</span>
        `;
        li.title = fileName;
        
        // Make file draggable
        li.draggable = true;
        
        li.addEventListener('dragstart', (e) => {
          e.stopPropagation();
          e.dataTransfer.setData('text/plain', filePath);
          e.dataTransfer.effectAllowed = 'move';
          li.style.opacity = '0.5';
        });
        
        li.addEventListener('dragend', (e) => {
          li.style.opacity = '';
        });
        
        // Add drag and drop support for dropping ONTO a file
        li.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.stopPropagation();
          li.style.background = 'var(--item-hover)';
        });

        li.addEventListener('dragleave', (e) => {
          e.stopPropagation();
          li.style.background = '';
        });

        li.addEventListener('drop', (e) => {
          e.preventDefault();
          e.stopPropagation();
          li.style.background = '';

          const parentPath = filePath.substring(0, filePath.lastIndexOf('/') + 1);

          const internalPath = e.dataTransfer.getData('text/plain');
          if (internalPath && internalPath !== filePath) {
            this.handleInternalMove(internalPath, parentPath);
          } else if (!internalPath) {
            this.handleFileDrop(e, parentPath);
          }
        });
        
        li.addEventListener('click', () => {
          // Set as selected and open file
          document.querySelectorAll('.folder-header').forEach(h => h.classList.remove('selected'));
          document.querySelectorAll('.file-item').forEach(f => f.classList.remove('selected'));
          li.classList.add('selected');
          this.openFile(filePath);
        });

        // Context menu for file
        li.addEventListener('contextmenu', (e) => {
          this.showContextMenu(e, li, 'file');
        });
        
        // Store full path for highlighting
        li.dataset.fullPath = filePath;
        
        container.appendChild(li);
      });
    }
  }

  previewImage(fileName) {
    const fileData = this.files.get(fileName);
    if (!fileData) return;
    
    const mimeType = this.getMimeType(fileName);
    const previewBody = document.getElementById('previewBody');
    
    previewBody.style.display = 'flex';
    previewBody.style.alignItems = 'center';
    previewBody.style.justifyContent = 'center';
    previewBody.style.background = '#1e1e1e';
    previewBody.innerHTML = '';
    
    const img = document.createElement('img');
    const blob = new Blob([fileData], { type: mimeType });
    img.src = URL.createObjectURL(blob);
    img.style.maxWidth = '100%';
    img.style.maxHeight = '100%';
    img.style.objectFit = 'contain';
    
    previewBody.appendChild(img);
    this.updateStatusBar(fileName);
  }

  openFile(fileName, line = null) {
    const mimeType = this.getMimeType(fileName);
    if (mimeType.startsWith('image/')) {
      this.previewImage(fileName);
      // Update selection in file tree
      document.querySelectorAll('.folder-header').forEach(h => h.classList.remove('selected'));
      document.querySelectorAll('.file-item').forEach(item => {
        const isActive = item.dataset.fullPath === fileName;
        item.classList.toggle('active', isActive);
        item.classList.toggle('selected', isActive);
      });
      return;
    }

    // Check if already open
    if (!this.openTabs.includes(fileName)) {
      this.openTabs.push(fileName);
      this.createTab(fileName);
    }
    
    this.switchToTab(fileName, line);
  }

  createTab(fileName) {
    const tabsContainer = document.getElementById('tabsContainer');
    const tab = document.createElement('div');
    tab.className = 'tab';
    tab.dataset.file = fileName;
    tab.title = fileName; // Add tooltip showing full path
    tab.draggable = true; // Make tab draggable
    
    const displayName = fileName.split('/').pop();
    tab.innerHTML = `
      <span class="tab-name">${displayName}</span>
      <span class="tab-dirty-indicator"></span>
      <span class="tab-close" onclick="event.stopPropagation(); virtualEditor.closeTab('${fileName}')">‚úï</span>
    `;
    
    // Tab drag and drop for reordering
    tab.addEventListener('dragstart', (e) => {
      e.stopPropagation();
      tab.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/tab-index', this.openTabs.indexOf(fileName).toString());
    });
    
    tab.addEventListener('dragend', (e) => {
      tab.classList.remove('dragging');
    });
    
    tab.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      
      const draggingTab = document.querySelector('.tab.dragging');
      if (draggingTab && draggingTab !== tab) {
        const rect = tab.getBoundingClientRect();
        const midpoint = rect.left + rect.width / 2;
        
        if (e.clientX < midpoint) {
          tab.parentNode.insertBefore(draggingTab, tab);
        } else {
          tab.parentNode.insertBefore(draggingTab, tab.nextSibling);
        }
      }
    });
    
    tab.addEventListener('drop', (e) => {
      e.preventDefault();
      const draggedIndex = parseInt(e.dataTransfer.getData('text/tab-index'));
      const targetIndex = Array.from(tabsContainer.children).indexOf(tab);
      
      if (draggedIndex !== targetIndex && draggedIndex >= 0) {
        // Reorder the openTabs array
        const draggedFile = this.openTabs[draggedIndex];
        this.openTabs.splice(draggedIndex, 1);
        
        // Find new position after removal
        const newTargetIndex = Array.from(tabsContainer.children).indexOf(tab);
        this.openTabs.splice(newTargetIndex, 0, draggedFile);
      }
    });
    
  tab.addEventListener('click', () => this.switchToTab(tab.dataset.file));
  tabsContainer.appendChild(tab);
    // Scroll to show the new tab
    setTimeout(() => {
      tab.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'end' });
    }, 0);
  }

  switchToTab(fileName, line = null) {
    // Update active tab
    document.querySelectorAll('.tab').forEach(tab => {
      tab.classList.toggle('active', tab.dataset.file === fileName);
    });

    // Update selected item in tree
    document.querySelectorAll('.folder-header').forEach(h => h.classList.remove('selected'));
    document.querySelectorAll('.file-item').forEach(item => {
      const isActive = item.dataset.fullPath === fileName;
      item.classList.toggle('active', isActive);
      item.classList.toggle('selected', isActive);
    });

    this.currentTab = fileName;
    this.displayFileContent(fileName);
    this.updateStatusBar(fileName);
    
    // Update virtual URL display
    const virtualUrlInput = document.getElementById('virtualUrl');
    const virtualQueryInput = document.getElementById('virtualQuery');
    
    const mime = this.getMimeType(fileName);
    const isPreviewable = mime === 'text/html' || mime === 'text/x-php' || mime === 'text/markdown';

    if (!this.isVirtualNavigation && isPreviewable) {
      if (virtualUrlInput) virtualUrlInput.value = '/' + fileName;
      if (virtualQueryInput) virtualQueryInput.value = '';
      this.currentVirtualUri = null;
      this.currentQueryString = null;
    }
    
    if (line !== null && this.editor) {
      this.editor.gotoLine(line, 0, true);
      this.editor.centerFocus();
    }
  }

  displayFileContent(fileName) {
    const fileData = this.files.get(fileName);
    if (!fileData) return;

    const mimeType = this.getMimeType(fileName);
    const editorContent = document.getElementById('editorContent');
    const previewBody = document.getElementById('previewBody');
    
    // Check if file should be edited or previewed
    if (this.isTextFile(mimeType)) {
      // Ensure editor container and instance exist
      let editorDiv = document.getElementById('editor');
      if (!editorDiv || !this.editor) {
        // Clean slate
        if (this.editor) {
          this.editor.destroy();
          this.editor = null;
        }
        editorContent.innerHTML = '';
        
        editorDiv = document.createElement('div');
        editorDiv.id = 'editor';
        editorDiv.style.width = '100%';
        editorDiv.style.height = '100%';
        editorContent.appendChild(editorDiv);
        
        // this.editor = new CustomEditor("editor");
        this.editor = ace.edit("editor");
        this.editor.setOptions({
          useSoftTabs: SOFT_TABS,
          tabSize: TAB_SIZE,
          enableBasicAutocompletion: true,
          enableLiveAutocompletion: true,
          enableMultiselect: true,
          enableSnippets: false,
          enableEmmet: true,
          behavioursEnabled: true,
          fontSize: "14px",
          showPrintMargin: false,
          highlightActiveLine: true,
          showGutter: true
        });
        this.editor.setKeyboardHandler("ace/keyboard/vscode");

        // Global editor listeners
        this.editor.on('changeSelection', () => {
          const cursor = this.editor.getCursorPosition();
          document.getElementById('cursorPosition').textContent = 
            `Ln ${cursor.row + 1}, Col ${cursor.column + 1}`;
        });
      }

      // Get or create session
      let session = this.sessions.get(fileName);
      if (!session) {
        const text = new TextDecoder().decode(fileData);
        const mode = this.getAceMode(mimeType, fileName);
        
        session = ace.createEditSession(text, mode);
        session.setUndoManager(new ace.UndoManager());
        session.setMode(mode);
        session.setUseSoftTabs(SOFT_TABS);
        session.setTabSize(TAB_SIZE);

        session.filePath = fileName;
        
        // Session-specific listeners
        session.on('change', () => {
          const currentPath = session.filePath;
          const currentMime = this.getMimeType(currentPath);
          // Mark as dirty
          this.dirtyFiles.add(currentPath);
          this.updateTabDirtyState(currentPath);
          
          // Auto-refresh preview for HTML and SVG
          if (currentMime === 'text/html' || currentMime === 'text/x-php') {
              clearTimeout(this.previewTimeout);
              this.previewTimeout = setTimeout(async () => {
                await this.refreshPreview();
              }, 500);
            } else if (currentMime === 'text/markdown') {
              clearTimeout(this.previewTimeout);
              this.previewTimeout = setTimeout(async () => {
                await this.refreshPreview();
              }, 500);
            } else if (currentMime === 'text/css') {
              if (this.currentPreviewFile) {
                clearTimeout(this.previewTimeout);
                this.previewTimeout = setTimeout(async () => {
                  await this.refreshPreview();
                }, 500);
              }
            } else if (currentPath.endsWith('.svg')) {
              clearTimeout(this.previewTimeout);
              this.previewTimeout = setTimeout(() => {
                // const text = this.editor.getValue();
                const text = session.getValue();
                previewBody.innerHTML = text;
              }, 500);
            }
        });
        
        this.sessions.set(fileName, session);
      }

      // Switch to session
      this.editor.setSession(session);
      this.editor.focus();
      
      // Update cursor immediately
      const cursor = this.editor.getCursorPosition();
      document.getElementById('cursorPosition').textContent = `Ln ${cursor.row + 1}, Col ${cursor.column + 1}`;

      // Initial preview
      if (mimeType === 'text/html' || mimeType === 'text/x-php' || mimeType === 'text/markdown') {
        this.currentPreviewFile = fileName;
        this.refreshPreview();
      } else if (fileName.endsWith('.svg')) {
        const text = session.getValue();
        previewBody.innerHTML = '';
        previewBody.style.display = 'flex';
        previewBody.style.alignItems = 'center';
        previewBody.style.justifyContent = 'center';
        previewBody.style.background = `#1e1e1e url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='20' height='20'><rect width='10' height='10' fill='%23aaa'/><rect x='10' y='10' width='10' height='10' fill='%23aaa'/><rect x='10' y='0' width='10' height='10' fill='%23777'/><rect x='0' y='10' width='10' height='10' fill='%23777'/></svg>")`;
        previewBody.innerHTML = text;
      } else if (mimeType === 'text/css') {
        if (!this.currentPreviewFile) {
           previewBody.innerHTML = '<div class="preview-empty">No preview available</div>';
        }
      } else {
        previewBody.innerHTML = '<div class="preview-empty">No preview available</div>';
      }

    } else if (mimeType.startsWith('image/')) {
      // Clean up existing editor if present
      if (this.editor) {
        this.editor.destroy();
        this.editor = null;
      }
      editorContent.innerHTML = '';
      const editorDiv = document.createElement('div');
      editorDiv.style.width = '100%';
      editorDiv.style.height = '100%';
      editorContent.appendChild(editorDiv);

      // Show image in preview
      editorDiv.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:var(--text-muted);">Image files are not editable</div>';
      const img = document.createElement('img');
      const blob = new Blob([fileData], { type: mimeType });
      img.src = URL.createObjectURL(blob);
      img.style.maxWidth = '100%';
      img.style.maxHeight = '100%';
      img.style.objectFit = 'contain';
      previewBody.style.display = 'flex';
      previewBody.style.alignItems = 'center';
      previewBody.style.justifyContent = 'center';
      previewBody.style.background = '#1e1e1e';
      previewBody.innerHTML = '';
      previewBody.appendChild(img);
    } else if (mimeType === 'application/pdf') {
      if (this.editor) {
        this.editor.destroy();
        this.editor = null;
      }
      editorContent.innerHTML = '';
      const editorDiv = document.createElement('div');
      editorDiv.style.width = '100%';
      editorDiv.style.height = '100%';
      editorContent.appendChild(editorDiv);

      // Show PDF in iframe
      editorDiv.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:var(--text-muted);">PDF files are not editable</div>';
      const iframe = document.createElement('iframe');
      iframe.style.width = '100%';
      iframe.style.height = '100%';
      iframe.style.border = 'none';
      const blob = new Blob([fileData], { type: mimeType });
      iframe.src = URL.createObjectURL(blob);
      previewBody.innerHTML = '';
      previewBody.appendChild(iframe);
    } else {
      if (this.editor) {
        this.editor.destroy();
        this.editor = null;
      }
      editorContent.innerHTML = '';
      const editorDiv = document.createElement('div');
      editorDiv.style.width = '100%';
      editorDiv.style.height = '100%';
      editorContent.appendChild(editorDiv);

      // Unknown file type - don't try to display or download
      editorDiv.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:var(--text-muted);">This file type cannot be edited or previewed</div>';
      previewBody.innerHTML = '<div class="preview-empty">No preview available for this file type</div>';
    }
  }

  async rewriteCSS(cssText, cssPath) {
    const normalize = (path) => {
      const parts = [];
      path.split("/").forEach(p => {
        if (!p || p === ".") return;
        if (p === "..") parts.pop();
        else parts.push(p);
      });
      return parts.join("/");
      let resolved = parts.join("/");
      if (p.endsWith('/') && resolved !== "") resolved += '/';
      return resolved;
    };

    const resolve = (ref) => {
      // Handle external URLs
      if (ref.startsWith("http://") || ref.startsWith("https://") || ref.startsWith("//")) {
        if (this.offline) {
          let url = ref
            .replace(/^(https?:)?\/\//, '_/')
            .replace(/[?:]/g, '_')
            ;
          return url;
        }
        return "__EXTERNAL__";
      }

      // Ignore data / blob
      if (ref.startsWith("data:") || ref.startsWith("blob:")) {
        return "__EXTERNAL__";
      }

      let cleanRef = ref;
      if (cleanRef.includes("?")) cleanRef = cleanRef.split('?')[0];
      if (cleanRef.includes("#")) cleanRef = cleanRef.split('#')[0];

      if (cleanRef.startsWith("/")) return normalize(cleanRef.slice(1));

      const base = cssPath.split("/").slice(0, -1).join("/");
      return normalize(base ? base + "/" + cleanRef : cleanRef);
    };

    // Better regex that handles quotes and unquoted URLs
    const urlRegex = /url\(\s*(['"]?)([^'")]+)\1\s*\)/gi;
    let out = cssText;

    const replacements = [];
    
    for (const match of cssText.matchAll(urlRegex)) {
      const full = match[0];
      const quote = match[1];
      const ref = match[2].trim();
      
      const resolved = resolve(ref);

      // External ‚Üí leave CSS untouched
      if (resolved === "__EXTERNAL__") continue;

      // Not resolvable ‚Üí skip
      if (!resolved) continue;

      const zipPath = resolved;

      if (!this.files.has(zipPath)) {
        replacements.push({
          from: full,
          to: `url("data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7")`
        });
        this.logNetworkRequest(zipPath.split('/').pop(), 404, 'image', 0, '5ms');
        continue;
      }

      try {
        const ext = zipPath.split(".").pop().toLowerCase();
        const mime =
          ext === "svg" ? "image/svg+xml" :
          ext === "png" ? "image/png" :
          ext === "jpg" || ext === "jpeg" ? "image/jpeg" :
          ext === "gif" ? "image/gif" :
          ext === "webp" ? "image/webp" :
          ext === "woff" ? "font/woff" :
          ext === "woff2" ? "font/woff2" :
          ext === "ttf" ? "font/ttf" :
          ext === "otf" ? "font/otf" :
          ext === "eot" ? "application/vnd.ms-fontobject" :
          "application/octet-stream";

        // Get file data
        const fileData = this.files.get(zipPath);
        const isFont = ['woff', 'woff2', 'ttf', 'otf', 'eot'].includes(ext);
        this.logNetworkRequest(zipPath.split('/').pop(), 200, isFont ? 'font' : 'image', fileData.byteLength, '5ms');

        // Convert to base64
        let data;
        if (ext === "svg") {
          // For SVG, convert to string first
          const text = new TextDecoder().decode(fileData);
          data = btoa(unescape(encodeURIComponent(text)));
        } else {
          // For binary files (fonts, images), convert to base64
          const bytes = new Uint8Array(fileData);
          let binary = '';
          const chunkSize = 0x8000; // 32KB chunks
          for (let i = 0; i < bytes.length; i += chunkSize) {
            binary += String.fromCharCode.apply(null, bytes.subarray(i, Math.min(i + chunkSize, bytes.length)));
          }
          data = btoa(binary);
        }

        replacements.push({
          from: full,
          to: `url("data:${mime};base64,${data}")`
        });
      } catch (err) {
        console.warn(`Failed to load CSS asset: ${zipPath}`, err);
      }
    }

    // Apply all replacements
    replacements.forEach(r => {
      out = out.split(r.from).join(r.to);
    });

    return out;
  }

  updateSNSPreview(doc, resolveFn) {
    const getMeta = (prop) => {
      const meta = doc.querySelector(`meta[property="${prop}"]`) || doc.querySelector(`meta[name="${prop}"]`);
      return meta ? meta.getAttribute('content') : null;
    };

    const title = getMeta('og:title') || getMeta('twitter:title') || doc.title || 'No Title';
    const desc = getMeta('og:description') || getMeta('twitter:description') || getMeta('description') || 'No Description';
    const image = getMeta('og:image') || getMeta('twitter:image');
    const url = getMeta('og:url') || getMeta('twitter:url') || 'example.com';

    const getDomain = (u) => {
      try {
        if (!u.startsWith('http')) u = 'http://' + u;
        return new URL(u).hostname.replace('www.', '');
      } catch (e) {
        return 'example.com';
      }
    };
    const domain = getDomain(url);

    let imageUrl = image;
    if (image && resolveFn) {
      const resolved = resolveFn(image);
      if (resolved && resolved !== "__EXTERNAL__") {
        const fileData = this.files.get(resolved);
        if (fileData) {
          const mime = this.getMimeType(resolved);
          imageUrl = this.createDataUrl(fileData, mime);
        }
      }
    }

    const updateCard = (prefix) => {
      const titleEl = document.getElementById(`${prefix}-title`);
      const descEl = document.getElementById(`${prefix}-desc`);
      const domainEl = document.getElementById(`${prefix}-domain`);
      const imgEl = document.getElementById(`${prefix}-img`);

      if (titleEl) titleEl.textContent = title;
      if (descEl) descEl.textContent = desc;
      if (domainEl) domainEl.textContent = prefix === 'fb' ? domain.toUpperCase() : domain;

      if (imageUrl && !imageUrl.startsWith('data:')) {
        let found = false;
        try {
          const u = imageUrl.startsWith('//') ? 'https:' + imageUrl : imageUrl;
          if (u.startsWith('http')) {
            const urlObj = new URL(u);
            let path = decodeURIComponent(urlObj.pathname);

            let fileData = this.files.get(path);
            if (!fileData && path.startsWith('/')) {
              fileData = this.files.get(path.substring(1));
              if (fileData) path = path.substring(1);
            }

            if (fileData) {
              const mime = this.getMimeType(path);
              imageUrl = this.createDataUrl(fileData, mime);
              found = true;
            }
          }
        } catch (e) {}
        if (this.offline && !found) imageUrl = "";
      }

      if (imgEl) {
        if (imageUrl) {
          imgEl.style.backgroundImage = `url('${imageUrl}')`;
          imgEl.classList.remove('empty');
        } else {
          imgEl.style.backgroundImage = '';
          imgEl.classList.add('empty');
        }
      }
    };

    updateCard('fb');
    updateCard('tw');
    updateCard('li');
  }

  async rewriteHtmlForIframe(html, currentFile, queryString = '') {
    const baseDir = currentFile.substring(0, currentFile.lastIndexOf('/') + 1);
    
    // Parse HTML
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');

    // Handle <base> tag for path resolution
    const docUrl = new URL(currentFile, 'file:///');
    const baseTag = doc.querySelector('base[href]');
    const assetBaseUrl = baseTag ? new URL(baseTag.getAttribute('href'), docUrl) : docUrl;
    
    // Unified normalize function
    const normalize = (p) => {
      const parts = [];
      p.split("/").forEach(seg => {
        if (!seg || seg === ".") return;
        if (seg === "..") parts.pop();
        else parts.push(seg);
      });
      let resolved = parts.join("/");
      // Preserve trailing slash to signify directory
      if (p.endsWith('/') && resolved !== "") resolved += '/';
      return resolved;
    };

    // const resolve = (ref) => {
    //   if (!ref) return null;

    //   // Handle external URLs
    //   if (ref.startsWith("http://") || ref.startsWith("https://") || ref.startsWith("//")) {
    //     if (this.offline) {
    //       //  let url = ref.split('?')[0].split('#')[0];
    //       // let url = ref.replace('?', '_');
    //       // return url.replace(/^(https?:)?\/\//, '_/');
    //       return ref
    //         .replace('?', '_')
    //         .replace(/^(https?:)?\/\//, '_/')
    //         .replace(':', '_')
    //         ;
    //     }
    //     return "__EXTERNAL__";
    //   }

    //   if (ref.startsWith("data:") || ref.startsWith("blob:")) {
    //     return "__EXTERNAL__";
    //   }

    //   let cleanRef = ref;
    //   if (cleanRef.includes("?")) cleanRef = cleanRef.split('?')[0];
    //   if (cleanRef.includes("#")) cleanRef = cleanRef.split('#')[0];

    //   try {
    //     // Use URL constructor for robust path resolution
    //     // Use URL constructor for robust path resolution against the determined assetBaseUrl
    //     const resolvedUrl = new URL(cleanRef, assetBaseUrl);
    //     // Return path relative to zip root
    //     return normalize(resolvedUrl.pathname.substring(1));
    //   } catch (e) {
    //     console.warn("Could not resolve path:", ref, "with base:", assetBaseUrl.href);
    //     return null;
    //   }
    // };

    const resolve = (ref) => {
  if (!ref) return null;

  // Handle external URLs
  if (ref.startsWith("http://") || ref.startsWith("https://") || ref.startsWith("//")) {
    if (this.offline) {
      return ref
        .replace('?', '_')
        .replace(/^(https?:)?\/\//, '_/')
        .replace(':', '_');
    }
    return "__EXTERNAL__";
  }

  if (ref.startsWith("data:") || ref.startsWith("blob:")) {
    return "__EXTERNAL__";
  }

  let cleanRef = ref;
  if (cleanRef.includes("?")) cleanRef = cleanRef.split('?')[0];
  if (cleanRef.includes("#")) cleanRef = cleanRef.split('#')[0];

  try {
    // IMPORTANT: For CSS/images, ignore the base tag and resolve from the current file's location
    // This is because inlined CSS needs to resolve relative to where it was defined
    const currentFileUrl = new URL(currentFile, 'file:///');
    const resolvedUrl = new URL(cleanRef, currentFileUrl);
    return normalize(resolvedUrl.pathname.substring(1));
  } catch (e) {
    console.warn("Could not resolve path:", ref, "with current file:", currentFile);
    return null;
  }
};

    this.updateSNSPreview(doc, resolve);

    // Inject environment and dynamic asset resolver
    const dynamicScript = doc.createElement("script");
    dynamicScript.setAttribute('data-devtools-ignore', 'true');
    dynamicScript.textContent = `window.__ZIP_PATH__ = "${currentFile}";
      window.__OFFLINE__ = ${this.offline};

      // Attempt to set the URL for the iframe so location.search works
      const qs = "${queryString ? '?' + queryString.replace(/\\/g, '\\\\').replace(/"/g, '\\"') : ''}";
      try {
        window.history.replaceState(null, '', "/${currentFile}" + qs);
      } catch(e) { 
        // Ignore SecurityError which happens on file:// protocol with srcdoc
        if (e.name !== 'SecurityError') console.warn('Failed to set virtual URL', e);
        
        // Fallback: Patch URLSearchParams to support query strings when replaceState fails
        if (qs) {
          const OriginalURLSearchParams = window.URLSearchParams;
          window.URLSearchParams = class extends OriginalURLSearchParams {
            constructor(init) {
              if (init === window.location.search || init === "" || init === null || init === undefined) {
                super(qs);
              } else {
                super(init);
              }
            }
          };
        }
      }

      // Intercept Fetch for virtual file system
      const originalFetch = window.fetch;
      window.fetch = async (input, init) => {
        let url = input;
        if (input instanceof Request) url = input.url;
        
        if (typeof url === 'string' && (url.startsWith('.') || url.startsWith('/') || !url.match(/^[a-z]+:/))) {
          const requestId = Math.random().toString(36).substr(2, 9);
          return new Promise((resolve) => {
            const handler = (e) => {
              if (e.data.type === 'ZIP_FILE_RESPONSE' && e.data.requestId === requestId) {
                window.removeEventListener('message', handler);
                if (e.data.error) {
                  resolve(new Response(null, { status: 404, statusText: 'Not Found' }));
                } else {
                  resolve(originalFetch(e.data.dataUrl));
                }
              }
            };
            window.addEventListener('message', handler);
            parent.postMessage({
              type: 'FETCH_ZIP_FILE',
              path: url,
              base: window.__ZIP_PATH__,
              requestId: requestId
            }, '*');
          });
        }
        return originalFetch(input, init);
      };

      // Console Interception
      const originalLog = console.log;
      const originalWarn = console.warn;
      const originalError = console.error;
      const originalInfo = console.info;

      function sendLog(type, args) {
        const safeArgs = args.map(arg => {
          try {
            if (typeof arg === 'object' && arg !== null) return JSON.stringify(arg);
            return String(arg);
          } catch(e) {
            return String(arg);
          }
        });
        parent.postMessage({ type: 'CONSOLE_LOG', logType: type, args: safeArgs }, '*');
      }

      console.log = (...args) => { originalLog.apply(console, args); sendLog('log', args); };
      console.warn = (...args) => { originalWarn.apply(console, args); sendLog('warn', args); };
      console.error = (...args) => { originalError.apply(console, args); sendLog('error', args); };
      console.info = (...args) => { originalInfo.apply(console, args); sendLog('info', args); };

      // Forward keyboard shortcuts to parent
      document.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'r') {
          e.preventDefault();
          parent.postMessage({ type: 'REFRESH_PREVIEW' }, '*');
        }
      });

      // Track clicks for double-click detection
      let lastClickTime = 0;
      let lastClickedLink = null;

      document.addEventListener("click", e => {
        if (window.__inspectorActive) return;

        const a = e.target.closest("a"); 
        if (!a) return;

        let href = a.getAttribute("href");

        if (href && href.startsWith("#")) {
          e.preventDefault();
          const targetId = href.substring(1);
          if (!targetId) {
            window.scrollTo(0, 0);
          } else {
            const targetEl = document.getElementById(targetId) || document.getElementsByName(targetId)[0];
            if (targetEl) targetEl.scrollIntoView();
          }
          try { history.pushState(null, null, href); } catch(e) {}
          return;
        }

        if (!href || href.startsWith("data:") || href.startsWith("http") || href.startsWith("//") || href.startsWith("javascript:")) {
          return;
        }

        // Handle <base> tag resolution manually since we intercept the click
        const base = document.querySelector('base[href]');
        if (base) {
          try {
            // Simulate resolution relative to the zip root using a fake origin
            const root = 'http://zip/';
            const currentPath = root + window.__ZIP_PATH__;
            const baseUrl = new URL(base.getAttribute('href'), currentPath);
            const resolvedUrl = new URL(href, baseUrl);
            // Extract the path part relative to our fake root
            href = resolvedUrl.href.substring(root.length);
          } catch (err) {
            console.warn('Failed to resolve link with base:', err);
          }
        }

        e.preventDefault();

        const isCtrlClick = e.ctrlKey || e.metaKey; // metaKey = Cmd on macOS

        if (isCtrlClick) {
          // CTRL/Cmd + click: open the source file in editor
          parent.postMessage({
            type: 'ZIP_OPEN_SOURCE',
            href: href,
            base: window.__ZIP_PATH__ || ""
          }, "*");
        } else {
          // Normal click: navigate
          parent.postMessage({
            type: 'ZIP_NAV',
            href: href,
            base: window.__ZIP_PATH__ || ""
          }, "*");
        }
      }, true);

      // Asset loader for dynamically added images
      async function requestAsset(el, attr) {
        const val = el.getAttribute(attr);
        if (!val || val.startsWith('data:') || val.startsWith('http')) return;
        const requestId = Math.random().toString(36).substr(2, 9);
        el.dataset.requestId = requestId;
        parent.postMessage({
          type: 'FETCH_ZIP_ASSET',
          path: val,
          base: window.__ZIP_PATH__,
          requestId: requestId
        }, "*");
      }

      const observer = new MutationObserver((mutations) => {
        mutations.forEach(m => {
          m.addedNodes.forEach(node => {
            if (node.nodeType === 1) {
              if (node.tagName === 'IMG' || node.tagName === 'SOURCE') requestAsset(node, 'src');
              node.querySelectorAll('img, source').forEach(a => requestAsset(a, 'src'));
            }
          });
        });
      });
      observer.observe(document.documentElement, { childList: true, subtree: true });

      window.addEventListener("message", e => {
        if (e.data.type === 'ZIP_ASSET_READY') {
          const el = document.querySelector('[data-request-id="' + e.data.requestId + '"]');
          if (el) el.src = e.data.dataUrl;
        }
      });
    `;
    doc.head.insertBefore(dynamicScript, doc.head.firstChild);

    /* ---- STATIC PROCESSING ---- */

    this.logNetworkRequest(currentFile.split('/').pop(), 200, 'document', html.length, '15ms');
    
    // Process Images
    for (const img of doc.querySelectorAll("img[src]")) {
      const src = img.getAttribute("src");
      const zipPath = resolve(src);
      if (zipPath === "__EXTERNAL__") continue;
      if (!zipPath) continue;
      
      try {
        const fileData = this.files.get(zipPath);
        if (!fileData) {
          img.setAttribute('data-missing-src', src);
          img.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
          this.logNetworkRequest(src.split('/').pop(), 404, 'image', 0, '10ms');
          continue;
        }
        
        const ext = zipPath.split(".").pop().toLowerCase();
        const mime = ext === 'svg' ? 'image/svg+xml' : `image/${ext}`;
        
        // Convert to base64
        let data;
        if (ext === "svg") {
          const text = new TextDecoder().decode(fileData);
          data = btoa(unescape(encodeURIComponent(text)));
        } else {
          const bytes = new Uint8Array(fileData);
          let binary = '';
          const chunkSize = 0x8000;
          for (let i = 0; i < bytes.length; i += chunkSize) {
            binary += String.fromCharCode.apply(null, bytes.subarray(i, Math.min(i + chunkSize, bytes.length)));
          }
          data = btoa(binary);
        }
        
        img.setAttribute('data-original-src', src);
        img.src = `data:${mime};base64,${data}`;
        this.logNetworkRequest(zipPath.split('/').pop(), 200, 'image', fileData.byteLength, '10ms');
      } catch (err) {
        console.warn(`Failed to load image: ${zipPath}`, err);
      }
    }

    // Process CSS
    for (const link of doc.querySelectorAll("link[rel=stylesheet]")) {
      let href = link.getAttribute("href");
      
      const cssPath = resolve(href);
      if (cssPath === "__EXTERNAL__") continue;
      if (!cssPath) { 
        console.warn('[CSS] Could not resolve path:', href);
        link.remove(); 
        continue; 
      }
      
      try {
        let cssData = this.files.get(cssPath);
        
        // Try to find the file with common filename sanitizations if exact match fails
        if (!cssData) {
          // 1. Try case-insensitive match
          const lowerCssPath = cssPath.toLowerCase();
          for (const [key, value] of this.files.entries()) {
            if (key.toLowerCase() === lowerCssPath) {
              cssData = value;
              break;
            }
          }
          
          // 2. Try appending .css
          if (!cssData && this.files.has(cssPath + '.css')) {
            cssData = this.files.get(cssPath + '.css');
          }
          
          // 3. If query string exists, try stripping it
          if (!cssData && cssPath.includes('?')) {
            const pathNoQuery = cssPath.split('?')[0];
            if (this.files.has(pathNoQuery)) {
              cssData = this.files.get(pathNoQuery);
            }
          }
        }

        if (!cssData) {
          link.remove();
          this.logNetworkRequest(cssPath.split('/').pop(), 404, 'stylesheet', 0, '10ms');
          continue;
        }
        
        const cssText = new TextDecoder().decode(cssData);
        const rewrittenCSS = await this.rewriteCSS(cssText, cssPath);
        
        const style = doc.createElement("style");
        style.textContent = rewrittenCSS;
        style.dataset.sourceFile = cssPath;
        style.dataset.originalHref = href;
        link.replaceWith(style);
        this.logNetworkRequest(cssPath.split('/').pop(), 200, 'stylesheet', cssData.byteLength, '10ms');
      } catch (err) {
        console.warn(`Failed to process CSS: ${cssPath}`, err);
        link.remove();
      }
    }

    // Process Scripts
    for (const s of doc.querySelectorAll("script[src]")) {
      const src = s.getAttribute("src");
      const jsPath = resolve(src);
      if (jsPath === "__EXTERNAL__") continue;
      if (!jsPath) { 
        s.remove(); 
        continue; 
      }
      
      try {
        const jsData = this.files.get(jsPath);
        if (!jsData) {
          this.logNetworkRequest(jsPath.split('/').pop(), 404, 'script', 0, '10ms');
          s.remove();
          continue;
        }
        
        const jsText = new TextDecoder().decode(jsData);
        const inline = doc.createElement("script");
        inline.textContent = jsText;
        inline.setAttribute('data-original-src', src);
        s.replaceWith(inline);
        this.logNetworkRequest(jsPath.split('/').pop(), 200, 'script', jsData.byteLength, '10ms');
      } catch (err) {
        console.warn(`Failed to process JS: ${jsPath}`, err);
        s.remove();
      }
    }

    // Re-execute inline scripts
    for (const oldScript of [...doc.querySelectorAll("script")]) {
      if (oldScript.src) continue;
      const s = doc.createElement("script");
      Array.from(oldScript.attributes).forEach(attr => {
        s.setAttribute(attr.name, attr.value);
      });
      s.textContent = oldScript.textContent;
      oldScript.replaceWith(s);
    }

    // Rewrite all inline <style> using rewriteCSS
    for (const style of doc.querySelectorAll("style")) {
      if (style.textContent) {
        style.textContent = await this.rewriteCSS(style.textContent, currentFile);
      }
    }

    return "<!DOCTYPE html>" + doc.documentElement.outerHTML;
  }

  async refreshPreview() {
    // console.clear();
    // console.warn("Preview Updated\n\n\n\n\n");
    this.clearConsole();
    this.clearNetwork();
    if (this.isInspecting) {
      this.toggleInspector();
    }
    if (!this.currentTab || !this.editor) return;
    
    const previewBody = document.getElementById('previewBody');
    if (!previewBody) return;

    // Determine effective file and content
    let effectiveFile = this.currentTab;
    let effectiveContent = this.editor.getValue();
    
    const currentMime = this.getMimeType(this.currentTab);
    const isCurrentPreviewable = currentMime === 'text/html' || currentMime === 'text/x-php' || currentMime === 'text/markdown';
    
    if (!isCurrentPreviewable) {
        if (this.currentPreviewFile) {
            effectiveFile = this.currentPreviewFile;
            // Fetch content
            if (this.sessions.has(effectiveFile)) {
                effectiveContent = this.sessions.get(effectiveFile).getValue();
            } else if (this.files.has(effectiveFile)) {
                effectiveContent = new TextDecoder().decode(this.files.get(effectiveFile));
            } else {
                return; 
            }
        } else {
            return; 
        }
    }

    // Capture scroll position
    let lastScrollX = 0;
    let lastScrollY = 0;
    const oldIframe = previewBody.querySelector('iframe');
    
    // Only restore scroll if we are editing the same file (not navigating)
    if (oldIframe && !this.isVirtualNavigation && oldIframe.dataset.filePath === effectiveFile && oldIframe.contentWindow) {
      try {
        lastScrollX = oldIframe.contentWindow.scrollX;
        lastScrollY = oldIframe.contentWindow.scrollY;
      } catch(e) {}
    }

    // Reset styles that might have been set by image preview
    previewBody.style.background = '#ffffff';
    previewBody.style.display = '';
    previewBody.style.alignItems = '';
    previewBody.style.justifyContent = '';

    // Update virtual URL display
    const virtualUrlInput = document.getElementById('virtualUrl');
    const virtualQueryInput = document.getElementById('virtualQuery');

    if (virtualUrlInput) {
      if (this.currentVirtualUri) {
        virtualUrlInput.value = this.currentVirtualUri;
      } else {
        virtualUrlInput.value = '/' + effectiveFile;
      }
    }
    if (virtualQueryInput) {
      virtualQueryInput.value = this.currentQueryString || '';
    }

    const isPhp = effectiveFile.toLowerCase().endsWith('.php');
    const isMd = effectiveFile.toLowerCase().endsWith('.md');
    
    // Clear and create new iframe
    previewBody.innerHTML = '';
    const iframe = document.createElement('iframe');
    iframe.dataset.filePath = effectiveFile;
    iframe.style.width = '100%';
    iframe.style.height = '100%';
    iframe.style.border = 'none';

    const html = effectiveContent;
    var rewrittenHtml = "";

    if (isPhp) {
      try {
        // transpile() returns a function string like "(function(__filesMap) { return ... })"
        // We need to evaluate it and call it with the files map to get the actual HTML output
        const uri = this.currentVirtualUri || ('/' + effectiveFile);
        const query = this.currentQueryString || '';
        const transpiledFunctionString = await this.phpTranspiler.transpile(html, effectiveFile, uri, query);
        
        // Evaluate the function string to get the actual function
        // Use Function constructor instead of eval for better error handling
        const transpiledFunction = new Function('return ' + transpiledFunctionString)();
        
        // Call the function with the files map to execute the PHP and get the output
        const phpGeneratedHtml = transpiledFunction(this.files);
        
        // Now rewrite the PHP-generated HTML to inline CSS and convert images to data URLs
        rewrittenHtml = await this.rewriteHtmlForIframe(phpGeneratedHtml, effectiveFile, query);
      } catch (error) {
        console.error('PHP transpile/execution error:', error);
        rewrittenHtml = `<html><body><pre style="color: red; padding: 20px; font-family: monospace;">PHP Error: ${error.message}\n\nStack:\n${error.stack}</pre></body></html>`;
      }
    } else if (isMd) {
        const mdCss = `
<style>
body {
  font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji";
  font-size: 16px;
  line-height: 1.5;
  word-wrap: break-word;
  color: #24292e;
  background-color: #fff;
  margin: 0;
  padding: 32px;
}
#result {
  max-width: 980px;
  margin: 0 auto;
}
h1, h2, h3, h4, h5, h6 {
  margin-top: 24px;
  margin-bottom: 16px;
  font-weight: 600;
  line-height: 1.25;
}
h1 { font-size: 2em; padding-bottom: 0.3em; border-bottom: 1px solid #eaecef; }
h2 { font-size: 1.5em; padding-bottom: 0.3em; border-bottom: 1px solid #eaecef; }
h3 { font-size: 1.25em; }
h4 { font-size: 1em; }
h5 { font-size: 0.875em; }
h6 { font-size: 0.85em; color: #6a737d; }
p { margin-top: 0; margin-bottom: 16px; }
blockquote, .quote {
  padding: 0 1em;
  color: #6a737d;
  border-left: 0.25em solid #dfe2e5;
  margin: 0 0 16px 0;
}
ul, ol { padding-left: 2em; margin-top: 0; margin-bottom: 16px; }
a { color: #0366d6; text-decoration: none; }
a:hover { text-decoration: underline; }
code, .code-inline {
  padding: 0.2em 0.4em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(27,31,35,0.05);
  border-radius: 3px;
  font-family: SFMono-Regular,Consolas,"Liberation Mono",Menlo,monospace;
  color: #24292e;
}
pre, .code-block {
  padding: 16px;
  overflow-x: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f6f8fa;
  border-radius: 3px;
  margin-top: 0;
  margin-bottom: 16px;
  font-family: SFMono-Regular,Consolas,"Liberation Mono",Menlo,monospace;
}
pre code, .code-block code {
  background-color: transparent;
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  border: 0;
  color: inherit;
}
hr {
  height: 0.25em;
  padding: 0;
  margin: 24px 0;
  background-color: #e1e4e8;
  border: 0;
}
img { max-width: 100%; box-sizing: content-box; background-color: #fff; }
table {
  border-spacing: 0;
  border-collapse: collapse;
  margin-top: 0;
  margin-bottom: 16px;
  width: 100%;
}
table th, table td {
  padding: 6px 13px;
  border: 1px solid #dfe2e5;
}
table tr {
  background-color: #fff;
  border-top: 1px solid #c6cbd1;
}
table tr:nth-child(2n) {
  background-color: #f6f8fa;
}
mark {
  background-color: #ffeb3b;
  padding: 0.2em;
}
ins {
  text-decoration: none;
  background-color: #e6ffed;
}
</style>`;
        rewrittenHtml = mdCss + '<div id="result">' + MarkdownRenderer.render(html) + '</div>';
    } else {
      rewrittenHtml = await this.rewriteHtmlForIframe(html, effectiveFile, this.currentQueryString);
    }
    
    // Don't use sandbox to allow external resources
    if (this.lastBlobUrl) {
      URL.revokeObjectURL(this.lastBlobUrl);
      this.lastBlobUrl = null;
    }
    
    previewBody.appendChild(iframe);
    
    const doc = iframe.contentDocument || iframe.contentWindow.document;
    doc.open();
    doc.write(rewrittenHtml);
    doc.close();

    iframe.onload = () => {
      this.updateElementsTree(iframe);
      if (lastScrollX || lastScrollY) {
        try {
          if (iframe.contentDocument && iframe.contentDocument.documentElement) {
            iframe.contentDocument.documentElement.style.scrollBehavior = 'auto';
          }
          iframe.contentWindow.scrollTo(lastScrollX, lastScrollY);
          if (iframe.contentDocument && iframe.contentDocument.documentElement) {
            iframe.contentDocument.documentElement.style.removeProperty('scroll-behavior');
          }
        } catch(e) {}
      }
    };
  }

  createDataUrl(data, mimeType) {
    let base64 = '';
    const bytes = new Uint8Array(data);
    const len = bytes.byteLength;
    
    for (let i = 0; i < len; i++) {
      base64 += String.fromCharCode(bytes[i]);
    }
    
    return `data:${mimeType};base64,${btoa(base64)}`;
  }

  resolvePath(base, relative) {
    if (relative.startsWith('/')) {
        return relative.substring(1);
    }
    const parts = base.split('/').filter(Boolean);
    const relativeParts = relative.split('/');
    
    for (const part of relativeParts) {
      if (part === '..') {
        parts.pop();
      } else if (part !== '.') {
        parts.push(part);
      }
    }
    
    return parts.join('/');
  }

  isTextFile(mimeType) {
    return mimeType.startsWith('text/') || 
      mimeType === 'application/javascript' ||
      mimeType === 'application/json' ||
      mimeType === 'application/xml';
  }

  getAceMode(mimeType, fileName) {
    // Filename-based overrides (configs)
    if (fileName === ".htaccess") {
      return "ace/mode/apache_conf";
    }

    if (
      fileName === "nginx.conf" ||
      fileName.endsWith(".nginx") ||
      fileName.endsWith(".nginx.conf")
    ) {
      return "ace/mode/nginx";
    }

    const modes = {
      'text/html': 'ace/mode/html',
      'text/css': 'ace/mode/css',
      'text/x-php': 'ace/mode/php',
      'application/javascript': 'ace/mode/javascript',
      'application/json': 'ace/mode/json',
      'application/xml': 'ace/mode/xml',
      'text/markdown': 'ace/mode/markdown',
      'text/plain': 'ace/mode/text'
    };
    return modes[mimeType] || 'ace/mode/text';
  }

  getMimeType(fileName) {
    // Special case: .htaccess has no extension
    if (fileName === ".htaccess") {
      return "text/plain";
    }

    const ext = fileName.split('.').pop().toLowerCase();
    const mimeTypes = {
      'html': 'text/html',
      'htm': 'text/html',
      'css': 'text/css',
      'php': 'text/x-php',
      'js': 'application/javascript',
      'json': 'application/json',
      'xml': 'application/xml',
      'txt': 'text/plain',
      'md': 'text/markdown',
      'svg': 'text/plain',
      'png': 'image/png',
      'jpg': 'image/jpeg',
      'jpeg': 'image/jpeg',
      'gif': 'image/gif',
      'webp': 'image/webp',
      'pdf': 'application/pdf',
      'htaccess': 'text/plain'
    };
    return mimeTypes[ext] || 'application/octet-stream';
  }

  updateStatusBar(fileName) {
    const mimeType = this.getMimeType(fileName);
    const ext = fileName.split('.').pop().toUpperCase();
    document.getElementById('fileType').textContent = ext;
  }

  createNewFile(targetPath = null) {
    const fileTree = document.getElementById('fileTree');
    
    // Remove any existing input
    const existingInput = document.querySelector('.temp-creation-input');
    if (existingInput) {
      existingInput.parentElement.remove();
      return;
    }
    
    // Determine where to insert the input
    let insertLocation = fileTree;
    let depth = 0;
    let pathPrefix = targetPath !== null ? targetPath : (this.selectedFolder || '');
    
    if (pathPrefix) {
      // Find the folder element
      const folderHeaders = document.querySelectorAll('.folder-header');
      for (const header of folderHeaders) {
        if (header.dataset.folderPath + '/' === pathPrefix) {
          const parentLi = header.parentElement;
          const childrenUl = parentLi.querySelector('.folder-children');
          
          // Expand folder if not expanded
          if (!childrenUl.classList.contains('expanded')) {
            header.click();
          }
          
          insertLocation = childrenUl;
          depth = (pathPrefix.split('/').length - 1);
          break;
        }
      }
    }
    
    // Create input element
    const inputLi = document.createElement('li');
    inputLi.style.paddingLeft = `${28 + depth * 16}px`;
    
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'new-item-input temp-creation-input';
    input.placeholder = 'filename.ext';
    
    inputLi.appendChild(input);
    insertLocation.insertBefore(inputLi, insertLocation.firstChild);
    
    // Focus the input
    input.focus();
    
    // Handle input confirmation
    const confirmCreate = () => {
      const fileName = input.value.trim();
      if (fileName) {
        const fullPath = pathPrefix + fileName;
        
        // Check if file already exists
        if (this.files.has(fullPath)) {
          this.showNotification(`File "${fileName}" already exists`, 'error');
        } else {
          // Create empty file
          const encoder = new TextEncoder();
          this.files.set(fullPath, encoder.encode(''));
          
          // Refresh tree and open file
          this.displayFileTree();
          this.openFile(fullPath);
          this.showNotification(`Created ${fileName}`, 'success');
        }
      }
      inputLi.remove();
    };
    
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        confirmCreate();
      } else if (e.key === 'Escape') {
        e.preventDefault();
        inputLi.remove();
      }
    });
  }

  createNewFolder(targetPath = null) {
    const fileTree = document.getElementById('fileTree');
    
    // Remove any existing input
    const existingInput = document.querySelector('.temp-creation-input');
    if (existingInput) {
      existingInput.parentElement.remove();
      return;
    }
    
    // Determine where to insert the input
    let insertLocation = fileTree;
    let depth = 0;
    let pathPrefix = targetPath !== null ? targetPath : (this.selectedFolder || '');
    
    if (pathPrefix) {
      // Find the folder element
      const folderHeaders = document.querySelectorAll('.folder-header');
      for (const header of folderHeaders) {
        if (header.dataset.folderPath + '/' === pathPrefix) {
          const parentLi = header.parentElement;
          const childrenUl = parentLi.querySelector('.folder-children');
          
          // Expand folder if not expanded
          if (!childrenUl.classList.contains('expanded')) {
            header.click();
          }
          
          insertLocation = childrenUl;
          depth = (pathPrefix.split('/').length - 1);
          break;
        }
      }
    }
    
    // Create input element
    const inputLi = document.createElement('li');
    inputLi.style.paddingLeft = `${28 + depth * 16}px`;
    
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'new-item-input temp-creation-input';
    input.placeholder = 'foldername';
    
    inputLi.appendChild(input);
    insertLocation.insertBefore(inputLi, insertLocation.firstChild);
    
    // Focus the input
    input.focus();
    
    // Handle input confirmation
    const confirmCreate = () => {
      let folderName = input.value.trim();
      if (!folderName) return;

      if (!folderName.endsWith('/')) {
        folderName += '/';
      }

      const fullPath = pathPrefix + folderName;

      if (this.folders.has(fullPath)) {
        this.showNotification(`Folder already exists`, 'error');
      } else {
        this.folders.add(fullPath);
        this.displayFileTree();
        this.showNotification(`Created folder ${folderName.replace('/', '')}`, 'success');
      }

      inputLi.remove();
    };
      
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          confirmCreate();
        } else if (e.key === 'Escape') {
          e.preventDefault();
          inputLi.remove();
        }
      });
    }

  closeTab(fileName) {
    const index = this.openTabs.indexOf(fileName);
    if (index > -1) {
      this.openTabs.splice(index, 1);
    }
    if (this.sessions.has(fileName)) {
      this.sessions.delete(fileName);
    }

    const tab = document.querySelector(`.tab[data-file="${fileName}"]`);
    if (tab) {
      tab.remove();
    }

    if (this.currentTab === fileName) {
      if (this.openTabs.length > 0) {
          this.switchToTab(this.openTabs[this.openTabs.length - 1]);
      } else {
        this.currentTab = null;
        document.getElementById('editorContent').innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">üìÑ</div>
            <div class="empty-state-text">No file open</div>
            <div class="empty-state-hint">Select a file from the explorer</div>
          </div>
        `;
      }
    }
  }

  closeCurrentTab() {
    if (this.currentTab) {
      this.closeTab(this.currentTab);
    }
  }

  async saveCurrentFile() {
    if (this.currentTab && this.editor) {
      // Save current editor content to files map
      const content = this.editor.getValue();
      const encoder = new TextEncoder();
      this.files.set(this.currentTab, encoder.encode(content));
      
      // Clear dirty state
      this.dirtyFiles.delete(this.currentTab);
      this.updateTabDirtyState(this.currentTab);
      
      // Also update preview if it's HTML
      const mimeType = this.getMimeType(this.currentTab);
      if (mimeType === 'text/html' || mimeType === 'text/x-php') {
        this.refreshPreview();
      }
    }
    
    // Save all changes back to ZIP
    await this.saveZip('STORE');
  }

  async saveZip(compression = 'STORE', saveAs = false) {
    try {
      // Save current editor content first
      if (this.currentTab && this.editor) {
        const content = this.editor.getValue();
        const encoder = new TextEncoder();
        this.files.set(this.currentTab, encoder.encode(content));
      }

      // Sync all open sessions to files map
      if (this.sessions.size > 0) {
        const encoder = new TextEncoder();
        this.sessions.forEach((session, path) => {
          const content = session.getValue();
          this.files.set(path, encoder.encode(content));
        });
      }
      
      // Import JSZip
      const JSZip = window.JSZip;
      
      // Create new ZIP
      const zip = new JSZip();
      
      // Add all files to ZIP
      this.files.forEach((data, path) => {
        zip.file(path, data);
      });
      
      // Add empty folders
      this.folders.forEach(folderPath => {
        zip.folder(folderPath.replace(/\/$/, ''));
      });
      
      // Generate ZIP blob
      const blob = await zip.generateAsync({ 
        type: 'blob',
        compression: compression,
        compressionOptions: { level: compression === 'DEFLATE' ? 6 : 0 }
      });
      
      // Try to use fileHandle to overwrite the file directly
      if (this.fileHandle && !saveAs) {
        try {
          const writable = await this.fileHandle.createWritable();
          await writable.write(blob);
          await writable.close();
          this.showNotification('ZIP file saved successfully', 'success');
          
          // Clear all dirty states
          this.dirtyFiles.clear();
          document.querySelectorAll('.tab.dirty').forEach(tab => tab.classList.remove('dirty'));
          
          return;
        } catch (err) {
          console.error('Failed to write with file handle:', err);
          // Fall through to download method
        }
      }
      
      // Fallback: Download the ZIP
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = this.zipFileName || 'project.zip';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      this.showNotification('ZIP file downloaded', 'success');
      
      // Clear all dirty states
      this.dirtyFiles.clear();
      document.querySelectorAll('.tab.dirty').forEach(tab => tab.classList.remove('dirty'));
      
    } catch (error) {
      console.error('Error saving ZIP:', error);
      this.showNotification('Error saving ZIP file', 'error');
    }
  }

    updateTabDirtyState(fileName) {
      const tab = document.querySelector(`.tab[data-file="${fileName}"]`);
      if (tab) {
        if (this.dirtyFiles.has(fileName)) {
          tab.classList.add('dirty');
        } else {
          tab.classList.remove('dirty');
        }
      }
    }

  showContextMenu(e, target, type) {
    e.preventDefault();
    e.stopPropagation();
    
    this.closeContextMenu();
    this.contextMenuTarget = { element: target, type: type };
    
    const menu = document.createElement('div');
    menu.className = 'explorer-menu';
    menu.style.left = e.pageX + 'px';
    menu.style.top = e.pageY + 'px';
    
    if (type === 'file') {
      menu.innerHTML = `
          <div class="explorer-menu-item" onclick="virtualEditor.handleContextAction('new-file')">
            <span>
              <svg width="16px" height="16px" viewBox="0 0 32 32" enable-background="new 0 0 32 32" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve">
                <polygon fill="none" stroke="#ccc" stroke-width="2" stroke-miterlimit="10" points="25,28 7,28 7,4 19,4 25,10 "/>
                <polyline fill="none" stroke="#ccc" stroke-width="2" stroke-miterlimit="10" points="19,4 19,10 25,10 "/>
              </svg>  
            </span>
            <span>New File</span>
          </div>
          <div class="explorer-menu-item" onclick="virtualEditor.handleContextAction('new-folder')">
            <span>
              <svg fill="#ccc" width="16px" height="16px" viewBox="0 0 24 24" id="folder" xmlns="http://www.w3.org/2000/svg">
                <path id="primary" d="M21,8V19a1,1,0,0,1-1,1H4a1,1,0,0,1-1-1V5A1,1,0,0,1,4,4H9.59a1,1,0,0,1,.7.29l2.42,2.42a1,1,0,0,0,.7.29H20A1,1,0,0,1,21,8Z" style="fill: none; stroke: #ccc; stroke-linecap: round; stroke-linejoin: round; stroke-width: 2;"></path>
              </svg>  
            </span>
            <span>New Folder</span>
          </div>
          <div class="explorer-menu-separator"></div>
          <div class="explorer-menu-item" onclick="virtualEditor.handleContextAction('copy-filename')">
            <span>
              <svg fill="#ccc" width="16px" height="16px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/>
              </svg>
            </span>
            <span>Copy Filename</span>
          </div>
          <div class="explorer-menu-item" onclick="virtualEditor.handleContextAction('copy-path')">
            <span>
              <svg fill="#ccc" width="16px" height="16px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/>
              </svg>
            </span>
            <span>Copy Path</span>
          </div>
          <div class="explorer-menu-separator"></div>
          <div class="explorer-menu-item" onclick="virtualEditor.handleContextAction('rename-file')">
            <span>
              <svg fill="#ccc" width="16px" height="16px" viewBox="0 0 36 36" version="1.1"  preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                <path class="clr-i-outline clr-i-outline-path-1" d="M33.87,8.32,28,2.42a2.07,2.07,0,0,0-2.92,0L4.27,23.2l-1.9,8.2a2.06,2.06,0,0,0,2,2.5,2.14,2.14,0,0,0,.43,0L13.09,32,33.87,11.24A2.07,2.07,0,0,0,33.87,8.32ZM12.09,30.2,4.32,31.83l1.77-7.62L21.66,8.7l6,6ZM29,13.25l-6-6,3.48-3.46,5.9,6Z"></path>
                <rect x="0" y="0" width="36" height="36" fill-opacity="0"/>
              </svg>
            </span>
            <span>Rename</span>
          </div>
          <div class="explorer-menu-separator"></div>
          <div class="explorer-menu-item danger" onclick="virtualEditor.handleContextAction('delete-file')">
            <svg fill="#ccc" width="16px" height="16px" viewBox="0 0 36 36" version="1.1"  preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
              <path class="clr-i-outline clr-i-outline-path-1" d="M27.14,34H8.86A2.93,2.93,0,0,1,6,31V11.23H8V31a.93.93,0,0,0,.86,1H27.14A.93.93,0,0,0,28,31V11.23h2V31A2.93,2.93,0,0,1,27.14,34Z"></path><path class="clr-i-outline clr-i-outline-path-2" d="M30.78,9H5A1,1,0,0,1,5,7H30.78a1,1,0,0,1,0,2Z"></path><rect class="clr-i-outline clr-i-outline-path-3" x="21" y="13" width="2" height="15"></rect><rect class="clr-i-outline clr-i-outline-path-4" x="13" y="13" width="2" height="15"></rect><path class="clr-i-outline clr-i-outline-path-5" d="M23,5.86H21.1V4H14.9V5.86H13V4a2,2,0,0,1,1.9-2h6.2A2,2,0,0,1,23,4Z"></path>
              <rect x="0" y="0" width="36" height="36" fill-opacity="0"/>
            </svg>
            <span>Delete</span>
          </div>
      `;
    } else if (type === 'folder') {
      menu.innerHTML = `
        <div class="explorer-menu-item" onclick="virtualEditor.handleContextAction('new-file')">
          <span>
            <svg width="16px" height="16px" viewBox="0 0 32 32" enable-background="new 0 0 32 32" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve">
              <polygon fill="none" stroke="#ccc" stroke-width="2" stroke-miterlimit="10" points="25,28 7,28 7,4 19,4 25,10 "/>
              <polyline fill="none" stroke="#ccc" stroke-width="2" stroke-miterlimit="10" points="19,4 19,10 25,10 "/>
            </svg>  
          </span>
          <span>New File</span>
        </div>
        <div class="explorer-menu-item" onclick="virtualEditor.handleContextAction('new-folder')">
          <span>
            <svg fill="#ccc" width="16px" height="16px" viewBox="0 0 24 24" id="folder" xmlns="http://www.w3.org/2000/svg">
              <path id="primary" d="M21,8V19a1,1,0,0,1-1,1H4a1,1,0,0,1-1-1V5A1,1,0,0,1,4,4H9.59a1,1,0,0,1,.7.29l2.42,2.42a1,1,0,0,0,.7.29H20A1,1,0,0,1,21,8Z" style="fill: none; stroke: #ccc; stroke-linecap: round; stroke-linejoin: round; stroke-width: 2;"></path>
            </svg>  
          </span>
          <span>New Folder</span>
        </div>
        <div class="explorer-menu-separator"></div>
        <div class="explorer-menu-item" onclick="virtualEditor.handleContextAction('copy-filename')">
          <span>
            <svg fill="#ccc" width="16px" height="16px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/>
            </svg>
          </span>
          <span>Copy Folder Name</span>
        </div>
        <div class="explorer-menu-item" onclick="virtualEditor.handleContextAction('copy-path')">
          <span>
            <svg fill="#ccc" width="16px" height="16px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/>
            </svg>
          </span>
          <span>Copy Path</span>
        </div>
        <div class="explorer-menu-separator"></div>
        <div class="explorer-menu-item" onclick="virtualEditor.handleContextAction('rename-folder')">
          <span>
            <svg fill="#ccc" width="16px" height="16px" viewBox="0 0 36 36" version="1.1"  preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
              <path class="clr-i-outline clr-i-outline-path-1" d="M33.87,8.32,28,2.42a2.07,2.07,0,0,0-2.92,0L4.27,23.2l-1.9,8.2a2.06,2.06,0,0,0,2,2.5,2.14,2.14,0,0,0,.43,0L13.09,32,33.87,11.24A2.07,2.07,0,0,0,33.87,8.32ZM12.09,30.2,4.32,31.83l1.77-7.62L21.66,8.7l6,6ZM29,13.25l-6-6,3.48-3.46,5.9,6Z"></path>
              <rect x="0" y="0" width="36" height="36" fill-opacity="0"/>
            </svg>
          </span>
          <span>Rename</span>
        </div>
        <div class="explorer-menu-item danger" onclick="virtualEditor.handleContextAction('delete-folder')">
          <span>
            <svg fill="#ccc" width="16px" height="16px" viewBox="0 0 36 36" version="1.1"  preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
              <path class="clr-i-outline clr-i-outline-path-1" d="M27.14,34H8.86A2.93,2.93,0,0,1,6,31V11.23H8V31a.93.93,0,0,0,.86,1H27.14A.93.93,0,0,0,28,31V11.23h2V31A2.93,2.93,0,0,1,27.14,34Z"></path><path class="clr-i-outline clr-i-outline-path-2" d="M30.78,9H5A1,1,0,0,1,5,7H30.78a1,1,0,0,1,0,2Z"></path><rect class="clr-i-outline clr-i-outline-path-3" x="21" y="13" width="2" height="15"></rect><rect class="clr-i-outline clr-i-outline-path-4" x="13" y="13" width="2" height="15"></rect><path class="clr-i-outline clr-i-outline-path-5" d="M23,5.86H21.1V4H14.9V5.86H13V4a2,2,0,0,1,1.9-2h6.2A2,2,0,0,1,23,4Z"></path>
              <rect x="0" y="0" width="36" height="36" fill-opacity="0"/>
            </svg>
          </span>
          <span>Delete Folder</span>
        </div>
      `;
    }
    
    document.body.appendChild(menu);
    
    // Prevent context menu from closing immediately
    menu.addEventListener('click', (e) => {
      e.stopPropagation();
    });
  }

  closeContextMenu() {
    const existingMenu = document.querySelector('.explorer-menu');
    if (existingMenu) {
      existingMenu.remove();
    }
  }

  handleContextAction(action) {
    this.closeContextMenu();
    
    if (!this.contextMenuTarget) return;
    
    const { element, type } = this.contextMenuTarget;
    
    if (action === 'rename-file') {
      const filePath = element.dataset.fullPath;
      this.renameFile(filePath);
    } else if (action === 'rename-folder') {
      const folderPath = element.dataset.folderPath;
      this.renameFolder(folderPath);
    } else if (action === 'copy-filename') {
      let name;
      if (type === 'file') {
        name = element.dataset.fullPath.split('/').pop();
      } else {
        name = element.dataset.folderPath.split('/').pop();
      }
      navigator.clipboard.writeText(name).then(() => {
        this.showNotification('Filename copied to clipboard', 'success');
      });
    } else if (action === 'copy-path') {
      let path;
      if (type === 'file') {
        path = element.dataset.fullPath;
      } else {
        path = element.dataset.folderPath;
      }
      navigator.clipboard.writeText(path).then(() => {
        this.showNotification('Path copied to clipboard', 'success');
      });
    } else if (action === 'delete-file') {
    const filePath = element.dataset.fullPath;
    if (confirm(`Are you sure you want to delete "${filePath.split('/').pop()}"?`)) {
        this.deleteFile(filePath);
    }
    } else if (action === 'delete-folder') {
      const folderPath = element.dataset.folderPath + '/';
      if (confirm(`Are you sure you want to delete folder "${folderPath}" and all its contents?`)) {
        this.deleteFolder(folderPath);
      }
    } else if (action === 'new-file') {
      let folderPath;
      if (type === 'folder') {
        folderPath = element.dataset.folderPath + '/';
      } else {
        const fullPath = element.dataset.fullPath;
        folderPath = fullPath.substring(0, fullPath.lastIndexOf('/') + 1);
      }
      this.createNewFile(folderPath);
    } else if (action === 'new-folder') {
      let folderPath;
      if (type === 'folder') {
        folderPath = element.dataset.folderPath + '/';
      } else {
        const fullPath = element.dataset.fullPath;
        folderPath = fullPath.substring(0, fullPath.lastIndexOf('/') + 1);
      }
      this.createNewFolder(folderPath);
    }
  }

  renameFile(oldPath) {
    const oldName = oldPath.split('/').pop();
    const dir = oldPath.substring(0, oldPath.lastIndexOf('/') + 1);
    
    // Find the file item in the tree
    const fileItem = document.querySelector(`.file-item[data-full-path="${oldPath}"]`);
    if (!fileItem) return;
    
    // Create input element
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'new-item-input';
    input.value = oldName;
    input.style.width = '100%';
    
    // Replace the file name with input
    const fileNameSpan = fileItem.querySelector('.file-name');
    const originalContent = fileItem.innerHTML;
    fileItem.innerHTML = '';
    fileItem.appendChild(input);
    
    // Select the filename without extension
    const dotIndex = oldName.lastIndexOf('.');
    if (dotIndex > 0) {
      input.setSelectionRange(0, dotIndex);
    } else {
      input.select();
    }
    input.focus();
    
    const confirmRename = () => {
      const newName = input.value.trim();
      
      if (!newName || newName === oldName) {
        fileItem.innerHTML = originalContent;
        return;
      }
      
      const newPath = dir + newName;
      
      // Check if new name already exists
      if (this.files.has(newPath)) {
        this.showNotification('A file with that name already exists', 'error');
        fileItem.innerHTML = originalContent;
        return;
      }
      
      // Get file data
      const fileData = this.files.get(oldPath);
      
      // Update files map
      this.files.delete(oldPath);
      this.files.set(newPath, fileData);
      
      // Update sessions
      if (this.sessions.has(oldPath)) {
        const session = this.sessions.get(oldPath);
        session.filePath = newPath;
        this.sessions.delete(oldPath);
        this.sessions.set(newPath, session);
        const newMime = this.getMimeType(newPath);
        session.setMode(this.getInternalMode(newMime));
      }

      // Update open tabs
      if (this.openTabs.includes(oldPath)) {
        const index = this.openTabs.indexOf(oldPath);
        this.openTabs[index] = newPath;
        
        // Update tab
        const tab = Array.from(document.querySelectorAll('.tab')).find(t => t.dataset.file === oldPath);
        if (tab) {
          tab.dataset.file = newPath;
          tab.querySelector('.tab-name').textContent = newName;
        }
        
        // Update current tab
        if (this.currentTab === oldPath) {
          this.currentTab = newPath;
        }
      }
      
      // Update dirty files
      if (this.dirtyFiles.has(oldPath)) {
        this.dirtyFiles.delete(oldPath);
        this.dirtyFiles.add(newPath);
      }
      
      this.displayFileTree();
      this.showNotification(`Renamed to ${newName}`, 'success');
    };
    
    const cancelRename = () => {
      fileItem.innerHTML = originalContent;
    };
    
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        confirmRename();
      } else if (e.key === 'Escape') {
        e.preventDefault();
        cancelRename();
      }
    });
    
    input.addEventListener('blur', () => {
      confirmRename();
    });
  }

  renameFolder(oldFolderPath) {
    const oldName = oldFolderPath.split('/').filter(Boolean).pop();
    
    // Find the folder header in the tree
    const folderHeader = document.querySelector(`.folder-header[data-folder-path="${oldFolderPath}"]`);
    if (!folderHeader) return;
    
    // Create input element
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'new-item-input';
    input.value = oldName;
    input.style.width = '100%';
    
    // Replace the folder name with input
    const folderNameSpan = folderHeader.querySelector('.folder-name');
    const originalContent = folderHeader.innerHTML;
    
    // Keep the chevron but replace the name
    const chevron = folderHeader.querySelector('.folder-icon');
    folderHeader.innerHTML = '';
    if (chevron) folderHeader.appendChild(chevron.cloneNode(true));
    folderHeader.appendChild(input);
    
    input.select();
    input.focus();
    
    const confirmRename = () => {
      const newName = input.value.trim();
      
      if (!newName || newName === oldName) {
        folderHeader.innerHTML = originalContent;
        return;
      }
      
      const parentPath = oldFolderPath.split('/').slice(0, -1).join('/');
      const newFolderPath = parentPath ? `${parentPath}/${newName}` : newName;
      
      const oldPrefix = oldFolderPath + '/';
      const newPrefix = newFolderPath + '/';
      
      // Check if new name already exists
      const exists = Array.from(this.files.keys()).some(f => f.startsWith(newPrefix));
      if (exists) {
        this.showNotification('A folder with that name already exists', 'error');
        folderHeader.innerHTML = originalContent;
        return;
      }
      
      // Update all files in the folder
      const filesToRename = Array.from(this.files.keys()).filter(f => f.startsWith(oldPrefix));
      
      filesToRename.forEach(oldFilePath => {
        const relativePath = oldFilePath.substring(oldPrefix.length);
        const newFilePath = newPrefix + relativePath;
        
        const fileData = this.files.get(oldFilePath);
        this.files.delete(oldFilePath);
        this.files.set(newFilePath, fileData);
        
        // Update sessions
        if (this.sessions.has(oldFilePath)) {
          const session = this.sessions.get(oldFilePath);
          session.filePath = newFilePath;
          this.sessions.delete(oldFilePath);
          this.sessions.set(newFilePath, session);
        }

        // Update tabs
        if (this.openTabs.includes(oldFilePath)) {
          const index = this.openTabs.indexOf(oldFilePath);
          this.openTabs[index] = newFilePath;
          
          const tab = Array.from(document.querySelectorAll('.tab')).find(t => t.dataset.file === oldFilePath);
          if (tab) {
            tab.dataset.file = newFilePath;
          }
          
          if (this.currentTab === oldFilePath) {
            this.currentTab = newFilePath;
          }
        }
        
        // Update dirty files
        if (this.dirtyFiles.has(oldFilePath)) {
          this.dirtyFiles.delete(oldFilePath);
          this.dirtyFiles.add(newFilePath);
        }
      });
      
      // Update folders set
      this.folders.delete(oldPrefix);
      this.folders.add(newPrefix);
      
      this.displayFileTree();
      this.showNotification(`Renamed folder to ${newName}`, 'success');
    };
    
    const cancelRename = () => {
      folderHeader.innerHTML = originalContent;
    };
    
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        confirmRename();
      } else if (e.key === 'Escape') {
        e.preventDefault();
        cancelRename();
      }
    });
    
    input.addEventListener('blur', () => {
      confirmRename();
    });
  }

  deleteFile(filePath) {
    // Remove from files
    this.files.delete(filePath);
    if (this.sessions.has(filePath)) {
      this.sessions.delete(filePath);
    }
    
    // Close tab if open
    if (this.openTabs.includes(filePath)) {
      this.closeTab(filePath);
    }
    
    // Remove from dirty files
    this.dirtyFiles.delete(filePath);
    
    // Refresh tree
    this.displayFileTree();
    this.showNotification(`Deleted ${filePath.split('/').pop()}`, 'success');
  }

  deleteFolder(folderPath) {
    // Find and delete all files in folder
    const filesToDelete = Array.from(this.files.keys()).filter(f => f.startsWith(folderPath));
    
    filesToDelete.forEach(file => {
      this.files.delete(file);
      if (this.sessions.has(file)) {
        this.sessions.delete(file);
      }
      if (this.openTabs.includes(file)) {
        this.closeTab(file);
      }
      this.dirtyFiles.delete(file);
    });
    
    // Remove folder from folders set
    this.folders.delete(folderPath);
    
    // Also remove any subfolders
    const foldersToDelete = Array.from(this.folders).filter(f => f.startsWith(folderPath));
    foldersToDelete.forEach(f => this.folders.delete(f));
    
    // Refresh tree
    this.displayFileTree();
    this.showNotification(`Deleted folder ${folderPath.replace('/', '')}`, 'success');
  }

  async handleFileDrop(e, targetPath) {
    e.preventDefault();
    e.stopPropagation();
    
    const items = e.dataTransfer.items;
    if (!items) return;
    
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      if (item.kind === 'file') {
        const file = item.getAsFile();
        if (file) {
          const fileName = file.name;
          const fullPath = targetPath + fileName;
          
          // Read file content
          const arrayBuffer = await file.arrayBuffer();
          const uint8Array = new Uint8Array(arrayBuffer);
          
          this.files.set(fullPath, uint8Array);
          this.showNotification(`Added ${fileName}`, 'success');
        }
      }
    }
    
    // Refresh tree
    this.displayFileTree();
  }

  handleInternalMove(sourcePath, targetPath) {
    // Check if source is a file or folder
    const isFolder = !this.files.has(sourcePath);
    
    if (isFolder) {
      // Moving a folder
      const sourceFolderPath = sourcePath.endsWith('/') ? sourcePath : sourcePath + '/';
      
      // Prevent moving folder into itself or its children
      if (targetPath.startsWith(sourceFolderPath)) {
        this.showNotification('Cannot move folder into itself', 'error');
        return;
      }
      
      const folderName = sourcePath.split('/').filter(Boolean).pop();
      const newFolderPath = targetPath + folderName + '/';
      
      // Check if target folder already exists
      const exists = Array.from(this.files.keys()).some(f => f.startsWith(newFolderPath));
      if (exists) {
        this.showNotification('A folder with that name already exists at destination', 'error');
        return;
      }
      
      // Move all files in the folder
      const filesToMove = Array.from(this.files.keys()).filter(f => f.startsWith(sourceFolderPath));
      
      filesToMove.forEach(oldFilePath => {
        const relativePath = oldFilePath.substring(sourceFolderPath.length);
        const newFilePath = newFolderPath + relativePath;
        
        const fileData = this.files.get(oldFilePath);
        this.files.delete(oldFilePath);
        this.files.set(newFilePath, fileData);
        
        // Update sessions
        if (this.sessions.has(oldFilePath)) {
          const session = this.sessions.get(oldFilePath);
          this.sessions.delete(oldFilePath);
          this.sessions.set(newFilePath, session);
        }

        // Update tabs
        if (this.openTabs.includes(oldFilePath)) {
          const index = this.openTabs.indexOf(oldFilePath);
          this.openTabs[index] = newFilePath;
          
          const tab = document.querySelector(`.tab[data-file="${oldFilePath}"]`);
          if (tab) {
            tab.dataset.file = newFilePath;
          }
          
          if (this.currentTab === oldFilePath) {
            this.currentTab = newFilePath;
          }
        }
        
        // Update dirty files
        if (this.dirtyFiles.has(oldFilePath)) {
          this.dirtyFiles.delete(oldFilePath);
          this.dirtyFiles.add(newFilePath);
        }
      });
      
      // Update folders set (including subfolders)
      const foldersToMove = Array.from(this.folders).filter(f => f.startsWith(sourceFolderPath));
      foldersToMove.forEach(oldSubFolderPath => {
        const relativePath = oldSubFolderPath.substring(sourceFolderPath.length);
        const newSubFolderPath = newFolderPath + relativePath;
        this.folders.delete(oldSubFolderPath);
        this.folders.add(newSubFolderPath);

        if (this.openFolders.has(oldSubFolderPath)) {
          this.openFolders.delete(oldSubFolderPath);
          this.openFolders.add(newSubFolderPath);
        }
      });
      
      this.showNotification(`Moved folder to ${targetPath || 'root'}`, 'success');
      
    } else {
      // Moving a file
      const fileName = sourcePath.split('/').pop();
      const newFilePath = targetPath + fileName;
      
      // Check if file already exists at destination
      if (this.files.has(newFilePath)) {
        this.showNotification('A file with that name already exists at destination', 'error');
        return;
      }
      
      // Move the file
      const fileData = this.files.get(sourcePath);
      this.files.delete(sourcePath);
      this.files.set(newFilePath, fileData);
      
      // Update sessions
      if (this.sessions.has(sourcePath)) {
        const session = this.sessions.get(sourcePath);
        this.sessions.delete(sourcePath);
        this.sessions.set(newFilePath, session);
        const newMime = this.getMimeType(newFilePath);
        session.setMode(this.getInternalMode(newMime));
      }

      // Update tabs
      if (this.openTabs.includes(sourcePath)) {
        const index = this.openTabs.indexOf(sourcePath);
        this.openTabs[index] = newFilePath;
        
        const tab = document.querySelector(`.tab[data-file="${sourcePath}"]`);
        if (tab) {
          tab.dataset.file = newFilePath;
          tab.querySelector('.tab-name').textContent = fileName;
        }
        
        if (this.currentTab === sourcePath) {
          this.currentTab = newFilePath;
        }
      }
      
      // Update dirty files
      if (this.dirtyFiles.has(sourcePath)) {
        this.dirtyFiles.delete(sourcePath);
        this.dirtyFiles.add(newFilePath);
      }
      
      this.showNotification(`Moved ${fileName} to ${targetPath || 'root'}`, 'success');
    }
    
    // Refresh tree
    this.displayFileTree();
  }

  markTabAsModified(fileName) {
    const tab = document.querySelector(`.tab[data-file="${fileName}"]`);
    if (tab && !tab.classList.contains('modified')) {
      tab.classList.add('modified');
    }
  }

  handleVirtualNavigation() {
    const urlInput = document.getElementById('virtualUrl');
    const queryInput = document.getElementById('virtualQuery');
    
    let path = urlInput.value.trim();
    let query = queryInput.value.trim();
    
    if (!path) return;
    if (!path.startsWith('/')) path = '/' + path;
    
    // Resolve file via .htaccess logic
    const resolvedFile = this.resolveHtaccess(path);
    
    if (resolvedFile) {
        // Set virtual state BEFORE opening file so switchToTab knows
        this.isVirtualNavigation = true;
        this.currentVirtualUri = path;
        this.currentQueryString = query;
        
        this.openFile(resolvedFile);
        
        this.isVirtualNavigation = false;
    } else {
        this.showNotification('404 Not Found: ' + path, 'error');
    }
  }

  resolveHtaccess(path) {
    let relativePath = path.startsWith('/') ? path.substring(1) : path;
    
    // 1. Check if file exists
    if (this.files.has(relativePath)) return relativePath;
    
    // 2. Check if directory (look for index)
    // User's htaccess: RewriteCond %{REQUEST_FILENAME} -f [OR] -d
    let isDirectory = false;
    let dirPath = relativePath;
    if (dirPath.endsWith('/')) dirPath = dirPath.slice(0, -1);
    
    if (this.folders.has(dirPath + '/') || dirPath === '') isDirectory = true;
    
    if (isDirectory) {
      const prefix = dirPath ? dirPath + '/' : '';
      if (this.files.has(prefix + 'index.php')) return prefix + 'index.php';
      if (this.files.has(prefix + 'index.html')) return prefix + 'index.html';
    }
    
    // 3. Check exclusions (admin, assets, layout)
    if (/^(admin|assets|layout)(\/|$)/.test(relativePath)) {
      return null;
    }
    
    // 4. FallbackResource
    if (this.files.has('.htaccess')) {
      const htaccess = new TextDecoder().decode(this.files.get('.htaccess'));
      const lines = htaccess.split('\n');
      for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed.startsWith('FallbackResource')) {
          const parts = trimmed.split(/\s+/);
          if (parts.length >= 2) {
            let fallback = parts[1];
            if (fallback.startsWith('/')) fallback = fallback.substring(1);
            if (this.files.has(fallback)) return fallback;
          }
        }
      }
    }
    
    return null;
  }

  // DevTools Methods
  switchDevToolsTab(tabName) {
    this.activeDevToolsTab = tabName;
    
    // Update tabs
    document.querySelectorAll('.devtools-tab').forEach(t => {
      t.classList.toggle('active', t.dataset.tab === tabName);
    });
    
    // Update content
    document.querySelectorAll('.devtools-tab-content').forEach(c => {
      c.classList.remove('active');
    });
    document.getElementById(`devtools${tabName.charAt(0).toUpperCase() + tabName.slice(1)}`).classList.add('active');
    
    // Show/Hide Input
    const inputContainer = document.getElementById('devtoolsInputContainer');
    inputContainer.style.display = tabName === 'console' ? 'flex' : 'none';
  }

  clearConsole() {
    const consoleEl = document.getElementById('devtoolsConsole');
    if (consoleEl) consoleEl.innerHTML = '';
  }

  clearNetwork() {
    const tbody = document.getElementById('networkTableBody');
    if (tbody) tbody.innerHTML = '';
  }

  logNetworkRequest(name, status, type, size, time) {
    const tbody = document.getElementById('networkTableBody');
    if (!tbody) return;
    
    const tr = document.createElement('tr');
    tr.dataset.type = type;
    if (status >= 400) tr.classList.add('network-error');
    const statusClass = (status >= 200 && status < 300) ? 'network-status-200' : 'network-status-404';
    
    let sizeStr = '-';
    if (size !== undefined && size !== null) {
        if (size < 1024) sizeStr = size + ' B';
        else if (size < 1024 * 1024) sizeStr = (size / 1024).toFixed(1) + ' KB';
        else sizeStr = (size / (1024 * 1024)).toFixed(1) + ' MB';
    }

    tr.innerHTML = `<td title="${name}">${name}</td><td class="${statusClass}">${status}</td><td>${type}</td><td>${sizeStr}</td><td>${time || '0ms'}</td>`;
    
    if (this.currentNetworkFilter && this.currentNetworkFilter !== 'all' && this.currentNetworkFilter !== type) {
        tr.style.display = 'none';
    }

    tbody.appendChild(tr);
    tbody.parentElement.parentElement.scrollTop = tbody.parentElement.parentElement.scrollHeight;
  }

  filterNetwork(category) {
    this.currentNetworkFilter = category;
    
    // Update active button state
    const toolbar = document.querySelector('.network-toolbar');
    if (toolbar) {
        Array.from(toolbar.children).forEach(btn => {
            const onclick = btn.getAttribute('onclick');
            btn.classList.toggle('active', onclick && onclick.includes(`'${category}'`));
        });
    }

    // Filter rows
    const rows = document.querySelectorAll('#networkTableBody tr');
    rows.forEach(row => {
        const match = category === 'all' || row.dataset.type === category;
        row.style.display = match ? '' : 'none';
    });
  }

  logToConsole(type, args) {
    const consoleEl = document.getElementById('devtoolsConsole');
    if (!consoleEl) return;
    
    const msgDiv = document.createElement('div');
    msgDiv.className = `console-msg ${type}`;
    msgDiv.textContent = args.join(' ');
    consoleEl.appendChild(msgDiv);
    consoleEl.scrollTop = consoleEl.scrollHeight;
  }

  handleConsoleInput(code) {
    const input = document.getElementById('devtoolsInput');
    input.value = '';
    
    this.logToConsole('log', [`> ${code}`]);
    
    const iframe = document.querySelector('#previewBody iframe');
    if (iframe && iframe.contentWindow) {
      try {
        const result = iframe.contentWindow.eval(code);
        this.logToConsole('log', [`< ${String(result)}`]);
      } catch (e) {
        this.logToConsole('error', [e.message]);
      }
    } else {
      this.logToConsole('error', ['No active preview context']);
    }
  }

  highlightElement(node) {
    if (!node || !node.ownerDocument) return;
    const doc = node.ownerDocument;
    const win = doc.defaultView;
    
    let overlay = doc.getElementById('__devtools-highlight__');
    if (!overlay) {
      overlay = doc.createElement('div');
      overlay.id = '__devtools-highlight__';
      overlay.style.position = 'fixed';
      overlay.style.zIndex = '2147483647';
      overlay.style.pointerEvents = 'none';
      if (doc.body) doc.body.appendChild(overlay);
      else if (doc.documentElement) doc.documentElement.appendChild(overlay);
    }
    
    // Reset overlay
    overlay.innerHTML = '';
    overlay.style.display = 'block';
    overlay.style.top = '0';
    overlay.style.left = '0';
    overlay.style.width = '0';
    overlay.style.height = '0';
    overlay.style.backgroundColor = 'transparent';
    overlay.style.border = 'none';

    if (node.nodeType === Node.TEXT_NODE) {
      const range = doc.createRange();
      range.selectNode(node);
      const rect = range.getBoundingClientRect();
      
      const contentBox = doc.createElement('div');
      contentBox.style.position = 'fixed';
      contentBox.style.top = rect.top + 'px';
      contentBox.style.left = rect.left + 'px';
      contentBox.style.width = rect.width + 'px';
      contentBox.style.height = rect.height + 'px';
      contentBox.style.backgroundColor = 'rgba(142, 213, 250, 0.65)'; // Content color
      overlay.appendChild(contentBox);
      return;
    }
    
    if (node.nodeType !== Node.ELEMENT_NODE) return;

    const computed = win.getComputedStyle(node);
    const rect = node.getBoundingClientRect();
    
    const getVal = (prop) => parseFloat(computed.getPropertyValue(prop)) || 0;
    
    const mt = getVal('margin-top');
    const mr = getVal('margin-right');
    const mb = getVal('margin-bottom');
    const ml = getVal('margin-left');
    
    const bt = getVal('border-top-width');
    const br = getVal('border-right-width');
    const bb = getVal('border-bottom-width');
    const bl = getVal('border-left-width');
    
    const pt = getVal('padding-top');
    const pr = getVal('padding-right');
    const pb = getVal('padding-bottom');
    const pl = getVal('padding-left');

    // Helper to create box using borders for colors (to avoid background blending)
    const createBox = (borderColor) => {
      const div = doc.createElement('div');
      div.style.boxSizing = 'border-box';
      div.style.width = '100%';
      div.style.height = '100%';
      div.style.borderStyle = 'solid';
      div.style.borderColor = borderColor;
      div.style.backgroundColor = 'transparent';
      return div;
    };

    // Margin Box (Base) - Fixed position relative to viewport
    const marginBox = doc.createElement('div');
    marginBox.style.position = 'fixed';
    marginBox.style.top = (rect.top - mt) + 'px';
    marginBox.style.left = (rect.left - ml) + 'px';
    marginBox.style.width = (rect.width + ml + mr) + 'px';
    marginBox.style.height = (rect.height + mt + mb) + 'px';
    marginBox.style.boxSizing = 'border-box';
    marginBox.style.borderStyle = 'solid';
    marginBox.style.borderColor = 'rgba(249, 204, 157, 1.0)';
    marginBox.style.borderWidth = `${mt}px ${mr}px ${mb}px ${ml}px`;
    
    // Border Box
    const borderBox = createBox('rgba(255, 238, 188, 1.0)');
    borderBox.style.borderWidth = `${bt}px ${br}px ${bb}px ${bl}px`;
    
    // Padding Box
    const paddingBox = createBox('rgba(195, 232, 180, 1.0)');
    paddingBox.style.borderWidth = `${pt}px ${pr}px ${pb}px ${pl}px`;
    
    // Content Box
    const contentBox = doc.createElement('div');
    contentBox.style.width = '100%';
    contentBox.style.height = '100%';
    contentBox.style.backgroundColor = 'rgba(142, 213, 250, 0.65)';
    
    paddingBox.appendChild(contentBox);
    borderBox.appendChild(paddingBox);
    marginBox.appendChild(borderBox);
    overlay.appendChild(marginBox);
  }

  removeHighlight() {
    const iframe = document.querySelector('#previewBody iframe');
    if (!iframe || !iframe.contentDocument) return;
    const overlay = iframe.contentDocument.getElementById('__devtools-highlight__');
    if (overlay) {
      overlay.style.display = 'none';
    }
  }

  toggleInspector() {
    this.isInspecting = !this.isInspecting;
    const btn = document.getElementById('inspectorBtn');
    if (btn) btn.classList.toggle('active', this.isInspecting);

    const iframe = document.querySelector('#previewBody iframe');
    if (!iframe || !iframe.contentDocument) return;
    
    const doc = iframe.contentDocument;
    
    if (this.isInspecting) {
      if (doc.defaultView) doc.defaultView.__inspectorActive = true;

      this._inspectorMoveHandler = (e) => {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        this.highlightElement(e.target);
      };
      
      this._inspectorClickHandler = (e) => {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        this.selectElementInTree(e.target);
        // Defer turning off the inspector to ensure the event is fully handled
        this.toggleInspector(); // Turn off
      };
      
      doc.addEventListener('mousemove', this._inspectorMoveHandler, true);
      doc.addEventListener('click', this._inspectorClickHandler, true);
      iframe.style.cursor = 'default';
    } else {
      if (doc.defaultView) doc.defaultView.__inspectorActive = false;

      if (this._inspectorMoveHandler) {
        doc.removeEventListener('mousemove', this._inspectorMoveHandler, true);
        doc.removeEventListener('click', this._inspectorClickHandler, true);
      }
      this.removeHighlight();
      iframe.style.cursor = '';
    }
  }

  selectElementInTree(node) {
    const treeContainer = document.getElementById('devtoolsElements');
    const allLines = treeContainer.querySelectorAll('.dom-line, .dom-node.dom-text');
    
    // Remove existing selection
    allLines.forEach(el => el.classList.remove('selected'));
    
    // Find and select new node
    for (const line of allLines) {
      if (line._domNode === node) {
        line.classList.add('selected');
        line.scrollIntoView({ behavior: 'auto', block: 'center' });
        // Ensure we are on the elements tab
        this.switchDevToolsTab('elements');
        this.updateStylesPanel(node);
        break;
      }
    }
  }

  updateStylesPanel(node) {
    const styleView = document.querySelector('.devtools-style-view');
    if (!styleView) return;
    
    // Initialize split view if not present
    let rulesPane = styleView.querySelector('.style-rules-pane');
    let computedPane = styleView.querySelector('.computed-pane');
    
    if (!rulesPane) {
      styleView.innerHTML = '';
      styleView.style.display = 'flex';
      styleView.style.flexDirection = 'row';
      styleView.style.padding = '0';
      styleView.style.overflow = 'hidden';
      
      rulesPane = document.createElement('div');
      rulesPane.className = 'style-rules-pane';
      
      const resizer = document.createElement('div');
      resizer.className = 'style-panes-resizer';
      
      computedPane = document.createElement('div');
      computedPane.className = 'computed-pane';

      styleView.appendChild(rulesPane);
      styleView.appendChild(resizer);
      styleView.appendChild(computedPane);
      
      // Resizer logic
      let isResizing = false;
      resizer.addEventListener('mousedown', (e) => {
        isResizing = true;
        document.body.style.cursor = 'col-resize';
        e.preventDefault();
      });

      document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        const rect = styleView.getBoundingClientRect();
        const computedWidth = rect.right - e.clientX;
        const percentage = (computedWidth / rect.width) * 100;
        
        if (percentage > 10 && percentage < 90) {
          computedPane.style.flex = `0 0 ${percentage}%`;
        }
      });

      document.addEventListener('mouseup', () => {
        if (isResizing) {
          isResizing = false;
          document.body.style.cursor = '';
        }
      });
    }

    this.currentSelectedNode = node;

    if (!node || node.nodeType !== Node.ELEMENT_NODE) {
      rulesPane.innerHTML = '<div style="color: #808080; padding: 8px; font-style: italic;">No element selected</div>';
      computedPane.innerHTML = '';
      return;
    }
    
    rulesPane.innerHTML = '';
    computedPane.innerHTML = '';
    
    this.renderStylesTab(node, rulesPane);
    this.renderComputedTab(node, computedPane);
  }

  renderStylesTab(node, container) {
    const doc = node.ownerDocument;
    const matchedRules = [];
    const usedProperties = new Set();
    
    const matches = (n, selector) => {
      try { return n.matches(selector); } catch (e) { return false; }
    };

    // 1. Inline style
    if (node.style && node.style.length > 0) {
      const section = document.createElement('div');
      section.className = 'style-section';
      section.innerHTML = `<div class="style-selector">element.style {</div>`;
      
      for (let i = 0; i < node.style.length; i++) {
        const prop = node.style[i];
        const val = node.style.getPropertyValue(prop);
        const priority = node.style.getPropertyPriority(prop);
        
        const line = document.createElement('div');
        line.style.paddingLeft = '14px';
        line.innerHTML = `<span class="style-property">${prop}</span>: <span class="style-value">${val}${priority ? ' !' + priority : ''}</span>;`;
        usedProperties.add(prop);
        section.appendChild(line);
      }
      section.innerHTML += `<div class="style-selector">}</div>`;
      container.appendChild(section);
    }

    // 2. Matched CSS Rules
    Array.from(doc.styleSheets).forEach(sheet => {
      try {
        const rules = sheet.cssRules || sheet.rules;
        const source = sheet.ownerNode.dataset.sourceFile;
        Array.from(rules).forEach(rule => {
          if (rule.type === 1) { // CSSStyleRule
            if (matches(node, rule.selectorText)) {
              matchedRules.push({rule, source});
            }
          } else if (rule.type === 4) { // CSSMediaRule
            if (doc.defaultView.matchMedia(rule.media.mediaText).matches) {
              Array.from(rule.cssRules).forEach(subRule => {
                  if (subRule.type === 1 && matches(node, subRule.selectorText)) {
                  matchedRules.push({rule: subRule, source});
                }
              });
            }
          }
        });
      } catch (e) {}
    });
    
    matchedRules.reverse().forEach(item => {
      const rule = item.rule;
      const source = item.source;

      const section = document.createElement('div');
      section.className = 'style-section';
      const selector = rule.selectorText.replace(/[\r\n]+/g, ' ');
      const sourceHtml = source ? `<span style="float:right; color:#808080; font-weight:normal; font-size: 10px; max-width: 100px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${source}">${source.split('/').pop()}</span>` : '';
      section.innerHTML = `<div class="style-selector">${selector} ${sourceHtml} {</div>`;
        
      const style = rule.style;
      for (let i = 0; i < style.length; i++) {
        const prop = style[i];
        const val = style.getPropertyValue(prop);
        const priority = style.getPropertyPriority(prop);
        
        const line = document.createElement('div');
        line.style.paddingLeft = '14px';
        
        const isOverwritten = usedProperties.has(prop);
        if (!isOverwritten) {
          usedProperties.add(prop);
        }
        
        const className = isOverwritten ? 'overwritten' : '';
        line.innerHTML = `<span class="style-property ${className}">${prop}</span>: <span class="style-value ${className}">${val}${priority ? ' !' + priority : ''}</span>;`;
        section.appendChild(line);
      }
      section.innerHTML += `<div class="style-selector">}</div>`;
      container.appendChild(section);
    });
    
    if (container.children.length === 0) {
        container.innerHTML = '<div style="color: #808080; padding: 4px;">No matching styles</div>';
    }
  }

  renderComputedTab(node, container) {
    const computed = node.ownerDocument.defaultView.getComputedStyle(node);
    
    const getTxt = (prop) => {
      const val = computed.getPropertyValue(prop);
      const num = parseFloat(val);
      return (isNaN(num) || num === 0) ? '-' : Number(num.toFixed(1));
    };

    // Box Model
    const boxContainer = document.createElement('div');
    boxContainer.className = 'box-model-container';
    boxContainer.innerHTML = `
      <div class="box-layer-dashed box-margin">
        <span class="box-label">margin</span>
        <div class="box-top">${getTxt('margin-top')}</div>
        <div class="box-middle">
          <div class="box-left">${getTxt('margin-left')}</div>
          <div class="box-layer-solid box-border">
            <span class="box-label">border</span>
            <div class="box-top">${getTxt('border-top-width')}</div>
            <div class="box-middle">
              <div class="box-left">${getTxt('border-left-width')}</div>
              <div class="box-layer-dashed box-padding">
                 <span class="box-label">padding</span>
                 <div class="box-top">${getTxt('padding-top')}</div>
                 <div class="box-middle">
                   <div class="box-left">${getTxt('padding-left')}</div>
                   <div class="box-layer-solid box-content">
                     <span>${getTxt('width')} x ${getTxt('height')}</span>
                   </div>
                   <div class="box-right">${getTxt('padding-right')}</div>
                 </div>
                 <div class="box-bottom">${getTxt('padding-bottom')}</div>
              </div>
              <div class="box-right">${getTxt('border-right-width')}</div>
            </div>
            <div class="box-bottom">${getTxt('border-bottom-width')}</div>
          </div>
          <div class="box-right">${getTxt('margin-right')}</div>
        </div>
        <div class="box-bottom">${getTxt('margin-bottom')}</div>
      </div>
    `;
    container.appendChild(boxContainer);

    // Computed Properties List
    const list = document.createElement('div');
    const props = [];
    for (let i = 0; i < computed.length; i++) {
      const prop = computed[i];
      const val = computed.getPropertyValue(prop);
      props.push({prop, val});
    }
    props.sort((a, b) => a.prop.localeCompare(b.prop));
    
    props.forEach(p => {
      const item = document.createElement('div');
      item.className = 'computed-property';
      item.innerHTML = `<span class="computed-name">${p.prop}</span><br><span class="computed-value">${p.val}</span>`;
      list.appendChild(item);
    });
    
    container.appendChild(list);
  }

  updateElementsTree(iframe) {
    const container = document.getElementById('devtoolsElements');
    if (!container || !iframe.contentDocument) return;
    
    // Initialize split view
    let treeView = container.querySelector('.devtools-tree-view');
    let styleView = container.querySelector('.devtools-style-view');
    
    if (!treeView) {
      container.innerHTML = '';
      
      treeView = document.createElement('div');
      treeView.className = 'devtools-tree-view';
      treeView.style.flex = '0 0 50%';
      
      const resizer = document.createElement('div');
      resizer.className = 'devtools-h-resizer';
      
      styleView = document.createElement('div');
      styleView.className = 'devtools-style-view';
      styleView.style.flex = '1';
      styleView.innerHTML = '<div style="color: #808080; padding: 8px; font-style: italic;">No element selected</div>';
      
      container.appendChild(treeView);
      container.appendChild(resizer);
      container.appendChild(styleView);
      
      // Resizer logic
      let isResizing = false;
      resizer.addEventListener('mousedown', (e) => {
        isResizing = true;
        document.body.style.cursor = 'col-resize';
        e.preventDefault();
      });
      
      document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        const rect = container.getBoundingClientRect();
        const x = e.clientX - rect.left;
        if (x > 50 && x < rect.width - 50) {
          const percent = (x / rect.width) * 100;
          treeView.style.flex = `0 0 ${percent}%`;
        }
      });
      
      document.addEventListener('mouseup', () => {
        if (isResizing) {
          isResizing = false;
          document.body.style.cursor = '';
        }
      });
    }

    const root = iframe.contentDocument.documentElement;
    treeView.innerHTML = '';
    
    const buildTree = (node, parentEl) => {
      if (node.nodeType === Node.ELEMENT_NODE && node.hasAttribute('data-devtools-ignore')) return;

      if (node.nodeType === Node.ELEMENT_NODE) {
        let tagName = node.tagName.toLowerCase();

        const attrs = Array.from(node.attributes).map(attr => ({
          name: attr.name,
          value: attr.value
        }));

        if (tagName === 'script' && node.hasAttribute('data-devtools-ignore')) {
          return;
        }
      }

      if (node.nodeType === Node.TEXT_NODE) {
        const text = node.textContent.trim();
        if (text) {
          const div = document.createElement('div');
          div.className = 'dom-node dom-text';
          div.textContent = text;
          div.style.paddingLeft = '16px';
          div._domNode = node;
          
          div.addEventListener('mouseover', (e) => {
            e.stopPropagation();
            this.highlightElement(node);
          });
          div.addEventListener('mouseout', (e) => {
            e.stopPropagation();
            this.removeHighlight();
          });
          div.addEventListener('click', (e) => {
            e.stopPropagation();
            if (e.ctrlKey || e.metaKey) {
              this.jumpToSource(node);
            } else {
              this.selectElementInTree(node);
            }
          });
          
          parentEl.appendChild(div);
        }
      } else if (node.nodeType === Node.ELEMENT_NODE) {
        const wrapper = document.createElement('div');
        wrapper.className = 'dom-node';
        
        const openLine = document.createElement('div');
        openLine.className = 'dom-line';
        openLine._domNode = node;
        
        let tagName = node.tagName.toLowerCase();
        let isConvertedStyle = false;
        if (tagName === 'style' && node.hasAttribute('data-original-href')) {
          isConvertedStyle = true;
          tagName = 'link';
        }

        let isConvertedScript = false;
        if (tagName === 'script' && node.hasAttribute('data-original-src')) {
          isConvertedScript = true;
        }

        const hasChildren = !isConvertedStyle && !isConvertedScript && node.childNodes.length > 0;
        let childrenContainer = null;

        if (hasChildren) {
          const arrow = document.createElement('span');
          arrow.className = 'dom-arrow expanded';
          arrow.innerHTML = '‚ñº';
          arrow.addEventListener('click', (e) => {
            e.stopPropagation();
            const isExpanded = arrow.classList.toggle('expanded');
            if (childrenContainer) childrenContainer.style.display = isExpanded ? 'block' : 'none';
          });
          openLine.appendChild(arrow);
        } else {
          const spacer = document.createElement('span');
          spacer.className = 'dom-spacer';
          openLine.appendChild(spacer);
        }

        let openHtml = `<span class="dom-tag">&lt;${tagName}</span>`;
        
        const attrList = Array.from(node.attributes).map(a => ({name: a.name, value: a.value}));
        
        const origSrc = node.getAttribute('data-original-src');
        if (origSrc) {
          const srcIdx = attrList.findIndex(a => a.name === 'src');
          if (srcIdx !== -1) attrList[srcIdx].value = origSrc;
          else attrList.push({name: 'src', value: origSrc});
        }
        
        const origHref = node.getAttribute('data-original-href');
        if (origHref) {
          const hrefIdx = attrList.findIndex(a => a.name === 'href');
          if (hrefIdx !== -1) attrList[hrefIdx].value = origHref;
          else attrList.push({name: 'href', value: origHref});
        }
        
        if (isConvertedStyle) {
            const relIdx = attrList.findIndex(a => a.name === 'rel');
            if (relIdx === -1) attrList.push({name: 'rel', value: 'stylesheet'});
        }
        
        attrList.filter(a => a.name !== 'data-original-src' && a.name !== 'data-original-href' && a.name !== 'data-source-file').forEach(attr => {
          openHtml += ` <span class="dom-attr-name">${attr.name}</span>=<span class="dom-attr-val">"${attr.value}"</span>`;
        });
        openHtml += `<span class="dom-tag">&gt;</span>`;
        
        const tagSpan = document.createElement('span');
        tagSpan.innerHTML = openHtml;
        openLine.appendChild(tagSpan);
        
        openLine.addEventListener('mouseover', (e) => {
          e.stopPropagation();
          this.highlightElement(node);
        });
        openLine.addEventListener('mouseout', (e) => {
          e.stopPropagation();
          this.removeHighlight();
        });
        openLine.addEventListener('click', (e) => {
          e.stopPropagation();
          if (e.ctrlKey || e.metaKey) {
            this.jumpToSource(node);
          } else {
            this.selectElementInTree(node);
          }
        });
        
        wrapper.appendChild(openLine);
        
        if (hasChildren) {
          childrenContainer = document.createElement('div');
          childrenContainer.className = 'dom-children expanded';
          Array.from(node.childNodes).forEach(child => buildTree(child, childrenContainer));
          wrapper.appendChild(childrenContainer);
          
          const closeLine = document.createElement('div');
          closeLine.className = 'dom-line';
          closeLine.style.paddingLeft = '16px';
          closeLine.innerHTML = `<span class="dom-tag">&lt;/${tagName}&gt;</span>`;
          
          closeLine.addEventListener('mouseover', (e) => {
            e.stopPropagation();
            this.highlightElement(node);
          });
          closeLine.addEventListener('mouseout', (e) => {
            e.stopPropagation();
            this.removeHighlight();
          });
          closeLine.addEventListener('click', (e) => {
            e.stopPropagation();
            if (e.ctrlKey || e.metaKey) {
              this.jumpToSource(node);
            } else {
              this.selectElementInTree(node);
            }
          });
          
          wrapper.appendChild(closeLine);
        } else {
           const voidElements = ['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'link', 'meta', 'param', 'source', 'track', 'wbr'];
           if (!voidElements.includes(tagName)) {
              tagSpan.innerHTML += `<span class="dom-tag">&lt;/${tagName}&gt;</span>`;
           }
        }
        
        parentEl.appendChild(wrapper);
      }
    };
    
    buildTree(root, treeView);
  }

  jumpToSource(node) {
    if (!this.editor) return;
    
    let searchTerm = '';
    let isRegex = false;

    if (node.nodeType === Node.ELEMENT_NODE) {
      const tagName = node.tagName.toLowerCase();
      
      // Strategy 1: ID
      if (node.id) {
        searchTerm = `id=["']${node.id}["']`;
        isRegex = true;
      } 
      // Strategy 2: Unique attributes (src, href)
      else if (node.hasAttribute('data-original-src')) {
        const src = node.getAttribute('data-original-src');
        const filename = src.split('/').pop();
        searchTerm = `src=["'].*${filename.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}["']`;
        isRegex = true;
      }
      else if (node.hasAttribute('data-original-href')) {
        const href = node.getAttribute('data-original-href');
        const filename = href.split('/').pop();
        searchTerm = `href=["'].*${filename.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}["']`;
        isRegex = true;
      }
      // Strategy 3: Classes
      else if (node.className && typeof node.className === 'string' && node.className.trim()) {
        const firstClass = node.className.trim().split(/\s+/)[0];
        searchTerm = `class=["'].*\\b${firstClass.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b.*["']`;
        isRegex = true;
      }
      // Strategy 4: Text Content (if short)
      else if (node.textContent && node.textContent.trim().length > 0 && node.textContent.trim().length < 50) {
        searchTerm = node.textContent.trim();
        isRegex = false;
      }
      // Strategy 5: Tag Name (fallback)
      else {
        searchTerm = `<${tagName}`;
        isRegex = false;
      }
    } else if (node.nodeType === Node.TEXT_NODE) {
        const text = node.textContent.trim();
        if (text) {
          searchTerm = text;
          isRegex = false;
        }
    }

    if (searchTerm) {
      this.editor.find(searchTerm, {
        regExp: isRegex,
        wrap: true,
        caseSensitive: false,
        wholeWord: false
      });
      this.editor.centerFocus();
    }
  }
}

// Initialize the editor
const virtualEditor = new VSCodeLikeEditor();

const toggle = ({ buttonId, bodyClass, updateLabel = false }) => {
  const isActive = document.body.classList.toggle(bodyClass);

  if (updateLabel) {
    const btn = document.getElementById(buttonId);
    btn.textContent = isActive ? '‚ùê Restore' : '‚õ∂ Expand';
  }
};

// Button clicks
document.getElementById('toggle-focus').onclick = () =>
  toggle({ buttonId: 'toggle-focus', bodyClass: 'preview-focus', updateLabel: true });

document.getElementById('toggle-snspreview').onclick = () =>
  toggle({ bodyClass: 'preview-sns' });

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.code !== 'Backquote') return;

  if (e.metaKey || e.ctrlKey) {
    e.preventDefault();
    toggle({ buttonId: 'toggle-focus', bodyClass: 'preview-focus', updateLabel: true });
  }

  if (e.altKey) {
    e.preventDefault();
    toggle({ bodyClass: 'preview-sns' });
  }
});


document.querySelectorAll('.tab-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    
    btn.classList.add('active');
    document.getElementById(`tab-${btn.dataset.tab}`).classList.add('active');
  });
});
</script>

<script>
// Menubar 
// ==================================================

const menuItems = document.querySelectorAll('.can-hover > li');
let focusedItem = null;

function closeMainMenu() {
  menuItems.forEach(item => {
    item.addEventListener('blur', () => {
      focusedItem = null;
    });

    item.blur();
  });
}

menuItems.forEach(item => {
  item.addEventListener('mouseover', () => {
    if (focusedItem) {
      focusedItem.blur();
      item.focus();
      focusedItem = item;
    }
  });

  item.addEventListener('focus', () => {
    focusedItem = item;
  });

  item.addEventListener('blur', () => {
    focusedItem = null;
  });

  item.addEventListener('mousedown', (event) => {
    // Check if the clicked element is an li inside a .can-hover > li
    const clickedLi = event.target.closest('.can-hover > li li');
    if (!clickedLi && item === focusedItem) {
      event.preventDefault();
      item.blur();
    }
  });
});

function OpenFile() {
  closeMainMenu();
  virtualEditor.triggerFileOpen();
}

function SaveStoredFile() {
  closeMainMenu();
  virtualEditor.saveZip('STORE');
}

function SaveCompressedFile() {
    closeMainMenu();
    virtualEditor.saveZip('DEFLATE', true);
}

function NewZIPSite() {
    closeMainMenu();
    virtualEditor.newProject();
}

function NewPHPZIPSite() {
    closeMainMenu();
    virtualEditor.newPHPProject();
}

let contextMenu = document.querySelector(".explorer-menu");

document.addEventListener('contextmenu', event => {
  event.preventDefault();
});


// Context Menu
// ==================================================

document.querySelector('main').addEventListener('contextmenu', e => {

  e.preventDefault();

  // Remove existing context menu
  if (contextMenu.style.display !== "none") {
    contextMenu.style.display = "none";
  }

  contextMenu.style.display = "block";

  // Set the position of the context menu
  const mouseX = e.clientX;
  const mouseY = e.clientY;
  const menuWidth = contextMenu.offsetWidth;
  const menuHeight = contextMenu.offsetHeight;
  const screenWidth = window.innerWidth;
  const screenHeight = window.innerHeight;
  const x = Math.min(mouseX, screenWidth - menuWidth);
  const y = Math.min(mouseY, screenHeight - menuHeight);
  contextMenu.style.top = `${y}px`;
  contextMenu.style.left = `${x}px`;

  // Left click on current location
  const evt = new MouseEvent('click', {
    bubbles: true,
    cancelable: true,
    clientX: x,
    clientY: y,
  });
  document.elementFromPoint(x, y).dispatchEvent(evt);
});

// Close context menu on click outside of it
document.addEventListener('click', e => {
  if (contextMenu !== null && !contextMenu.contains(e.target)) {
    contextMenu.style.display = "none";
  }
});

</script>
</body>
</html>
