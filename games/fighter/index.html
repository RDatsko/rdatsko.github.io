

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />
<link rel="stylesheet" href="../../assets/layout/css/cosmuic.css">
<link rel="stylesheet" href="../../assets/layout/css/styles.css">
<script src="../../assets/layout/layout.js"></script>
<script>
document.addEventListener('keydown', e => e.code === 'Backquote' && location.reload());
</script>
<title>FighterZ</title>

<style>
:root {
  --header-h: 64px;
  --game-width:  1920px;
  --game-height: 1080px;
}

html,body { margin: 0; height: 100%; background: #111; display: flex; justify-content: center; align-items: center; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, "Trebuchet MS", "Lucida Grande", sans-serif; font-size: 10px; }
body { --scale: min(calc(100vw / var(--game-width)), calc((100vh - var(--header-h)) / var(--game-height))); overflow: hidden; }
body > header ~ main { position: absolute; display: flex; padding: 0; height: calc(100vh - var(--header-h)); max-width: 100vw; top: var(--header-h); margin: 0 !important; }
.game-wrapper { width: calc(var(--game-width) * var(--scale)); height: calc(var(--game-height) * var(--scale)); position: relative; overflow: hidden; margin: auto; }
#game-screen { width: var(--game-width); height: var(--game-height); background: #242424; box-sizing: border-box; transform: scale(var(--scale)); transform-origin: top left; position: absolute; top: 0; left: 0; image-rendering: pixelated; image-rendering: -moz-crisp-edges; }
canvas { width: 100%; position: absolute; top: 0; left: 0; object-fit: contain; image-rendering: crisp-edges; image-rendering: pixelated; }
#start { position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; background-color: black; }
#start * { font-size: 36px; color: white; } 
#start svg { display: block; pointer-events: auto; }
#btnLinkFolder {  background: #4a90e2; color: white; border: none; padding: 20px 30px; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 24px; bottom: 50px; margin: auto; position: absolute; display: block; }
#btnLinkFolder, #folderStatus { position: absolute; left: 0; right: 0; width: fit-content; margin: auto; text-align: center; }
#folderStatus { bottom: 150px; }
#btnLinkFolder { bottom: 50px; }
#playButton { cursor: pointer; pointer-events: none; opacity: 0.4; transition: opacity 0.2s, transform 0.2s; background-color: transparent; }
#playButton.enabled { pointer-events: auto; opacity: 1; }
#playButton:hover { transform: scale(1.15); }
iframe { display: none; }
</style>

</head>
<body>

<header data-nav="right">
  <span>
    <input type="checkbox">
    <div style="font-size: 24px; font-weight: 700;">FighterZ</div>
    <nav>
      <ol>
        <li><a href="">HOME</a></li>
        <li><a href="./editor/editor.html">EDITOR</a></li>
        <li><a href="">ABOUT</a></li>
      </ol>
    </nav>
  </span>
</header>

<main>
  <div class="game-wrapper">
    <div id="game-screen">
      <canvas id="game"></canvas>
      <div id="start">
        <button id="playButton" >
          <svg width="350px" height="350px" x="0px" y="0px" viewBox="0 0 487.622 487.622" style="enable-background:new 0 0 487.622 487.622;" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve">
          <g>
            <circle style="fill:#535353;" cx="243.811" cy="243.811" r="243.811"/>
            <polygon style="fill:#b8b8b8;" points="375.699,243.811 169.686,368.19 169.686,119.431"/>
          </g>
          </svg>
        </button>
        <div id="folderStatus">No folder linked. Please select the game folder.</div><br>
        <button id="btnLinkFolder">ğŸ“ SELECT MAIN GAME FOLDER</button>
        <input type="file" id="firefoxFolderPicker" webkitdirectory multiple style="display:none"/>
      </div>
    </div>
  </div>
</main>

<script>

/* ================================
   Browser Capability Detection
================================ */

const supportsDirectoryPicker = "showDirectoryPicker" in window;
const isFirefox = navigator.userAgent.includes("Firefox");

/* ================================
   IndexedDB Setup
================================ */

const dbName = "FighterZ";
const storeName = "FighterZ";

let gameDirHandle = null;
let firefoxFiles = null;

const playButton = document.getElementById("playButton");
const folderStatus = document.getElementById("folderStatus");
const btnLinkFolder = document.getElementById("btnLinkFolder");

/* ================================
   IndexedDB Helpers
================================ */

async function openDB() {
  return new Promise(resolve => {
    const req = indexedDB.open(dbName, 1);

    req.onupgradeneeded = () => {
      req.result.createObjectStore(storeName);
    };

    req.onsuccess = () => resolve(req.result);
  });
}

async function saveHandle(handle) {
  if (!supportsDirectoryPicker) return;

  const db = await openDB();
  db.transaction(storeName, "readwrite")
    .objectStore(storeName)
    .put(handle, "root");
}

async function getHandle() {
  if (!supportsDirectoryPicker) return null;

  const db = await openDB();
  return new Promise(resolve => {
    const req = db.transaction(storeName)
      .objectStore(storeName)
      .get("root");

    req.onsuccess = () => resolve(req.result);
  });
}

/* ================================
   Folder Picker (Unified)
================================ */

async function pickGameFolder() {
  // Chrome / Edge
  if (supportsDirectoryPicker) {
    return await window.showDirectoryPicker();
  }

  // Firefox fallback
  return new Promise(resolve => {
    const input = document.getElementById("firefoxFolderPicker");
    input.value = ""; // allow re-pick
    input.onchange = () => resolve([...input.files]);
    input.click();
  });
}

/* ================================
   Permission Handling (Chrome only)
================================ */

async function verifyPermission(handle) {
  if (!supportsDirectoryPicker) return true;

  const options = { mode: "read" };

  if ((await handle.queryPermission(options)) === "granted") return true;
  if ((await handle.requestPermission(options)) === "granted") return true;

  return false;
}

/* ================================
   Unified File Access Helper
================================ */

async function getGameFile(path) {
  // Chrome / Edge (File System Access API)
  if (supportsDirectoryPicker && gameDirHandle) {
    try {
      const parts = path.split('/');
      let currentHandle = gameDirHandle;
      
      // Navigate through subdirectories
      for (let i = 0; i < parts.length - 1; i++) {
        currentHandle = await currentHandle.getDirectoryHandle(parts[i]);
      }
      
      // Get the final file handle
      const fileHandle = await currentHandle.getFileHandle(parts[parts.length - 1]);
      return await fileHandle.getFile();
    } catch (e) {
      console.warn(`File not found in FS: ${path}`, e);
      return null;
    }
  }

  // Firefox Fallback
  if (firefoxFiles) {
    const searchPath = path.toLowerCase();
    return firefoxFiles.find(f => f.webkitRelativePath.toLowerCase().endsWith(searchPath));
  }

  return null;
}

/* ================================
   Folder Button Click
================================ */

btnLinkFolder.addEventListener("click", async () => {
  try {
    const result = await pickGameFolder();
    if (!result) return;

    if (supportsDirectoryPicker) {
      gameDirHandle = result;
      await saveHandle(gameDirHandle);

      folderStatus.innerText =
        "âœ“ Folder Linked - PRESS PLAY BUTTON";
    } else {
      firefoxFiles = result;

      folderStatus.innerText =
        `âœ“ ${firefoxFiles.length} files loaded (Firefox mode)`;
    }

    playButton.classList.add("enabled");

  } catch (err) {
    console.error("Folder selection failed:", err);
  }
});

/* ================================
   Restore Folder on Load (Chrome)
================================ */

window.addEventListener("load", async () => {


  // If the button isn't enabled and we aren't on a website, stop.
  const isWebMode = window.location.protocol.startsWith('http');
  if (isWebMode) {
    try {
      // 1. Load the config (Fetch if on web, FileSystem if folder linked)
      const config = await Game.setupConfig();
      
      // 2. Create the ACTUAL game instance
      const game = new Game(config);
      
      // 3. Start the loop
      game.init();

      // 4. UI: Hide the overlay/menu
      document.getElementById('start').style.display = 'none';
      
    } catch (err) {
      console.error("Game failed to start:", err);
      return;
    }
  }

  if (!supportsDirectoryPicker) return;

  gameDirHandle = await getHandle();

  if (gameDirHandle) {
    folderStatus.innerText =
      "âœ“ Folder Found (re-verify if needed)";
    playButton.classList.add("enabled");
  }
});

/* ================================
   Play Button
================================ */

// playButton.addEventListener("click", async () => {
//   if (!playButton.classList.contains("enabled")) return;

//   if (supportsDirectoryPicker) {
//     const ok = await verifyPermission(gameDirHandle);
//     if (!ok) {
//       alert("Please re-link the folder to grant access.");
//       return;
//     }
//   }

//   document.getElementById("start").style.display = "none";

//   // Start your game here
//   new Game().start();
//   // const game = new Game();
//   // await game.start();
//   // await Game().start();

// // const config = await Game.setupConfig();
// // const game = new Game(config);
// // game.init();
// });











// playButton.addEventListener("click", async () => {
//   if (!playButton.classList.contains("enabled")) return;

//   if (supportsDirectoryPicker) {
//     const ok = await verifyPermission(gameDirHandle);
//     if (!ok) {
//       alert("Please re-link the folder to grant access.");
//       return;
//     }
//   }

//   document.getElementById("start").style.display = "none";

//   // LOAD CONFIG FIRST, THEN NEW GAME
//   const config = await Game.setupConfig();
//   const game = new Game(config); 
//   game.init(); // This starts the loop on the correct instance
// });

playButton.addEventListener("click", async () => {
  // If the button isn't enabled and we aren't on a website, stop.
  const isWebMode = window.location.protocol.startsWith('http');
  if (!playButton.classList.contains("enabled") && !isWebMode) return;

  try {
    // 1. Load the config (Fetch if on web, FileSystem if folder linked)
    const config = await Game.setupConfig();
    
    // 2. Create the ACTUAL game instance
    const game = new Game(config);
    
    // 3. Start the loop
    game.init();

    // 4. UI: Hide the overlay/menu
    document.getElementById('start').style.display = 'none';
    
  } catch (err) {
    console.error("Game failed to start:", err);
  }
});

</script>

<script>
(function () {
  if (!navigator.userAgent.includes("Firefox")) return;

  async function updateScale() {
    const headerHeight = 64;
    // Get the actual config values so we match the canvas resolution
    const config = await Game.setupConfig(); 
    
    const gameWidth = config.GameWidth;
    const gameHeight = config.GameHeight;

    const vw = window.innerWidth;
    const vh = window.innerHeight - headerHeight;

    const scaleX = vw / gameWidth;
    const scaleY = vh / gameHeight;
    const scale = Math.min(scaleX, scaleY);

    console.log(`--- Firefox Fix: Scaling to ${scale} ---`);

    // Update CSS Variable
    document.body.style.setProperty("--scale", scale);
    document.documentElement.style.setProperty("--game-width", gameWidth + "px");
    document.documentElement.style.setProperty("--game-height", gameHeight + "px");
    
    const screen = document.getElementById('game-screen');
    const wrapper = document.querySelector('.game-wrapper');

    if (screen) {
      screen.style.transform = `scale(${scale})`;
    }
    if (wrapper) {
      wrapper.style.width = (gameWidth * scale) + "px";
      wrapper.style.height = (gameHeight * scale) + "px";
    }
  }

  window.addEventListener("resize", updateScale);
  // Run after a slight delay to ensure the config/DOM is ready
  setTimeout(updateScale, 100);
})();
</script>



<script>

  /*
  ============================================================
  GLOBALS
  ============================================================
  */
  
  const ENABLE_DEBUG = true;
  
  const FPS = 60;
  const FRAME_TIME = 1000 / 60;
  
  let air = null;
  
  
  
  
  
  
  
  
  
  
  /*
  ============================================================
  CANVAS / CAMERA
  ============================================================
  */
  
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const camera = { ground: 200 };
  
  
  
  
  
  
  
  
  
  
  /*
  ============================================================
  INPUT
  ============================================================
  */
  
  const keys = {};
  addEventListener("keydown", e => keys[e.code] = true);
  addEventListener("keyup", e => keys[e.code] = false);
  
  
  
  
  
  
  
  
  
  
  /*
  ============================================================
  AIR ANIMATIONS
  ============================================================
  */
  
  class AIR { constructor(){ this.actions = new Map(); } }
  
  class AIRAnim {
  Â  constructor(action){ this.action = action; this.i=0; this.t=0; }
  Â  update(){
  Â  Â  if(!this.action || !this.action.frames.length) return;
  Â  Â  if(++this.t>=this.action.frames[this.i][2]){
  Â  Â  Â  this.t=0; this.i++;
  Â  Â  Â  if(this.i>=this.action.frames.length) this.i=this.action.loopStart||0;
  Â  Â  }
  Â  }
  Â  get frame(){ return this.action.frames[this.i]; }
  }
  
  
  
  
  
  
  
  
  
  
  /*
  ============================================================
  CAMERA
  ============================================================
  */
  
  class Camera {
  Â  constructor(x, y, width = 640, height = 480) {
  // Temp
  Â  Â  this.startPosition = { x, y };
  Â  Â  this.dimensions = { width, height };
  
  // IKEMEN
  Â  Â  this.stageCamera = new StageCamera();
  
  Â  Â  this.Pos = { x: 0, y: 0};
  Â  }
  
  Â  setDimensions(width, height) {
  Â  Â  this.dimensions = { width, height };
  Â  }
  
  Â  Update(scl, x, y, config) {
  Â  Â  if (this.Pos.x < 0) this.Pos.x = 0;
  Â  Â  if (this.Pos.y < 0) this.Pos.y = 0;
  Â  Â  if (this.Pos.x > this.dimensions.width - config.GameWidth) {
  Â  Â  Â  this.Pos.x = this.dimensions.width - config.GameWidth;
  Â  Â  }
  
  Â  Â  if (this.Pos.y > this.dimensions.height - config.GameHeight) {
  Â  Â  Â  this.Pos.y = this.dimensions.height - config.GameHeight;
  Â  Â  }
  Â  }
  }
  
  
  
  
  
  
  
  
  
  
  
  /*
  ============================================================
  CHAR (with palette support)
  ============================================================
  */
  
  class Char {
  Â  constructor() {
  Â  Â  this.pos = [0, 200];
  Â  Â  this.vel = [0,0];
  Â  Â  this.facing = 1;
  Â  Â  this.state = 0;
  
  Â  Â  this.anim = null;
  Â  Â  this.spriteData = null;
  Â  Â  this.pal = null;
  Â  Â  this.image = null; Â // palette-swapped spritesheet
  Â  }
  
  Â  trackableByCamera(){ return true; }
  
  Â  changeState(st){
  Â  Â  this.state = st;
  Â  Â  const act = air?.actions.get(st);
  Â  Â  if(act) this.anim = new AIRAnim(act);
  Â  }
  
  Â  update(isPlayer=false, time, context, config){
  Â  Â  // Player controls only for first character (P1)
  Â  Â  if(isPlayer){
  Â  Â  Â  switch(this.state){
  Â  Â  Â  Â  case 0:
  Â  Â  Â  Â  Â  if(keys.ArrowRight){ this.facing=1; this.changeState(20); }
  Â  Â  Â  Â  Â  else if(keys.ArrowLeft){ this.facing=1; this.changeState(21); }
  Â  Â  Â  Â  Â  break;
  Â  Â  Â  Â  case 20: if(!keys.ArrowRight)
  Â  Â  Â  Â  Â  this.changeState(0);
  Â  Â  Â  Â  Â  break;
  Â  Â  Â  Â  case 21: if(!keys.ArrowLeft)
  Â  Â  Â  Â  Â  this.changeState(0);
  Â  Â  Â  Â  Â  break;
  Â  Â  Â  }
  Â  Â  }
  
  Â  Â  if(this.state===20) this.pos[0]+=1.8;
  Â  Â  if(this.state===21) this.pos[0]-=1.2;
  
  Â  Â  this.anim?.update();
  Â  }
  
  Â  cueDraw(context, config, renderScale) {
  Â  Â  if (!this.anim || !this.spriteData || !this.image) return;
  Â  Â  const f = this.anim.frame;
  Â  Â  if (!f) return;
  Â  Â  const id = f[0];
  Â  Â  if (!id || id.startsWith("-")) return;
  
  Â  Â  const spr = this.spriteData[id];
  Â  Â  if (!spr) return;
  Â  Â  
  Â  Â  const off = f[1] || [0,0];
  Â  Â  const [ax, ay] = spr[0]; // Axis/Anchor
  Â  Â  const [sx, sy, sw, sh] = spr[1]; // Source Rect
  
  Â  Â  context.save();
  Â  Â  // Use raw character positions
  Â  Â  context.translate(this.pos[0] * renderScale, this.pos[1] * renderScale);
  Â  Â  context.scale(this.facing * renderScale, renderScale);
  
  Â  Â  // Draw 1:1. The CSS will scale this whole canvas to fit the screen.
  Â  Â  context.drawImage(
  Â  Â  Â  this.image,
  Â  Â  Â  sx, sy, sw, sh, Â  Â  Â // Source from palette-swapped sheet
  Â  Â  Â  -ax + off[0], Â  Â  Â  // Destination X
  Â  Â  Â  -ay + off[1], Â  Â  Â  // Destination Y
  Â  Â  Â  sw, sh Â  Â  Â  Â  Â  Â  Â  // Destination Width/Height
  Â  Â  );
  Â  Â  context.restore();
  Â  }
  
  Â  draw(context, config, renderScale) {
  Â  Â  this.cueDraw(context, config, renderScale);
  Â  }
  
    async loadFromFiles(charname, paletteKey = "1-1") {
      const name = charname.toLowerCase();
      let data;
      let imgBitmap;

      // 1. TRY LOCAL FILES FIRST
      const jsonFile = await getGameFile(`chars/${name}/${name}.json`);
      const imgFile = await getGameFile(`chars/${name}/${name}.png`);

      if (jsonFile && imgFile) {
        console.log(`Loading ${name} from local files...`);
        data = JSON.parse(await jsonFile.text());
        imgBitmap = await createImageBitmap(imgFile);
      } 
      // 2. FALLBACK TO FETCH ONLY IF LOCAL FILES WEREN'T FOUND AND WE ARE ON A SERVER
      else if (window.location.protocol.startsWith('http')) {
        console.log(`Loading ${name} via fetch...`);
        const res = await fetch(`./chars/${name}/${name}.json`);
        if (!res.ok) throw new Error("Failed to load JSON");
        data = await res.json();

        const img = new Image();
        img.src = `./chars/${name}/${name}.png`;
        await img.decode();
        imgBitmap = img;
      } 
      // 3. FINAL ERROR: No local files and not on a server
      else {
        console.error(`Files for ${name} not found locally, and fetch is unavailable on file:// protocol.`);
        return;
      }

      // === STORE DATA ===
      this.spriteData = data.sprite;
      this.pal = data.pal;

      if (!air) air = new AIR();
      for (const [id, a] of Object.entries(data.anim)) {
        air.actions.set(+id, a);
      }

      this.image = this.#createScaledSpritesheet(imgBitmap, paletteKey);
      this.changeState(0);
    }
  
  Â  #hexToRgb(hex){
  Â  Â  const bigint = parseInt(hex.replace("#",""),16);
  Â  Â  return { r:(bigint>>16)&255, g:(bigint>>8)&255, b:bigint&255 };
  Â  }
  
  Â  #applyPaletteSwap(ctx, paletteKey, w,h){
  Â  Â  if(!this.pal||paletteKey==="1-1") return;
  Â  Â  const imgData = ctx.getImageData(0,0,w,h);
  Â  Â  const pixels = imgData.data;
  Â  Â  const master = this.pal["1-1"];
  Â  Â  const target = this.pal[paletteKey];
  Â  Â  if(!master||!target) return;
  Â  Â  const map = new Map();
  Â  Â  master.forEach((hex,i)=> map.set(`${this.#hexToRgb(hex).r},${this.#hexToRgb(hex).g},${this.#hexToRgb(hex).b}`, i));
  Â  Â  const tRgb = target.map(hex=>this.#hexToRgb(hex));
  Â  Â  for(let i=0;i<pixels.length;i+=4){
  Â  Â  Â  if(pixels[i+3]===0) continue;
  Â  Â  Â  const key = `${pixels[i]},${pixels[i+1]},${pixels[i+2]}`;
  Â  Â  Â  const idx = map.get(key);
  Â  Â  Â  if(idx!==undefined){ const c=tRgb[idx]; pixels[i]=c.r; pixels[i+1]=c.g; pixels[i+2]=c.b; }
  Â  Â  }
  Â  Â  ctx.putImageData(imgData,0,0);
  Â  }
  
  Â  #createScaledSpritesheet(img, paletteKey) {
  Â  Â  const srcCanvas = document.createElement("canvas");
  Â  Â  srcCanvas.width = img.width;
  Â  Â  srcCanvas.height = img.height;
  
  Â  Â  const srcCtx = srcCanvas.getContext("2d", { willReadFrequently: true });
  Â  Â  srcCtx.drawImage(img, 0, 0);
  Â  Â  this.#applyPaletteSwap(srcCtx, paletteKey, img.width, img.height);
  
  Â  Â  const dstCanvas = document.createElement("canvas");
  Â  Â  dstCanvas.width = img.width;
  Â  Â  dstCanvas.height = img.height;
  
  Â  Â  const dstCtx = dstCanvas.getContext("2d");
  Â  Â  dstCtx.imageSmoothingEnabled = false;
  
  Â  Â  dstCtx.drawImage(
  Â  Â  Â  srcCanvas,
  Â  Â  Â  0, 0, img.width, img.height,
  Â  Â  Â  0, 0,
  Â  Â  Â  dstCanvas.width,
  Â  Â  Â  dstCanvas.height
  Â  Â  );
  
  Â  Â  return dstCanvas;
  Â  }
  }
  
  /*
  ============================================================
  CHAR LIST
  ============================================================
  */
  
  class CharList {
  Â  constructor(){ this.list=[]; }
  Â  add(c){ this.list.push(c); }
  Â  update(time, context, config){ this.list.forEach((c,i)=>c.update(i===0, time, context, config)); } // first char is player
  Â  cueDraw(context, config){ this.list.forEach(c=>c.cueDraw(context, config)); }
  }
  
  
  
  
  
  
  
  
  
  
  /*
  ============================================================
  CONFIG
  ============================================================
  */
  
  const defaultConfig = {
  Â  AIRamping: true,
  Â  AIRandomColor: true,
  Â  AISurvivalColor: true,
  Â  AudioDucking: false,
  Â  AudioSampleRate: 44100,
  Â  AutoGuard: false,
  Â  BarGuard: false,
  Â  BarRedLife: true,
  Â  BarStun: false,
  Â  Borderless: false,
  Â  ComboExtraFrameWindow: 1,
  Â  CommonAir: ["data/common.air"],
  Â  CommonCmd: ["data/common.cmd"],
  Â  CommonConst: ["data/common.const"],
  Â  CommonFx: ["data/common.fx"],
  Â  CommonLua: [],
  Â  CommonStates: ["data/common.states"],
  Â  ControllerStickSensitivity: 0.4,
  Â  Credits: 10,
  Â  DebugClipboardRows: 20,
  Â  DebugClsnDarken: true,
  Â  DebugConsoleRows: 15,
  Â  DebugFont: "font/f-4x6.fnt",
  Â  DebugFontScale: 1.0,
  Â  DebugKeys: true,
  Â  DebugMode: false,
  Â  Difficulty: 8,
  Â  EscOpensMenu: true,
  Â  ExternalShaders: [],
  Â  FirstRun: true,
  Â  FontShaderVer: 0,
  Â  ForceStageZoomin: 1.0,
  Â  ForceStageZoomout: 1.0,
  Â  Framerate: 60,
  Â  Fullscreen: false,
  Â  FullscreenRefreshRate: 60,
  Â  FullscreenWidth: 1280,
  Â  FullscreenHeight: 720,
  Â  GameWidth: 1280,
  Â  GameHeight: 720,
  Â  GameFramerate: 60,
  Â  IP: {},
  Â  LifeMul: 100,
  Â  ListenPort: "7500",
  Â  LoseSimul: true,
  Â  LoseTag: false,
  Â  MaxAfterImage: 128,
  Â  MaxBgmVolume: 100,
  Â  MaxDrawGames: 1,
  Â  MaxExplod: 512,
  Â  MaxHelper: 56,
  Â  MaxPlayerProjectile: 256,
  Â  Modules: [],
  Â  Motif: "data/system.def",
  Â  MSAA: false,
  Â  NumSimul: [2, 4],
  Â  NumTag: [2, 4],
  Â  NumTurns: [2, 4],
  Â  PanningRange: 100,
  Â  Players: 2,
  Â  PngSpriteFilter: false,
  Â  PostProcessingShader: 0,
  Â  QuickContinue: false,
  Â  RatioAttack: [0.82, 1.0, 1.17, 1.3],
  Â  RatioLife: [0.8, 1.0, 1.15, 1.3],
  Â  RatioRecoveryBase: 0,
  Â  RatioRecoveryBonus: 0,
  Â  RoundsNumSimul: 2,
  Â  RoundsNumSingle: 2,
  Â  RoundsNumTag: 2,
  Â  RoundTime: 99,
  Â  ScreenshotFolder: "ss",
  Â  StartStage: "stages/stage0.def",
  Â  StereoEffects: true,
  Â  System: "script/main.lua", // This will point to our JS entry logic later
  Â  Team1VS2Life: 100,
  Â  TeamDuplicates: false,
  Â  TeamLifeShare: false,
  Â  TeamPowerShare: true,
  Â  TrainingChar: "chars/kfm/kfm.def",
  Â  TurnsRecoveryBase: 0,
  Â  TurnsRecoveryBonus: 0,
  Â  VolumeBgm: 80,
  Â  VolumeMaster: 80,
  Â  VolumeSfx: 80,
  Â  VRetrace: 1,
  Â  WavChannels: 128,
  Â  WindowCentered: true,
  Â  WindowIcon: [],
  Â  WindowTitle: "FighterZ",
  Â  XinputTriggerSensitivity: 0.1,
  Â  ZoomActive: true,
  Â  ZoomDelay: false,
  Â  ZoomSpeed: 1.0,
  Â  KeyConfig: [
  Â  Â  { Joystick: -1, Buttons: ["UP", "DOWN", "LEFT", "RIGHT", "a", "b", "c", "x", "y", "z", "s", "d", "w", "m"] }
  Â  ],
  Â  JoystickConfig: []
  };
  
  async function saveConfig(configObj) {
  Â  try {
  Â  Â  const saveDir = await gameDirHandle.getDirectoryHandle("save", {
  Â  Â  Â  create: true
  Â  Â  });
  
  Â  Â  const fileHandle = await saveDir.getFileHandle("config.json", {
  Â  Â  Â  create: true
  Â  Â  });
  
  Â  Â  const writable = await fileHandle.createWritable();
  Â  Â  await writable.write(JSON.stringify(configObj, null, 2));
  Â  Â  await writable.close();
  Â  } catch (err) {
  Â  Â  console.error("Config save failed:", err);
  Â  }
  }
  
  
  
  
  
  
  
  
  
  
  
  /*
  ============================================================
  FPS COUNTER
  ============================================================
  */
  
  class FpsCounter {
  Â  constructor() {
  Â  Â  this.accumulator = 0;
  Â  Â  this.frames = 0;
  Â  Â  this.fps = 0;
  Â  Â  this.interval = 0.25; // 250 ms
  Â  }
  
  Â  // update(secondsPassed) {
  Â  // Â  this.fps = Math.trunc(1 / secondsPassed);
  Â  // }
  
  Â  update(deltaTime) {
  Â  Â  this.accumulator += deltaTime;
  Â  Â  this.frames++;
  
  Â  Â  if (this.accumulator >= this.interval) {
  Â  Â  Â  this.fps = Math.round(this.frames / this.accumulator);
  Â  Â  Â  this.accumulator = 0;
  Â  Â  Â  this.frames = 0;
  Â  Â  }
  Â  }
  
  Â  draw(context, config, renderScale) {
      const fontSize = Math.round(10 * renderScale);
      context.font = `${fontSize}px monospace`;
  Â  Â  context.textAlign = 'right';
  Â  Â  context.textBaseline = 'top';
  
  Â  Â  const text = `${this.fps}`;
      const padding = 2 * renderScale;
  Â  Â  const metrics = context.measureText(text);

      // 2. Calculate dimensions based on scaled metrics
      const textWidth = metrics.width;
      // Approximation for height based on font size
      const textHeight = fontSize;

      const boxWidth = textWidth + padding * 2;
      const boxHeight = textHeight + padding * 2;

      // 3. Position in the bottom right, scaled away from the edges
      const margin = 5 * renderScale;
      const x = context.canvas.width - margin;
      const y = context.canvas.height - margin - boxHeight;
  Â  Â  
      // Draw Background
      context.fillStyle = 'rgba(0, 0, 0, 0.65)';
      context.fillRect(x - boxWidth, y, boxWidth, boxHeight);

      // Draw Text
      context.fillStyle = 'white';
      context.fillText(text, x - padding, y + padding);
  Â  }
  }
  
  /*
  ============================================================
  STAGE CAMERA
  ============================================================
  */
  
  class StageCamera {
  Â  constructor() {
  Â  Â  this.startx = 0;
  Â  Â  this.boundleft = 0;
  Â  Â  this.boundright = 0;
  Â  Â  this.boundhigh = 0;
  Â  Â  this.boundlow = 0;
  
  Â  Â  this.verticalfollow = 0;
  
  Â  Â  this.floortension = 0;
  Â  Â  this.tensionhigh = 0;
  Â  Â  this.tensionlow = 0;
  Â  Â  this.tension = 0;
  Â  Â  this.tensionvel = 0;
  
  Â  Â  this.overdrawhigh = 0; // TODO: not implemented
  Â  Â  this.overdrawlow = 0;
  
  Â  Â  this.cuthigh = 0;
  Â  Â  this.cutlow = 0;
  
  Â  Â  this.localcoord = [0, 0];
  Â  Â  this.localscl = 0;
  
  Â  Â  this.zoffset = 0;
  Â  Â  this.ztopscale = 0;
  Â  Â  this.drawOffsetY = 0;
  
  Â  Â  this.startzoom = 0;
  Â  Â  this.zoomin = 0;
  Â  Â  this.zoomout = 0;
  
  Â  Â  this.ytensionenable = false;
  Â  Â  this.zoomanchor = false;
  Â  }
  }
  
  
  
  
  
  
  
  
  
  
  
  /* ============================================================
  GAME CLASS
  ============================================================ */
  
  class Game {
  Â  scene = null; // new Scene();
  Â  camera = new Camera(0, 0);
  Â  frameTime = { previous: 0, secondsPassed: 0 };
  Â  fpsCounter = new FpsCounter();
  Â  renderScale = 1;
  
  Â  constructor(config) {
  Â  Â  this.config = config || defaultConfig;
  Â  Â  this.context = document.querySelector('#game').getContext('2d');
  Â  Â  const canvasElement = this.context.canvas;
  
  Â  Â  // 1. Get dimensions from CSS :root
  Â  Â  const rootStyle = getComputedStyle(document.documentElement);
  Â  Â  const cssWidth = parseInt(rootStyle.getPropertyValue('--game-width')) || 1920;
  Â  Â  const cssHeight = parseInt(rootStyle.getPropertyValue('--game-height')) || 1080;
  
  Â  Â  // 2. Set the CANVAS resolution to the large size
  Â  Â  canvasElement.width = cssWidth;
  Â  Â  canvasElement.height = cssHeight;
  
  Â  Â  // 3. Calculate Scale based on the config internal width
  Â  Â  this.renderScale = cssWidth / this.config.GameWidth;
  
  Â  Â  // 4. IMPORTANT: Remove the lines that set canvas width/height to config
  Â  Â  // This allows the canvas to stay at the high resolution.
  Â  Â  this.context.imageSmoothingEnabled = false;
  Â  Â  
  Â  Â  this.camera = new Camera(0, 0, this.config.GameWidth, this.config.GameHeight);
  Â  Â  this.scene = new Scene();
  Â  Â  
  Â  Â  console.log(`Resolution: ${cssWidth}x${cssHeight} | Internal: ${this.config.GameWidth}x${this.config.GameHeight} | Scale: ${this.renderScale}`);
  Â  }
  
  Â  frame = (time) => {
  Â  Â  if (!this.frameTime.previous) {
  Â  Â  Â  this.frameTime.previous = time;
  Â  Â  Â  requestAnimationFrame(this.frame);
  Â  Â  Â  return;
  Â  Â  }
  Â  Â  window.requestAnimationFrame(this.frame);
  
  Â  Â  this.frameTime.secondsPassed = (time - this.frameTime.previous) / 1000;
  Â  Â  this.frameTime.previous = time;
  
  Â  Â  this.fpsCounter.update(this.frameTime.secondsPassed);
  Â  Â  this.scene.update(this.frameTime, this.context, this.camera, this.config);
  Â  Â  
  Â  Â  // Crucial: pass the scale to the scene draw
  Â  Â  this.scene.draw(this.context, this.camera, this.config, this.renderScale);
  
  Â  Â  if (this.config.DebugMode || ENABLE_DEBUG) {
  Â  Â  Â  this.fpsCounter.draw(this.context, this.config, this.renderScale);
  Â  Â  }
  Â  };
  
  Â  async start() {
  Â  Â  const config = await Game.setupConfig();
  Â  Â  const game = new Game(config);
  
  Â  Â  this.camera.setDimensions(config.GameWidth, config.GameHeight)
  
  // Â  Â  RENDER_SCALE =
  // Â  Â  Â  Â  Math.min(
  // Â  Â  Â  Â  Â  window.innerWidth / config.GameWidth,
  // Â  Â  Â  Â  Â  window.innerHeight / config.GameHeight
  // Â  Â  Â  Â  )
  
  // RENDER_SCALE = 1;
  // console.log(`RENDER_SCALE: ${RENDER_SCALE}`);
  
  Â  Â  game.init();
  Â  }
  
  Â  init() {
  Â  Â  // registerKeyEvents();
  Â  Â  // registerGamepadEvents();
  
  Â  Â  window.requestAnimationFrame(this.frame);
  Â  }

  static async setupConfig() {
  let config = { ...defaultConfig };

  // Only try getGameFile if a folder has been selected
  if (gameDirHandle || firefoxFiles) {
    try {
      const file = await getGameFile("save/config.json");

      if (file) {
        const text = await file.text();
        const parsed = JSON.parse(text);
        console.log("âœ… CONFIG: Loaded from selected folder (" + (supportsDirectoryPicker ? "Chrome" : "Firefox") + " mode)");
        return { ...config, ...parsed };
      }
    } catch (err) {
      console.warn("âš ï¸ CONFIG: config.json not found in selected folder's 'save/' directory.");
    }
  }

  // Web Server Fallback (Only if running on http/https)
  if (window.location.protocol.startsWith('http')) {
    try {
      const response = await fetch('./save/config.json');
      if (response.ok) {
        const parsed = await response.json();
        console.log("âœ… CONFIG: Loaded from web server.");
        return { ...config, ...parsed };
      }
    } catch (e) { 
      console.warn("âš ï¸ CONFIG: config.json not found on web server.");
    }
  } else {
    console.info("â„¹ï¸ Running on file:// protocol - folder selection required for local files.");
  }

  console.log("â„¹ï¸ CONFIG: Using hardcoded defaults.");
  return config;
}
  
  Â  // async saveConfig(configObj) {
  Â  // Â  try {
  Â  // Â  Â  const saveDir = await gameDirHandle.getDirectoryHandle("save", {
  Â  // Â  Â  Â  create: true
  Â  // Â  Â  });
  
  Â  // Â  Â  const fileHandle = await saveDir.getFileHandle("config.json", {
  Â  // Â  Â  Â  create: true
  Â  // Â  Â  });
  
  Â  // Â  Â  const writable = await fileHandle.createWritable();
  Â  // Â  Â  await writable.write(JSON.stringify(configObj, null, 2));
  Â  // Â  Â  await writable.close();
  Â  // Â  } catch (err) {
  Â  // Â  Â  console.error("Config save failed:", err);
  Â  // Â  }
  Â  // }
  }
  
  
  
  
  
  
  
  
  
  
  /*
  ============================================================
  SCENE - TEMP ???
  ============================================================
  */
  
  class Scene {
  Â  constructor () {
  Â  Â  let entities = [];
  Â  Â  let imageP1 = new Image();
  Â  Â  let imageP2 = new Image();
  Â  Â  let imageBackground = new Image();
  
  Â  Â  this.chars = new CharList();
  Â  Â  this.P1 = new Char();
  Â  Â  this.P2 = new Char();
  Â  Â  this.stage = new Stage();
  
  // Â  Â  let battleSelItems = ['background', 'subzero', '1-1', 'scorpion', '1-1'];
  Â  Â  let battleSelItems = ['background', 'ryu', '1-4', 'ken', '1-4'];
  
  Â  Â  this.entities = [
  Â  Â  Â  new Stage(`./stages/${battleSelItems[0]}.png`),
  Â  Â  Â  this.P1,
  Â  Â  Â  this.P2,
  Â  Â  ];
  
  Â  Â  Promise.all([
  Â  Â  Â  this.P1.loadFromFiles(battleSelItems[1], battleSelItems[2]),
  Â  Â  Â  this.P2.loadFromFiles(battleSelItems[3], battleSelItems[4]),
  Â  Â  ]).then(() => {
  Â  Â  Â  // Ryu, Ken
  Â  Â  Â  this.P1.frame = [166, 24, 59, 90];
  Â  Â  Â  this.P2.frame = [166, 24, 55, 93];
  Â  
  Â  Â  Â  this.P1.pos = [80, 190];
  Â  Â  Â  this.P2.pos = [280, 190];
  
  Â  Â  Â  // this.P1.vel.x = 150;
  Â  Â  Â  // this.P2.vel.x = -150;
  Â  Â  });
  Â  }
  
  Â  update(time, context, camera, config) {
  Â  Â  camera.Update(time, 0, 0, config);
  
  Â  Â  for (const entity of this.entities) {
  Â  Â  Â  entity.update(time.secondsPassed, context, config);
  Â  Â  }
  Â  }
  
  Â  draw(context, camera, config, renderScale) {
  // Â  Â  context.clearRect(0, 0, config.GameWidth, config.GameHeight);
  Â  Â  context.clearRect(0, 0, context.canvas.width, context.canvas.height);
  
  Â  Â  for (const entity of this.entities) {
  Â  Â  Â  entity.draw(context, config, renderScale);
  Â  Â  }
  Â  }
  }
  
  
  
  
  
  
  
  
  
  
  /*
  ============================================================
  STAGE - TEMP ???
  ============================================================
  */
  
  class Stage {
  Â  constructor(imageBackground) {
  Â  Â  this.image = new Image();
  
  Â  Â  if (imageBackground) {
  Â  Â  Â  this.image.src = imageBackground;
  Â  Â  }
  Â  }
  
  Â  update() {}
  
  Â  draw(context, config, renderScale) {
  Â  Â  if (this.image.complete && this.image.naturalWidth > 0) {
  Â  Â  Â  context.drawImage(
  Â  Â  Â  Â  this.image, 
  Â  Â  Â  Â  0, 0, 
  Â  Â  Â  Â  this.image.width * renderScale, 
  Â  Â  Â  Â  this.image.height * renderScale
  Â  Â  Â  );
  Â  Â  }
  Â  }
  }
  
  </script>
  

</body>
</html>